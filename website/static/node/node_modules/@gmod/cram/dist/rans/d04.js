"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const constants_1 = require("./constants");
const decoding_1 = __importDefault(require("./decoding"));
function uncompress(
/* ByteBuffer */ input, 
/* Decoding.AriDecoder */ D, 
/* Decoding.Symbol[] */ syms, 
/* ByteBuffer */ out) {
    let rans0 = input.getInt();
    let rans1 = input.getInt();
    let rans2 = input.getInt();
    let rans3 = input.getInt();
    const /* int */ outputSize = out.remaining();
    const /* int */ outputEnd = outputSize & ~3;
    for (let i = 0; i < outputEnd; i += 4) {
        const /* byte */ c0 = D.R[decoding_1.default.get(rans0, constants_1.TF_SHIFT)];
        const /* byte */ c1 = D.R[decoding_1.default.get(rans1, constants_1.TF_SHIFT)];
        const /* byte */ c2 = D.R[decoding_1.default.get(rans2, constants_1.TF_SHIFT)];
        const /* byte */ c3 = D.R[decoding_1.default.get(rans3, constants_1.TF_SHIFT)];
        out.putAt(i, c0);
        out.putAt(i + 1, c1);
        out.putAt(i + 2, c2);
        out.putAt(i + 3, c3);
        rans0 = decoding_1.default.advanceSymbolStep(rans0, syms[0xff & c0], constants_1.TF_SHIFT);
        rans1 = decoding_1.default.advanceSymbolStep(rans1, syms[0xff & c1], constants_1.TF_SHIFT);
        rans2 = decoding_1.default.advanceSymbolStep(rans2, syms[0xff & c2], constants_1.TF_SHIFT);
        rans3 = decoding_1.default.advanceSymbolStep(rans3, syms[0xff & c3], constants_1.TF_SHIFT);
        rans0 = decoding_1.default.renormalize(rans0, input);
        rans1 = decoding_1.default.renormalize(rans1, input);
        rans2 = decoding_1.default.renormalize(rans2, input);
        rans3 = decoding_1.default.renormalize(rans3, input);
    }
    out.setPosition(outputEnd);
    let /* byte */ c;
    switch (outputSize & 3) {
        case 0:
            break;
        case 1:
            c = D.R[decoding_1.default.get(rans0, constants_1.TF_SHIFT)];
            decoding_1.default.advanceSymbol(rans0, input, syms[0xff & c], constants_1.TF_SHIFT);
            out.put(c);
            break;
        case 2:
            c = D.R[decoding_1.default.get(rans0, constants_1.TF_SHIFT)];
            decoding_1.default.advanceSymbol(rans0, input, syms[0xff & c], constants_1.TF_SHIFT);
            out.put(c);
            c = D.R[decoding_1.default.get(rans1, constants_1.TF_SHIFT)];
            decoding_1.default.advanceSymbol(rans1, input, syms[0xff & c], constants_1.TF_SHIFT);
            out.put(c);
            break;
        case 3:
            c = D.R[decoding_1.default.get(rans0, constants_1.TF_SHIFT)];
            decoding_1.default.advanceSymbol(rans0, input, syms[0xff & c], constants_1.TF_SHIFT);
            out.put(c);
            c = D.R[decoding_1.default.get(rans1, constants_1.TF_SHIFT)];
            decoding_1.default.advanceSymbol(rans1, input, syms[0xff & c], constants_1.TF_SHIFT);
            out.put(c);
            c = D.R[decoding_1.default.get(rans2, constants_1.TF_SHIFT)];
            decoding_1.default.advanceSymbol(rans2, input, syms[0xff & c], constants_1.TF_SHIFT);
            out.put(c);
            break;
        default:
            throw new errors_1.CramMalformedError('invalid output size encountered during rANS decoding');
    }
    out.setPosition(0);
}
exports.default = uncompress;
//# sourceMappingURL=d04.js.map