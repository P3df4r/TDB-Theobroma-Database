"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const abortable_promise_cache_1 = __importDefault(require("abortable-promise-cache"));
const quick_lru_1 = __importDefault(require("quick-lru"));
const unzip_1 = require("./unzip");
const io_1 = require("./io");
const errors_1 = require("./errors");
const BAI_MAGIC = 21578050; // BAI\1
function addRecordToIndex(index, record) {
    if (record.some(el => el === undefined)) {
        throw new errors_1.CramMalformedError('invalid .crai index file');
    }
    const [seqId, start, span, containerStart, sliceStart, sliceBytes] = record;
    if (!index[seqId]) {
        index[seqId] = [];
    }
    index[seqId].push({
        start,
        span,
        containerStart,
        sliceStart,
        sliceBytes,
    });
}
class CraiIndex {
    /**
     *
     * @param {object} args
     * @param {string} [args.path]
     * @param {string} [args.url]
     * @param {FileHandle} [args.filehandle]
     */
    constructor(args) {
        this.filehandle = (0, io_1.open)(args.url, args.path, args.filehandle);
        this._parseCache = new abortable_promise_cache_1.default({
            cache: new quick_lru_1.default({ maxSize: 1 }),
            fill: (data, signal) => this.parseIndex(),
        });
    }
    parseIndex() {
        const index = {};
        return this.filehandle
            .readFile()
            .then(data => {
            if (data[0] === 31 && data[1] === 139) {
                return (0, unzip_1.unzip)(data);
            }
            return data;
        })
            .then(uncompressedBuffer => {
            if (uncompressedBuffer.length > 4 &&
                uncompressedBuffer.readUInt32LE(0) === BAI_MAGIC) {
                throw new errors_1.CramMalformedError('invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support');
            }
            // interpret the text as regular ascii, since it is
            // supposed to be only digits and whitespace characters
            // this is written in a deliberately low-level fashion for performance,
            // because some .crai files can be pretty large.
            let currentRecord = [];
            let currentString = '';
            for (let i = 0; i < uncompressedBuffer.length; i += 1) {
                const charCode = uncompressedBuffer[i];
                if ((charCode >= 48 && charCode <= 57) /* 0-9 */ ||
                    (!currentString && charCode === 45) /* leading - */) {
                    currentString += String.fromCharCode(charCode);
                }
                else if (charCode === 9 /* \t */) {
                    currentRecord.push(Number.parseInt(currentString, 10));
                    currentString = '';
                }
                else if (charCode === 10 /* \n */) {
                    currentRecord.push(Number.parseInt(currentString, 10));
                    currentString = '';
                    addRecordToIndex(index, currentRecord);
                    currentRecord = [];
                }
                else if (charCode !== 13 /* \r */ && charCode !== 32 /* space */) {
                    // if there are other characters in the file besides
                    // space and \r, something is wrong.
                    throw new errors_1.CramMalformedError('invalid .crai index file');
                }
            }
            // if the file ends without a \n, we need to flush our buffers
            if (currentString) {
                currentRecord.push(Number.parseInt(currentString, 10));
            }
            if (currentRecord.length === 6) {
                addRecordToIndex(index, currentRecord);
            }
            // sort each of them by start
            Object.entries(index).forEach(([seqId, ent]) => {
                index[seqId] = ent.sort((a, b) => a.start - b.start || a.span - b.span);
            });
            return index;
        });
    }
    getIndex(opts = {}) {
        return this._parseCache.get('index', null, opts.signal);
    }
    /**
     * @param {number} seqId
     * @returns {Promise} true if the index contains entries for
     * the given reference sequence ID, false otherwise
     */
    hasDataForReferenceSequence(seqId) {
        return __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getIndex())[seqId];
        });
    }
    /**
     * fetch index entries for the given range
     *
     * @param {number} seqId
     * @param {number} queryStart
     * @param {number} queryEnd
     *
     * @returns {Promise} promise for
     * an array of objects of the form
     * `{start, span, containerStart, sliceStart, sliceBytes }`
     */
    getEntriesForRange(seqId, queryStart, queryEnd) {
        return __awaiter(this, void 0, void 0, function* () {
            const seqEntries = (yield this.getIndex())[seqId];
            if (!seqEntries) {
                return [];
            }
            const compare = (entry) => {
                const entryStart = entry.start;
                const entryEnd = entry.start + entry.span;
                if (entryStart > queryEnd) {
                    return -1;
                } // entry is ahead of query
                if (entryEnd <= queryStart) {
                    return 1;
                } // entry is behind query
                return 0; // entry overlaps query
            };
            const bins = [];
            for (let i = 0; i < seqEntries.length; i += 1) {
                if (compare(seqEntries[i]) === 0) {
                    bins.push(seqEntries[i]);
                }
            }
            return bins;
        });
    }
}
exports.default = CraiIndex;
//# sourceMappingURL=craiIndex.js.map