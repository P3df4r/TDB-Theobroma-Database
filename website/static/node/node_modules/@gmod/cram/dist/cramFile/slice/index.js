"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const util_1 = require("../util");
const constants_1 = __importDefault(require("../constants"));
const decodeRecord_1 = __importDefault(require("./decodeRecord"));
const record_1 = __importDefault(require("../record"));
const sectionParsers_1 = require("../sectionParsers");
const getBits_1 = require("../codecs/getBits");
/**
 * @private
 * Try to estimate the template length from a bunch of interrelated multi-segment reads.
 * @param {Array[CramRecord]} allRecords
 * @param {number} currentRecordNumber
 * @param {CramRecord} thisRecord
 */
function calculateMultiSegmentMatedTemplateLength(allRecords, currentRecordNumber, thisRecord) {
    function getAllMatedRecords(startRecord) {
        const records = [startRecord];
        if (startRecord.mateRecordNumber !== undefined &&
            startRecord.mateRecordNumber >= 0) {
            const mateRecord = allRecords[startRecord.mateRecordNumber];
            if (!mateRecord) {
                throw new errors_1.CramMalformedError('intra-slice mate record not found, this file seems malformed');
            }
            records.push(...getAllMatedRecords(mateRecord));
        }
        return records;
    }
    const matedRecords = getAllMatedRecords(thisRecord);
    const starts = matedRecords.map(r => r.alignmentStart);
    const ends = matedRecords.map(r => r.alignmentStart + r.readLength - 1);
    const estimatedTemplateLength = Math.max(...ends) - Math.min(...starts) + 1;
    if (estimatedTemplateLength >= 0) {
        matedRecords.forEach(r => {
            if (r.templateLength !== undefined) {
                throw new errors_1.CramMalformedError('mate pair group has some members that have template lengths already, this file seems malformed');
            }
            r.templateLength = estimatedTemplateLength;
        });
    }
}
/**
 * @private
 * Attempt to calculate the `templateLength` for a pair of intra-slice paired reads.
 * Ported from htslib. Algorithm is imperfect.
 * @param {CramRecord} thisRecord
 * @param {CramRecord} mateRecord
 */
function calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord) {
    // this just estimates the template length by using the simple (non-gapped) end coordinate of each
    // read, because gapping in the alignment doesn't mean the template is longer or shorter
    const start = Math.min(thisRecord.alignmentStart, mateRecord.alignmentStart);
    const end = Math.max(thisRecord.alignmentStart + thisRecord.readLength - 1, mateRecord.alignmentStart + mateRecord.readLength - 1);
    const lengthEstimate = end - start + 1;
    thisRecord.templateLength = lengthEstimate;
    mateRecord.templateLength = lengthEstimate;
}
/**
 * @private establishes a mate-pair relationship between two records in the same slice.
 * CRAM compresses mate-pair relationships between records in the same slice down into
 * just one record having the index in the slice of its mate
 */
function associateIntraSliceMate(allRecords, currentRecordNumber, thisRecord, mateRecord) {
    if (!mateRecord) {
        throw new errors_1.CramMalformedError('could not resolve intra-slice mate pairs, file seems truncated or malformed');
    }
    const complicatedMultiSegment = !!(mateRecord.mate ||
        (mateRecord.mateRecordNumber !== undefined &&
            mateRecord.mateRecordNumber !== currentRecordNumber));
    // Deal with lossy read names
    if (!thisRecord.readName) {
        thisRecord.readName = String(thisRecord.uniqueId);
        mateRecord.readName = thisRecord.readName;
    }
    thisRecord.mate = {
        sequenceId: mateRecord.sequenceId,
        alignmentStart: mateRecord.alignmentStart,
        uniqueId: mateRecord.uniqueId,
    };
    if (mateRecord.readName) {
        thisRecord.mate.readName = mateRecord.readName;
    }
    // the mate record might have its own mate pointer, if this is some kind of
    // multi-segment (more than paired) scheme, so only relate that one back to this one
    // if it does not have any other relationship
    if (!mateRecord.mate && mateRecord.mateRecordNumber === undefined) {
        mateRecord.mate = {
            sequenceId: thisRecord.sequenceId,
            alignmentStart: thisRecord.alignmentStart,
            uniqueId: thisRecord.uniqueId,
        };
        if (thisRecord.readName) {
            mateRecord.mate.readName = thisRecord.readName;
        }
    }
    // make sure the proper flags and cramFlags are set on both records
    // paired
    thisRecord.flags |= constants_1.default.BAM_FPAIRED;
    // set mate unmapped if needed
    if (mateRecord.flags & constants_1.default.BAM_FUNMAP) {
        thisRecord.flags |= constants_1.default.BAM_FMUNMAP;
        // thisRecord.templateLength = 0
    }
    if (thisRecord.flags & constants_1.default.BAM_FUNMAP) {
        // thisRecord.templateLength = 0
        mateRecord.flags |= constants_1.default.BAM_FMUNMAP;
    }
    // set mate reversed if needed
    if (mateRecord.flags & constants_1.default.BAM_FREVERSE) {
        thisRecord.flags |= constants_1.default.BAM_FMREVERSE;
    }
    if (thisRecord.flags & constants_1.default.BAM_FREVERSE) {
        mateRecord.flags |= constants_1.default.BAM_FMREVERSE;
    }
    if (thisRecord.templateLength === undefined) {
        if (complicatedMultiSegment) {
            calculateMultiSegmentMatedTemplateLength(allRecords, currentRecordNumber, thisRecord);
        }
        else {
            calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord);
        }
    }
    // delete this last because it's used by the
    // complicated template length estimation
    delete thisRecord.mateRecordNumber;
}
class CramSlice {
    constructor(container, containerPosition, _unused) {
        this.container = container;
        this.containerPosition = containerPosition;
        this.file = container.file;
    }
    // memoize
    getHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch and parse the slice header
            const sectionParsers = yield this.file.getSectionParsers();
            const containerHeader = yield this.container.getHeader();
            const header = yield this.file.readBlock(containerHeader._endPosition + this.containerPosition);
            if (header === undefined) {
                throw new Error();
            }
            if (header.contentType === 'MAPPED_SLICE_HEADER') {
                const content = (0, util_1.parseItem)(header.content, sectionParsers.cramMappedSliceHeader.parser, 0, containerHeader._endPosition);
                return Object.assign(Object.assign({}, header), { parsedContent: content });
            }
            else if (header.contentType === 'UNMAPPED_SLICE_HEADER') {
                const content = (0, util_1.parseItem)(header.content, sectionParsers.cramUnmappedSliceHeader.parser, 0, containerHeader._endPosition);
                return Object.assign(Object.assign({}, header), { parsedContent: content });
            }
            else {
                throw new errors_1.CramMalformedError(`error reading slice header block, invalid content type ${header.contentType}`);
            }
        });
    }
    // memoize
    getBlocks() {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.getHeader();
            // read all the blocks into memory and store them
            let blockPosition = header._endPosition;
            const blocks = new Array(header.parsedContent.numBlocks);
            for (let i = 0; i < blocks.length; i += 1) {
                const block = yield this.file.readBlock(blockPosition);
                if (block === undefined) {
                    throw new Error();
                }
                blocks[i] = block;
                blockPosition = blocks[i]._endPosition;
            }
            return blocks;
        });
    }
    // no memoize
    getCoreDataBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const blocks = yield this.getBlocks();
            // the core data block is always the first block in the slice
            return blocks[0];
        });
    }
    // memoize
    _getBlocksContentIdIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            const blocks = yield this.getBlocks();
            const blocksByContentId = {};
            blocks.forEach(block => {
                if (block.contentType === 'EXTERNAL_DATA') {
                    blocksByContentId[block.contentId] = block;
                }
            });
            return blocksByContentId;
        });
    }
    getBlockByContentId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const blocksByContentId = yield this._getBlocksContentIdIndex();
            return blocksByContentId[id];
        });
    }
    getReferenceRegion() {
        return __awaiter(this, void 0, void 0, function* () {
            // read the slice header
            const sliceHeader = (yield this.getHeader()).parsedContent;
            if (!(0, sectionParsers_1.isMappedSliceHeader)(sliceHeader)) {
                throw new Error();
            }
            if (sliceHeader.refSeqId < 0) {
                return undefined;
            }
            const compressionScheme = yield this.container.getCompressionScheme();
            if (compressionScheme === undefined) {
                throw new Error();
            }
            // console.log(JSON.stringify(sliceHeader, null, '  '))
            if (sliceHeader.refBaseBlockId >= 0) {
                const refBlock = yield this.getBlockByContentId(sliceHeader.refBaseBlockId);
                if (!refBlock) {
                    throw new errors_1.CramMalformedError('embedded reference specified, but reference block does not exist');
                }
                // TODO: we do not read anything named 'span'
                // if (sliceHeader.span > refBlock.uncompressedSize) {
                //   throw new CramMalformedError('Embedded reference is too small')
                // }
                // TODO verify
                return {
                    seq: refBlock.data.toString('utf8'),
                    start: sliceHeader.refSeqStart,
                    end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,
                    span: sliceHeader.refSeqSpan,
                };
            }
            if (compressionScheme.referenceRequired ||
                this.file.fetchReferenceSequenceCallback) {
                if (!this.file.fetchReferenceSequenceCallback) {
                    throw new Error('reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence');
                }
                const seq = yield this.file.fetchReferenceSequenceCallback(sliceHeader.refSeqId, sliceHeader.refSeqStart, sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1);
                if (seq.length !== sliceHeader.refSeqSpan) {
                    throw new errors_1.CramArgumentError('seqFetch callback returned a reference sequence of the wrong length');
                }
                return {
                    seq,
                    start: sliceHeader.refSeqStart,
                    end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,
                    span: sliceHeader.refSeqSpan,
                };
            }
            return undefined;
        });
    }
    getAllRecords() {
        return this.getRecords(() => true);
    }
    _fetchRecords() {
        return __awaiter(this, void 0, void 0, function* () {
            const { majorVersion } = yield this.file.getDefinition();
            const compressionScheme = yield this.container.getCompressionScheme();
            if (compressionScheme === undefined) {
                throw new Error();
            }
            const sliceHeader = yield this.getHeader();
            if (sliceHeader === undefined) {
                throw new Error();
            }
            const blocksByContentId = yield this._getBlocksContentIdIndex();
            // check MD5 of reference if available
            if (majorVersion > 1 &&
                this.file.options.checkSequenceMD5 &&
                (0, sectionParsers_1.isMappedSliceHeader)(sliceHeader.parsedContent) &&
                sliceHeader.parsedContent.refSeqId >= 0 &&
                sliceHeader.parsedContent.md5.join('') !== '0000000000000000') {
                const refRegion = yield this.getReferenceRegion();
                if (refRegion) {
                    const { seq, start, end } = refRegion;
                    const seqMd5 = (0, util_1.sequenceMD5)(seq);
                    const storedMd5 = sliceHeader.parsedContent.md5
                        .map(byte => (byte < 16 ? '0' : '') + byte.toString(16))
                        .join('');
                    if (seqMd5 !== storedMd5) {
                        throw new errors_1.CramMalformedError(`MD5 checksum reference mismatch for ref ${sliceHeader.parsedContent.refSeqId} pos ${start}..${end}. recorded MD5: ${storedMd5}, calculated MD5: ${seqMd5}`);
                    }
                }
            }
            // tracks the read position within the block. codec.decode() methods
            // advance the byte and bit positions in the cursor as they decode
            // data note that we are only decoding a single block here, the core
            // data block
            const coreDataBlock = yield this.getCoreDataBlock();
            const cursors = {
                lastAlignmentStart: (0, sectionParsers_1.isMappedSliceHeader)(sliceHeader.parsedContent)
                    ? sliceHeader.parsedContent.refSeqStart
                    : 0,
                coreBlock: { bitPosition: 7, bytePosition: 0 },
                externalBlocks: {
                    map: new Map(),
                    getCursor(contentId) {
                        let r = this.map.get(contentId);
                        if (r === undefined) {
                            r = { bitPosition: 7, bytePosition: 0 };
                            this.map.set(contentId, r);
                        }
                        return r;
                    },
                },
            };
            const decodeDataSeries = (dataSeriesName) => {
                const codec = compressionScheme.getCodecForDataSeries(dataSeriesName);
                if (!codec) {
                    throw new errors_1.CramMalformedError(`no codec defined for ${dataSeriesName} data series`);
                }
                // console.log(dataSeriesName, Object.getPrototypeOf(codec))
                const decoded = codec.decode(this, coreDataBlock, blocksByContentId, cursors);
                return decoded;
            };
            let records = new Array(sliceHeader.parsedContent.numRecords);
            for (let i = 0; i < records.length; i += 1) {
                try {
                    const init = (0, decodeRecord_1.default)(this, decodeDataSeries, compressionScheme, sliceHeader, coreDataBlock, blocksByContentId, cursors, majorVersion, i);
                    records[i] = new record_1.default(Object.assign(Object.assign({}, init), { uniqueId: sliceHeader.contentPosition +
                            sliceHeader.parsedContent.recordCounter +
                            i +
                            1 }));
                }
                catch (e) {
                    if (e instanceof getBits_1.CramBufferOverrunError) {
                        console.warn('read attempted beyond end of buffer, file seems truncated.');
                        records = records.filter(r => !!r);
                        break;
                    }
                    else {
                        throw e;
                    }
                }
            }
            // interpret `recordsToNextFragment` attributes to make standard `mate`
            // objects Resolve mate pair cross-references between records in this slice
            for (let i = 0; i < records.length; i += 1) {
                const { mateRecordNumber } = records[i];
                if (mateRecordNumber !== undefined && mateRecordNumber >= 0) {
                    associateIntraSliceMate(records, i, records[i], records[mateRecordNumber]);
                }
            }
            return records;
        });
    }
    getRecords(filterFunction) {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch the features if necessary, using the file-level feature cache
            const cacheKey = this.container.filePosition + this.containerPosition;
            let recordsPromise = this.file.featureCache.get(cacheKey.toString());
            if (!recordsPromise) {
                recordsPromise = this._fetchRecords();
                this.file.featureCache.set(cacheKey.toString(), recordsPromise);
            }
            const unfiltered = yield recordsPromise;
            const records = unfiltered.filter(filterFunction);
            // if we can fetch reference sequence, add the reference sequence to the records
            if (records.length && this.file.fetchReferenceSequenceCallback) {
                const sliceHeader = yield this.getHeader();
                if ((0, sectionParsers_1.isMappedSliceHeader)(sliceHeader.parsedContent) &&
                    (sliceHeader.parsedContent.refSeqId >= 0 || // single-ref slice
                        sliceHeader.parsedContent.refSeqId === -2) // multi-ref slice
                ) {
                    const singleRefId = sliceHeader.parsedContent.refSeqId >= 0
                        ? sliceHeader.parsedContent.refSeqId
                        : undefined;
                    const compressionScheme = yield this.container.getCompressionScheme();
                    if (compressionScheme === undefined) {
                        throw new Error();
                    }
                    const refRegions = {}; // seqId => { start, end, seq }
                    // iterate over the records to find the spans of the reference sequences we need to fetch
                    for (let i = 0; i < records.length; i += 1) {
                        const seqId = singleRefId !== undefined ? singleRefId : records[i].sequenceId;
                        let refRegion = refRegions[seqId];
                        if (!refRegion) {
                            refRegion = {
                                id: seqId,
                                start: records[i].alignmentStart,
                                end: -Infinity,
                                seq: null,
                            };
                            refRegions[seqId] = refRegion;
                        }
                        const end = records[i].alignmentStart +
                            (records[i].lengthOnRef || records[i].readLength) -
                            1;
                        if (end > refRegion.end) {
                            refRegion.end = end;
                        }
                        if (records[i].alignmentStart < refRegion.start) {
                            refRegion.start = records[i].alignmentStart;
                        }
                    }
                    // fetch the `seq` for all of the ref regions
                    yield Promise.all(Object.values(refRegions).map((refRegion) => __awaiter(this, void 0, void 0, function* () {
                        if (refRegion.id !== -1 && refRegion.start <= refRegion.end) {
                            refRegion.seq = yield this.file.fetchReferenceSequenceCallback(refRegion.id, refRegion.start, refRegion.end);
                        }
                    })));
                    // now decorate all the records with them
                    for (let i = 0; i < records.length; i += 1) {
                        const seqId = singleRefId !== undefined ? singleRefId : records[i].sequenceId;
                        const refRegion = refRegions[seqId];
                        if (refRegion && refRegion.seq) {
                            const seq = refRegion.seq;
                            records[i].addReferenceSequence(Object.assign(Object.assign({}, refRegion), { seq }), compressionScheme);
                        }
                    }
                }
            }
            return records;
        });
    }
}
exports.default = CramSlice;
// memoize several methods in the class for performance
'getHeader getBlocks _getBlocksContentIdIndex'
    .split(' ')
    .forEach(method => (0, util_1.tinyMemoize)(CramSlice, method));
//# sourceMappingURL=index.js.map