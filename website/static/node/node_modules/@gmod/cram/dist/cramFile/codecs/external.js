"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const _base_1 = __importDefault(require("./_base"));
const util_1 = require("../util");
const getBits_1 = require("./getBits");
class ExternalCodec extends _base_1.default {
    constructor(parameters, dataType) {
        super(parameters, dataType);
        if (this.dataType === 'int') {
            this._decodeData = this._decodeInt;
        }
        else if (this.dataType === 'byte') {
            this._decodeData = this._decodeByte;
        }
        else {
            throw new errors_1.CramUnimplementedError(`${this.dataType} decoding not yet implemented by EXTERNAL codec`);
        }
    }
    decode(slice, coreDataBlock, blocksByContentId, cursors) {
        const { blockContentId } = this.parameters;
        const contentBlock = blocksByContentId[blockContentId];
        if (!contentBlock) {
            throw new errors_1.CramMalformedError(`no block found with content ID ${blockContentId}`);
        }
        const cursor = cursors.externalBlocks.getCursor(blockContentId);
        return this._decodeData(contentBlock, cursor);
    }
    _decodeInt(contentBlock, cursor) {
        const [result, bytesRead] = (0, util_1.parseItf8)(contentBlock.content, cursor.bytePosition);
        cursor.bytePosition = cursor.bytePosition + bytesRead;
        return result;
    }
    _decodeByte(contentBlock, cursor) {
        if (cursor.bytePosition >= contentBlock.content.length) {
            throw new getBits_1.CramBufferOverrunError('attempted to read beyond end of block. this file seems truncated.');
        }
        return contentBlock.content[cursor.bytePosition++];
    }
}
exports.default = ExternalCodec;
//# sourceMappingURL=external.js.map