"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sequenceMD5 = exports.tinyMemoize = exports.parseItem = exports.parseItf8 = exports.itf8Size = void 0;
const md5_1 = __importDefault(require("md5"));
const getBits_1 = require("./codecs/getBits");
function itf8Size(v) {
    if (!(v & ~0x7f)) {
        return 1;
    }
    if (!(v & ~0x3fff)) {
        return 2;
    }
    if (!(v & ~0x1fffff)) {
        return 3;
    }
    if (!(v & ~0xfffffff)) {
        return 4;
    }
    return 5;
}
exports.itf8Size = itf8Size;
function parseItf8(buffer, initialOffset) {
    let offset = initialOffset;
    const countFlags = buffer[offset];
    let result;
    if (countFlags < 0x80) {
        result = countFlags;
        offset = offset + 1;
    }
    else if (countFlags < 0xc0) {
        result = ((countFlags << 8) | buffer[offset + 1]) & 0x3fff;
        offset = offset + 2;
    }
    else if (countFlags < 0xe0) {
        result =
            ((countFlags << 16) | (buffer[offset + 1] << 8) | buffer[offset + 2]) &
                0x1fffff;
        offset = offset + 3;
    }
    else if (countFlags < 0xf0) {
        result =
            ((countFlags << 24) |
                (buffer[offset + 1] << 16) |
                (buffer[offset + 2] << 8) |
                buffer[offset + 3]) &
                0x0fffffff;
        offset = offset + 4;
    }
    else {
        result =
            ((countFlags & 0x0f) << 28) |
                (buffer[offset + 1] << 20) |
                (buffer[offset + 2] << 12) |
                (buffer[offset + 3] << 4) |
                (buffer[offset + 4] & 0x0f);
        // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);
        // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;
        offset = offset + 5;
    }
    if (offset > buffer.length) {
        throw new getBits_1.CramBufferOverrunError('Attempted to read beyond end of buffer; this file seems truncated.');
    }
    return [result, offset - initialOffset];
}
exports.parseItf8 = parseItf8;
function parseItem(buffer, parser, startBufferPosition = 0, startFilePosition = 0) {
    const { offset, result } = parser.parse(buffer);
    return Object.assign(Object.assign({}, result), { _endPosition: offset + startFilePosition, _size: offset - startBufferPosition });
}
exports.parseItem = parseItem;
// this would be nice as a decorator, but i'm a little worried about
// babel support for it going away or changing.
// memoizes a method in the stupidest possible way, with no regard for the
// arguments.  actually, this only works on methods that take no arguments
function tinyMemoize(_class, methodName) {
    const method = _class.prototype[methodName];
    const memoAttrName = `_memo_${methodName}`;
    _class.prototype[methodName] = function _tinyMemoized() {
        if (!(memoAttrName in this)) {
            const res = method.call(this);
            this[memoAttrName] = res;
            Promise.resolve(res).catch(() => {
                delete this[memoAttrName];
            });
        }
        return this[memoAttrName];
    };
}
exports.tinyMemoize = tinyMemoize;
function sequenceMD5(seq) {
    return (0, md5_1.default)(seq.toUpperCase().replace(/[^\x21-\x7e]/g, ''));
}
exports.sequenceMD5 = sequenceMD5;
//# sourceMappingURL=util.js.map