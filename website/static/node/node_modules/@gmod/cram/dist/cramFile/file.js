"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const unzip_1 = require("../unzip");
const buffer_crc32_1 = __importDefault(require("buffer-crc32"));
const quick_lru_1 = __importDefault(require("quick-lru"));
const errors_1 = require("../errors");
const rans_1 = __importDefault(require("../rans"));
const sectionParsers_1 = require("./sectionParsers");
const htscodecs_1 = __importDefault(require("@jkbonfield/htscodecs"));
const container_1 = __importDefault(require("./container"));
const io_1 = require("../io");
const util_1 = require("./util");
const sam_1 = require("../sam");
//source:https://abdulapopoola.com/2019/01/20/check-endianness-with-javascript/
function getEndianness() {
    const uInt32 = new Uint32Array([0x11223344]);
    const uInt8 = new Uint8Array(uInt32.buffer);
    if (uInt8[0] === 0x44) {
        return 0; //little-endian
    }
    else if (uInt8[0] === 0x11) {
        return 1; //big-endian
    }
    else {
        return 2; //mixed-endian?
    }
}
class CramFile {
    constructor(args) {
        var _a;
        this.file = (0, io_1.open)(args.url, args.path, args.filehandle);
        this.validateChecksums = true;
        this.fetchReferenceSequenceCallback = args.seqFetch;
        this.options = {
            checkSequenceMD5: args.checkSequenceMD5,
            cacheSize: (_a = args.cacheSize) !== null && _a !== void 0 ? _a : 20000,
        };
        // cache of features in a slice, keyed by the
        // slice offset. caches all of the features in a slice, or none.
        // the cache is actually used by the slice object, it's just
        // kept here at the level of the file
        this.featureCache = new quick_lru_1.default({
            maxSize: this.options.cacheSize,
        });
        if (getEndianness() > 0) {
            throw new Error('Detected big-endian machine, may be unable to run');
        }
    }
    // toString() {
    //   if (this.file.filename) {
    //     return this.file.filename
    //   }
    //   if (this.file.url) {
    //     return this.file.url
    //   }
    //
    //   return '(cram file)'
    // }
    // can just read this object like a filehandle
    read(buffer, offset, length, position) {
        return this.file.read(buffer, offset, length, position);
    }
    // can just stat this object like a filehandle
    stat() {
        return this.file.stat();
    }
    // memoized
    getDefinition() {
        return __awaiter(this, void 0, void 0, function* () {
            const headbytes = Buffer.allocUnsafe(sectionParsers_1.cramFileDefinition.maxLength);
            yield this.file.read(headbytes, 0, sectionParsers_1.cramFileDefinition.maxLength, 0);
            const definition = sectionParsers_1.cramFileDefinition.parser.parse(headbytes)
                .result;
            if (definition.majorVersion !== 2 && definition.majorVersion !== 3) {
                throw new errors_1.CramUnimplementedError(`CRAM version ${definition.majorVersion} not supported`);
            }
            return definition;
        });
    }
    // memoize
    getSamHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            const firstContainer = yield this.getContainerById(0);
            if (!firstContainer) {
                throw new errors_1.CramMalformedError('file contains no containers');
            }
            const firstBlock = yield firstContainer.getFirstBlock();
            if (firstBlock === undefined) {
                return (0, sam_1.parseHeaderText)('');
            }
            const content = firstBlock.content;
            // find the end of the trailing zeros in the header text
            const headerLength = content.readInt32LE(0);
            const textStart = 4;
            // let textEnd = content.length - 1
            // while (textEnd >= textStart && !content[textEnd]) textEnd -= 1
            // trim off the trailing zeros
            const text = content.toString('utf8', textStart, textStart + headerLength);
            this.header = text;
            return (0, sam_1.parseHeaderText)(text);
        });
    }
    getHeaderText() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getSamHeader();
            return this.header;
        });
    }
    // memoize
    getSectionParsers() {
        return __awaiter(this, void 0, void 0, function* () {
            const { majorVersion } = yield this.getDefinition();
            return (0, sectionParsers_1.getSectionParsers)(majorVersion);
        });
    }
    getContainerById(containerNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const sectionParsers = yield this.getSectionParsers();
            let position = sectionParsers.cramFileDefinition.maxLength;
            const { size: fileSize } = yield this.file.stat();
            const { cramContainerHeader1 } = sectionParsers;
            // skip with a series of reads to the proper container
            let currentContainer;
            for (let i = 0; i <= containerNumber; i += 1) {
                // if we are about to go off the end of the file
                // and have not found that container, it does not exist
                if (position + cramContainerHeader1.maxLength + 8 >= fileSize) {
                    return undefined;
                }
                currentContainer = this.getContainerAtPosition(position);
                const currentHeader = yield currentContainer.getHeader();
                if (!currentHeader) {
                    throw new errors_1.CramMalformedError(`container ${containerNumber} not found in file`);
                }
                // if this is the first container, read all the blocks in the
                // container to determine its length, because we cannot trust
                // the container header's given length due to a bug somewhere
                // in htslib
                if (i === 0) {
                    position = currentHeader._endPosition;
                    for (let j = 0; j < currentHeader.numBlocks; j += 1) {
                        const block = yield this.readBlock(position);
                        if (block === undefined) {
                            return undefined;
                        }
                        position = block._endPosition;
                    }
                }
                else {
                    // otherwise, just traverse to the next container using the container's length
                    position += currentHeader._size + currentHeader.length;
                }
            }
            return currentContainer;
        });
    }
    checkCrc32(position, length, recordedCrc32, description) {
        return __awaiter(this, void 0, void 0, function* () {
            const b = Buffer.allocUnsafe(length);
            yield this.file.read(b, 0, length, position);
            const calculatedCrc32 = buffer_crc32_1.default.unsigned(b);
            if (calculatedCrc32 !== recordedCrc32) {
                throw new errors_1.CramMalformedError(`crc mismatch in ${description}: recorded CRC32 = ${recordedCrc32}, but calculated CRC32 = ${calculatedCrc32}`);
            }
        });
    }
    /**
     * @returns {Promise[number]} the number of containers in the file
     */
    containerCount() {
        return __awaiter(this, void 0, void 0, function* () {
            const sectionParsers = yield this.getSectionParsers();
            const { size: fileSize } = yield this.file.stat();
            const { cramContainerHeader1 } = sectionParsers;
            let containerCount = 0;
            let position = sectionParsers.cramFileDefinition.maxLength;
            while (position + cramContainerHeader1.maxLength + 8 < fileSize) {
                const currentHeader = yield this.getContainerAtPosition(position).getHeader();
                if (!currentHeader) {
                    break;
                }
                // if this is the first container, read all the blocks in the
                // container, because we cannot trust the container
                // header's given length due to a bug somewhere in htslib
                if (containerCount === 0) {
                    position = currentHeader._endPosition;
                    for (let j = 0; j < currentHeader.numBlocks; j += 1) {
                        const block = yield this.readBlock(position);
                        if (block === undefined) {
                            return undefined;
                        }
                        position = block._endPosition;
                    }
                }
                else {
                    // otherwise, just traverse to the next container using the container's length
                    position += currentHeader._size + currentHeader.length;
                }
                containerCount += 1;
            }
            return containerCount;
        });
    }
    getContainerAtPosition(position) {
        return new container_1.default(this, position);
    }
    readBlockHeader(position) {
        return __awaiter(this, void 0, void 0, function* () {
            const sectionParsers = yield this.getSectionParsers();
            const { cramBlockHeader } = sectionParsers;
            const { size: fileSize } = yield this.file.stat();
            if (position + cramBlockHeader.maxLength >= fileSize) {
                return undefined;
            }
            const buffer = Buffer.allocUnsafe(cramBlockHeader.maxLength);
            yield this.file.read(buffer, 0, cramBlockHeader.maxLength, position);
            return (0, util_1.parseItem)(buffer, cramBlockHeader.parser, 0, position);
        });
    }
    _parseSection(section, position, size = section.maxLength, preReadBuffer = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer;
            if (preReadBuffer) {
                buffer = preReadBuffer;
            }
            else {
                const { size: fileSize } = yield this.file.stat();
                if (position + size >= fileSize) {
                    return undefined;
                }
                buffer = Buffer.allocUnsafe(size);
                yield this.file.read(buffer, 0, size, position);
            }
            const data = (0, util_1.parseItem)(buffer, section.parser, 0, position);
            if (data._size !== size) {
                throw new errors_1.CramMalformedError(`section read error: requested size ${size} does not equal parsed size ${data._size}`);
            }
            return data;
        });
    }
    _uncompress(compressionMethod, inputBuffer, outputBuffer) {
        if (compressionMethod === 'gzip') {
            const result = (0, unzip_1.unzip)(inputBuffer);
            result.copy(outputBuffer);
        }
        else if (compressionMethod === 'bzip2') {
            const bits = bzip2.array(inputBuffer);
            let size = bzip2.header(bits);
            let j = 0;
            let chunk;
            do {
                chunk = bzip2.decompress(bits, size);
                if (chunk != -1) {
                    Buffer.from(chunk).copy(outputBuffer, j);
                    j += chunk.length;
                    size -= chunk.length;
                }
            } while (chunk != -1);
        }
        else if (compressionMethod === 'rans') {
            (0, rans_1.default)(inputBuffer, outputBuffer);
            //htscodecs r4x8 is slower, but compatible.
            //htscodecs.r4x8_uncompress(inputBuffer, outputBuffer);
        }
        else if (compressionMethod === 'rans4x16') {
            htscodecs_1.default.r4x16_uncompress(inputBuffer, outputBuffer);
        }
        else if (compressionMethod === 'arith') {
            htscodecs_1.default.arith_uncompress(inputBuffer, outputBuffer);
        }
        else if (compressionMethod === 'fqzcomp') {
            htscodecs_1.default.fqzcomp_uncompress(inputBuffer, outputBuffer);
        }
        else if (compressionMethod === 'tok3') {
            htscodecs_1.default.tok3_uncompress(inputBuffer, outputBuffer);
        }
        else {
            throw new errors_1.CramUnimplementedError(`${compressionMethod} decompression not yet implemented`);
        }
    }
    readBlock(position) {
        return __awaiter(this, void 0, void 0, function* () {
            const { majorVersion } = yield this.getDefinition();
            const sectionParsers = yield this.getSectionParsers();
            const blockHeader = yield this.readBlockHeader(position);
            if (blockHeader === undefined) {
                return undefined;
            }
            const blockContentPosition = blockHeader._endPosition;
            const uncompressedData = Buffer.allocUnsafe(blockHeader.uncompressedSize);
            const block = Object.assign(Object.assign({}, blockHeader), { _endPosition: blockContentPosition, contentPosition: blockContentPosition, content: uncompressedData });
            if (blockHeader.compressionMethod !== 'raw') {
                const compressedData = Buffer.allocUnsafe(blockHeader.compressedSize);
                yield this.read(compressedData, 0, blockHeader.compressedSize, blockContentPosition);
                this._uncompress(blockHeader.compressionMethod, compressedData, uncompressedData);
            }
            else {
                yield this.read(uncompressedData, 0, blockHeader.uncompressedSize, blockContentPosition);
            }
            if (majorVersion >= 3) {
                // parse the crc32
                const crc = yield this._parseSection(sectionParsers.cramBlockCrc32, blockContentPosition + blockHeader.compressedSize);
                if (crc === undefined) {
                    return undefined;
                }
                block.crc32 = crc.crc32;
                // check the block data crc32
                if (this.validateChecksums) {
                    yield this.checkCrc32(position, blockHeader._size + blockHeader.compressedSize, crc.crc32, 'block data');
                }
                // make the endposition and size reflect the whole block
                block._endPosition = crc._endPosition;
                block._size =
                    block.compressedSize + sectionParsers.cramBlockCrc32.maxLength;
            }
            else {
                block._endPosition = blockContentPosition + block.compressedSize;
                block._size = block.compressedSize;
            }
            return block;
        });
    }
}
exports.default = CramFile;
'getDefinition getSectionParsers getSamHeader'
    .split(' ')
    .forEach(method => (0, util_1.tinyMemoize)(CramFile, method));
//# sourceMappingURL=file.js.map