"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const _base_1 = __importDefault(require("./_base"));
const getBits_1 = require("./getBits");
class ByteArrayStopCodec extends _base_1.default {
    constructor(parameters, dataType) {
        super(parameters, dataType);
        if (dataType !== 'byteArray') {
            throw new TypeError(`byteArrayStop codec does not support data type ${dataType}`);
        }
    }
    decode(slice, coreDataBlock, blocksByContentId, cursors) {
        const { blockContentId } = this.parameters;
        const contentBlock = blocksByContentId[blockContentId];
        if (!contentBlock) {
            throw new errors_1.CramMalformedError(`no block found with content ID ${blockContentId}`);
        }
        const cursor = cursors.externalBlocks.getCursor(blockContentId);
        return this._decodeByteArray(contentBlock, cursor);
    }
    _decodeByteArray(contentBlock, cursor) {
        const dataBuffer = contentBlock.content;
        const { stopByte } = this.parameters;
        // scan to the next stop byte
        const startPosition = cursor.bytePosition;
        let stopPosition = cursor.bytePosition;
        while (dataBuffer[stopPosition] !== stopByte &&
            stopPosition < dataBuffer.length) {
            if (stopPosition === dataBuffer.length) {
                throw new getBits_1.CramBufferOverrunError(`byteArrayStop reading beyond length of data buffer?`);
            }
            stopPosition = stopPosition + 1;
        }
        cursor.bytePosition = stopPosition + 1;
        return dataBuffer.subarray(startPosition, stopPosition);
    }
}
exports.default = ByteArrayStopCodec;
//# sourceMappingURL=byteArrayStop.js.map