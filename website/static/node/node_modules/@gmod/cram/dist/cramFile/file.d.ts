/// <reference types="node" />
import QuickLRU from 'quick-lru';
import { BlockHeader, CompressionMethod } from './sectionParsers';
import CramContainer from './container';
import { Parser } from '@gmod/binary-parser';
import CramRecord from './record';
import { Filehandle } from './filehandle';
export declare type CramFileSource = {
    filehandle?: Filehandle;
    url?: string;
    path?: string;
};
export declare type SeqFetch = (seqId: number, start: number, end: number) => Promise<string>;
export declare type CramFileArgs = CramFileSource & {
    checkSequenceMD5: boolean;
    cacheSize?: number;
    seqFetch: SeqFetch;
};
export declare type CramFileBlock = BlockHeader & {
    _endPosition: number;
    contentPosition: number;
    _size: number;
    content: Buffer;
    crc32?: number;
};
export default class CramFile {
    private file;
    validateChecksums: boolean;
    fetchReferenceSequenceCallback: SeqFetch;
    options: {
        checkSequenceMD5: boolean;
        cacheSize: number;
    };
    featureCache: QuickLRU<string, Promise<CramRecord[]>>;
    private header;
    constructor(args: CramFileArgs);
    read(buffer: Buffer, offset: number, length: number, position: number): Promise<{
        bytesRead: number;
        buffer: Buffer;
    }>;
    stat(): Promise<import("generic-filehandle").Stats>;
    getDefinition(): Promise<any>;
    getSamHeader(): Promise<import("../sam").HeaderDataItem[]>;
    getHeaderText(): Promise<string | undefined>;
    getSectionParsers(): Promise<{
        cramFileDefinition: {
            parser: Parser<{
                magic: string;
                majorVersion: number;
                minorVersion: number;
                fileId: string;
            }>;
            maxLength: number;
        };
        cramContainerHeader1: {
            parser: Parser<{
                length: number;
                refSeqId: number;
                refSeqStart: number;
                alignmentSpan: number;
                numRecords: number;
                recordCounter: number;
                numBases: number;
                numBlocks: number;
                numLandmarks: number;
            }>;
            maxLength: number;
        };
        cramContainerHeader2: {
            parser: Parser<{
                numLandmarks: number;
                landmarks: number[];
                crc32: number;
            }>;
            maxLength: (x: number) => number;
        };
        cramBlockHeader: {
            parser: Parser<BlockHeader>;
            maxLength: number;
        };
        cramBlockCrc32: {
            parser: Parser<{
                crc32: number;
            }>;
            maxLength: number;
        };
        cramCompressionHeader: {
            parser: Parser<import("./sectionParsers").CramCompressionHeader>;
        };
        cramMappedSliceHeader: {
            parser: Parser<import("./sectionParsers").MappedSliceHeader>;
            maxLength: (numContentIds: number) => number;
        };
        cramUnmappedSliceHeader: {
            parser: Parser<import("./sectionParsers").UnmappedSliceHeader>;
            maxLength: (numContentIds: number) => number;
        };
    }>;
    getContainerById(containerNumber: number): Promise<CramContainer | undefined>;
    checkCrc32(position: number, length: number, recordedCrc32: number, description: string): Promise<void>;
    /**
     * @returns {Promise[number]} the number of containers in the file
     */
    containerCount(): Promise<number | undefined>;
    getContainerAtPosition(position: number): CramContainer;
    readBlockHeader(position: number): Promise<import("./util").ParsedItem<BlockHeader> | undefined>;
    _parseSection<T>(section: {
        parser: Parser<T>;
        maxLength: number;
    }, position: number, size?: number, preReadBuffer?: undefined): Promise<import("./util").ParsedItem<T> | undefined>;
    _uncompress(compressionMethod: CompressionMethod, inputBuffer: Buffer, outputBuffer: Buffer): void;
    readBlock(position: number): Promise<CramFileBlock | undefined>;
}
