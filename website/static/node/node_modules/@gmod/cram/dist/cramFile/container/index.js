"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const util_1 = require("../util");
const slice_1 = __importDefault(require("../slice"));
const compressionScheme_1 = __importDefault(require("./compressionScheme"));
class CramContainer {
    constructor(file, filePosition) {
        this.file = file;
        this.filePosition = filePosition;
    }
    // memoize
    getHeader() {
        return this._readContainerHeader(this.filePosition);
    }
    // memoize
    getCompressionHeaderBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const containerHeader = yield this.getHeader();
            // if there are no records in the container, there will be no compression header
            if (!containerHeader.numRecords) {
                return null;
            }
            const sectionParsers = yield this.file.getSectionParsers();
            const block = yield this.getFirstBlock();
            if (block === undefined) {
                return undefined;
            }
            if (block.contentType !== 'COMPRESSION_HEADER') {
                throw new errors_1.CramMalformedError(`invalid content type ${block.contentType} in what is supposed to be the compression header block`);
            }
            const content = (0, util_1.parseItem)(block.content, sectionParsers.cramCompressionHeader.parser, 0, block.contentPosition);
            return Object.assign(Object.assign({}, block), { parsedContent: content });
        });
    }
    getFirstBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const containerHeader = yield this.getHeader();
            return this.file.readBlock(containerHeader._endPosition);
        });
    }
    // parses the compression header data into a CramContainerCompressionScheme object
    // memoize
    getCompressionScheme() {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.getCompressionHeaderBlock();
            if (!header) {
                return undefined;
            }
            return new compressionScheme_1.default(header.parsedContent);
        });
    }
    getSlice(slicePosition, sliceSize) {
        // note: slicePosition is relative to the end of the container header
        // TODO: perhaps we should cache slices?
        return new slice_1.default(this, slicePosition, sliceSize);
    }
    _readContainerHeader(position) {
        return __awaiter(this, void 0, void 0, function* () {
            const sectionParsers = yield this.file.getSectionParsers();
            const { cramContainerHeader1, cramContainerHeader2 } = sectionParsers;
            const { size: fileSize } = yield this.file.stat();
            if (position >= fileSize) {
                return undefined;
            }
            // parse the container header. do it in 2 pieces because you cannot tell
            // how much to buffer until you read numLandmarks
            const bytes1 = Buffer.allocUnsafe(cramContainerHeader1.maxLength);
            yield this.file.read(bytes1, 0, cramContainerHeader1.maxLength, position);
            const header1 = (0, util_1.parseItem)(bytes1, cramContainerHeader1.parser);
            const numLandmarksSize = (0, util_1.itf8Size)(header1.numLandmarks);
            if (position + header1.length >= fileSize) {
                console.warn(`${this.file}: container header at ${position} indicates that the container has length ${header1.length}, which extends beyond the length of the file. Skipping this container.`);
                return undefined;
            }
            const bytes2 = Buffer.allocUnsafe(cramContainerHeader2.maxLength(header1.numLandmarks));
            yield this.file.read(bytes2, 0, cramContainerHeader2.maxLength(header1.numLandmarks), position + header1._size - numLandmarksSize);
            const header2 = (0, util_1.parseItem)(bytes2, cramContainerHeader2.parser);
            if (this.file.validateChecksums && header2.crc32 !== undefined) {
                yield this.file.checkCrc32(position, header1._size + header2._size - numLandmarksSize - 4, header2.crc32, `container header beginning at position ${position}`);
            }
            const completeHeader = Object.assign(header1, header2, {
                _size: header1._size + header2._size - numLandmarksSize,
                _endPosition: header1._size + header2._size - numLandmarksSize + position,
            });
            return completeHeader;
        });
    }
}
exports.default = CramContainer;
'getHeader getCompressionHeaderBlock getCompressionScheme'
    .split(' ')
    .forEach(method => (0, util_1.tinyMemoize)(CramContainer, method));
//# sourceMappingURL=index.js.map