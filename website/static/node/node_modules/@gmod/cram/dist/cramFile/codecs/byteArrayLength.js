"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const _base_1 = __importDefault(require("./_base"));
class ByteArrayStopCodec extends _base_1.default {
    constructor(parameters, dataType, instantiateCodec) {
        super(parameters, dataType);
        this.instantiateCodec = instantiateCodec;
        if (dataType !== 'byteArray') {
            throw new TypeError(`byteArrayLength does not support data type ${dataType}`);
        }
    }
    decode(slice, coreDataBlock, blocksByContentId, cursors) {
        const lengthCodec = this._getLengthCodec();
        const arrayLength = lengthCodec.decode(slice, coreDataBlock, blocksByContentId, cursors);
        const dataCodec = this._getDataCodec();
        const data = new Uint8Array(arrayLength);
        for (let i = 0; i < arrayLength; i += 1) {
            data[i] = dataCodec.decode(slice, coreDataBlock, blocksByContentId, cursors);
        }
        return data;
    }
    // memoize
    _getLengthCodec() {
        const encodingParams = this.parameters.lengthsEncoding;
        return this.instantiateCodec(encodingParams, 'int');
    }
    // memoize
    _getDataCodec() {
        const encodingParams = this.parameters.valuesEncoding;
        return this.instantiateCodec(encodingParams, 'byte');
    }
}
exports.default = ByteArrayStopCodec;
'_getLengthCodec _getDataCodec'
    .split(' ')
    .forEach(method => (0, util_1.tinyMemoize)(ByteArrayStopCodec, method));
//# sourceMappingURL=byteArrayLength.js.map