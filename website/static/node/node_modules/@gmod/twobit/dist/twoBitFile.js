"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var long_1 = __importDefault(require("long"));
var generic_filehandle_1 = require("generic-filehandle");
var binary_parser_1 = require("@gmod/binary-parser");
var TWOBIT_MAGIC = 0x1a412743;
function tinyMemoize(_class, methodName) {
    var method = _class.prototype[methodName];
    var memoAttrName = "_memo_".concat(methodName);
    _class.prototype[methodName] = function _tinyMemoized() {
        if (!(memoAttrName in this)) {
            this[memoAttrName] = method.call(this);
        }
        return this[memoAttrName];
    };
}
var twoBit = ['T', 'C', 'A', 'G'];
// byteTo4Bases is an array of byteValue -> 'ACTG'
// the weird `...keys()` incantation generates an array of numbers 0 to 255
var byteTo4Bases = [];
for (var i = 0; i < 256; i++) {
    byteTo4Bases.push(twoBit[(i >> 6) & 3] +
        twoBit[(i >> 4) & 3] +
        twoBit[(i >> 2) & 3] +
        twoBit[i & 3]);
}
var maskedByteTo4Bases = byteTo4Bases.map(function (bases) { return bases.toLowerCase(); });
var TwoBitFile = /** @class */ (function () {
    /**
     * @param {object} args
     * @param {string} [args.path] filesystem path for the .2bit file to open
     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.
     *  Only needs to support `filehandle.read(buffer, offset, length, position)`
     */
    function TwoBitFile(_a) {
        var filehandle = _a.filehandle, path = _a.path;
        if (filehandle) {
            this.filehandle = filehandle;
        }
        else if (path) {
            this.filehandle = new generic_filehandle_1.LocalFile(path);
        }
        else {
            throw new Error('must supply path or filehandle');
        }
        this.isBigEndian = undefined;
    }
    TwoBitFile.prototype._getParser = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var parser;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getParsers()];
                    case 1:
                        parser = (_a.sent())[name];
                        if (!parser) {
                            throw new Error("parser ".concat(name, " not found"));
                        }
                        return [2 /*return*/, parser];
                }
            });
        });
    };
    TwoBitFile.prototype._detectEndianness = function () {
        return __awaiter(this, void 0, void 0, function () {
            var ret, buffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0)];
                    case 1:
                        ret = _a.sent();
                        buffer = ret.buffer;
                        if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {
                            this.isBigEndian = false;
                            this.version = buffer.readInt32LE(4);
                        }
                        else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {
                            this.isBigEndian = true;
                            this.version = buffer.readInt32BE(4);
                        }
                        else {
                            throw new Error('not a 2bit file');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // memoize
    /**
     * @private
     * detects the file's endianness and instantiates our binary parsers accordingly
     */
    TwoBitFile.prototype._getParsers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var endianess, lebe, indexEntryParser, header;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._detectEndianness()];
                    case 1:
                        _a.sent();
                        endianess = this.isBigEndian ? 'big' : 'little';
                        lebe = this.isBigEndian ? 'be' : 'le';
                        indexEntryParser = new binary_parser_1.Parser()
                            .endianess(endianess)
                            .uint8('nameLength')
                            .string('name', { length: 'nameLength' });
                        if (this.version === 1) {
                            indexEntryParser = indexEntryParser.buffer('offsetBytes', {
                                length: 8,
                            });
                        }
                        else {
                            indexEntryParser = indexEntryParser.uint32('offset');
                        }
                        header = new binary_parser_1.Parser()
                            .endianess(endianess)
                            .int32('magic', {
                            assert: function (m) { return m === 0x1a412743; },
                        })
                            .int32('version', {
                            /* istanbul ignore next */
                            assert: function (v) { return v === 0 || v === 1; },
                        })
                            .uint32('sequenceCount', {
                            /* istanbul ignore next */
                            assert: function (v) { return v >= 0; },
                        })
                            .uint32('reserved');
                        return [2 /*return*/, {
                                header: header,
                                index: new binary_parser_1.Parser()
                                    .endianess(endianess)
                                    .uint32('sequenceCount')
                                    .uint32('reserved')
                                    .array('index', {
                                    length: 'sequenceCount',
                                    type: indexEntryParser,
                                }),
                                record1: new binary_parser_1.Parser()
                                    .endianess(endianess)
                                    .uint32('dnaSize')
                                    .uint32('nBlockCount'),
                                record2: new binary_parser_1.Parser()
                                    .endianess(endianess)
                                    .uint32('nBlockCount')
                                    .array('nBlockStarts', {
                                    length: 'nBlockCount',
                                    type: "uint32".concat(lebe),
                                })
                                    .array('nBlockSizes', {
                                    length: 'nBlockCount',
                                    type: "uint32".concat(lebe),
                                })
                                    .uint32('maskBlockCount'),
                                record3: new binary_parser_1.Parser()
                                    .endianess(endianess)
                                    .uint32('maskBlockCount')
                                    .array('maskBlockStarts', {
                                    length: 'maskBlockCount',
                                    type: "uint32".concat(lebe),
                                })
                                    .array('maskBlockSizes', {
                                    length: 'maskBlockCount',
                                    type: "uint32".concat(lebe),
                                })
                                    .int32('reserved'),
                                // .buffer('packedDna', { length: 'dnaSize' }),
                            }];
                }
            });
        });
    };
    // memoize
    /**
     * @returns {Promise} for object with the file's header information, like
     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`
     */
    TwoBitFile.prototype.getHeader = function () {
        return __awaiter(this, void 0, void 0, function () {
            var buffer, headerParser;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._detectEndianness()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.filehandle.read(Buffer.allocUnsafe(16), 0, 16, 0)];
                    case 2:
                        buffer = (_a.sent()).buffer;
                        return [4 /*yield*/, this._getParser('header')];
                    case 3:
                        headerParser = _a.sent();
                        return [2 /*return*/, headerParser.parse(buffer).result];
                }
            });
        });
    };
    // memoize
    /**
     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`
     */
    TwoBitFile.prototype.getIndex = function () {
        return __awaiter(this, void 0, void 0, function () {
            var header, maxIndexLength, buffer, indexParser, indexData, index;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getHeader()];
                    case 1:
                        header = _a.sent();
                        maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));
                        return [4 /*yield*/, this.filehandle.read(Buffer.allocUnsafe(maxIndexLength), 0, maxIndexLength, 8)];
                    case 2:
                        buffer = (_a.sent()).buffer;
                        return [4 /*yield*/, this._getParser('index')];
                    case 3:
                        indexParser = _a.sent();
                        indexData = indexParser.parse(buffer).result.index;
                        index = {};
                        if (this.version === 1) {
                            indexData.forEach(function (_a) {
                                var name = _a.name, offsetBytes = _a.offsetBytes;
                                var long = long_1.default.fromBytes(offsetBytes, true, !_this.isBigEndian);
                                if (long.greaterThan(Number.MAX_SAFE_INTEGER)) {
                                    throw new Error('integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.');
                                }
                                index[name] = long.toNumber();
                            });
                        }
                        else {
                            indexData.forEach(function (_a) {
                                var name = _a.name, offset = _a.offset;
                                index[name] = offset;
                            });
                        }
                        return [2 /*return*/, index];
                }
            });
        });
    };
    /**
     * @returns {Promise} for an array of string sequence names that are found in the file
     */
    TwoBitFile.prototype.getSequenceNames = function () {
        return __awaiter(this, void 0, void 0, function () {
            var index;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getIndex()];
                    case 1:
                        index = _a.sent();
                        return [2 /*return*/, Object.keys(index)];
                }
            });
        });
    };
    /**
     * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`
     */
    TwoBitFile.prototype.getSequenceSizes = function () {
        return __awaiter(this, void 0, void 0, function () {
            var index, seqNames, sizePromises, sizes, returnObject, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getIndex()];
                    case 1:
                        index = _a.sent();
                        seqNames = Object.keys(index);
                        sizePromises = Object.values(index).map(function (offset) {
                            return _this._getSequenceSize(offset);
                        });
                        return [4 /*yield*/, Promise.all(sizePromises)];
                    case 2:
                        sizes = _a.sent();
                        returnObject = {};
                        for (i = 0; i < seqNames.length; i += 1) {
                            returnObject[seqNames[i]] = sizes[i];
                        }
                        return [2 /*return*/, returnObject];
                }
            });
        });
    };
    /**
     * @param {string} seqName name of the sequence
     * @returns {Promise} for the sequence's length, or undefined if it is not in the file
     */
    TwoBitFile.prototype.getSequenceSize = function (seqName) {
        return __awaiter(this, void 0, void 0, function () {
            var index, offset;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getIndex()];
                    case 1:
                        index = _a.sent();
                        offset = index[seqName];
                        if (!offset) {
                            return [2 /*return*/, undefined];
                        }
                        return [2 /*return*/, this._getSequenceSize(offset)];
                }
            });
        });
    };
    TwoBitFile.prototype._getSequenceSize = function (offset) {
        return __awaiter(this, void 0, void 0, function () {
            var rec1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads
                        if (offset === undefined || offset < 0) {
                            throw new Error('invalid offset');
                        }
                        return [4 /*yield*/, this._parseItem(offset, 8, 'record1')];
                    case 1:
                        rec1 = _a.sent();
                        return [2 /*return*/, rec1.dnaSize];
                }
            });
        });
    };
    TwoBitFile.prototype._getSequenceRecord = function (offset) {
        return __awaiter(this, void 0, void 0, function () {
            var rec1, rec2DataLength, rec2, rec3DataLength, rec3, rec;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads
                        if (offset === undefined || offset < 0) {
                            throw new Error('invalid offset');
                        }
                        return [4 /*yield*/, this._parseItem(offset, 8, 'record1')];
                    case 1:
                        rec1 = _a.sent();
                        rec2DataLength = rec1.nBlockCount * 8 + 8;
                        return [4 /*yield*/, this._parseItem(offset + 4, rec2DataLength, 'record2')];
                    case 2:
                        rec2 = _a.sent();
                        rec3DataLength = rec2.maskBlockCount * 8 + 8;
                        return [4 /*yield*/, this._parseItem(offset + 4 + rec2DataLength - 4, rec3DataLength, 'record3')];
                    case 3:
                        rec3 = _a.sent();
                        rec = {
                            dnaSize: rec1.dnaSize,
                            nBlocks: { starts: rec2.nBlockStarts, sizes: rec2.nBlockSizes },
                            maskBlocks: { starts: rec3.maskBlockStarts, sizes: rec3.maskBlockSizes },
                            dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength,
                        };
                        return [2 /*return*/, rec];
                }
            });
        });
    };
    TwoBitFile.prototype._parseItem = function (offset, length, parserName) {
        return __awaiter(this, void 0, void 0, function () {
            var buffer, parser;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.filehandle.read(Buffer.allocUnsafe(length), 0, length, offset)];
                    case 1:
                        buffer = (_a.sent()).buffer;
                        return [4 /*yield*/, this._getParser(parserName)];
                    case 2:
                        parser = _a.sent();
                        return [2 /*return*/, parser.parse(buffer).result];
                }
            });
        });
    };
    /**
     * @param {string} seqName name of the sequence you want
     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.
     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence
     * @returns {Promise} for a string of sequence bases
     */
    TwoBitFile.prototype.getSequence = function (seqName, regionStart, regionEnd) {
        if (regionStart === void 0) { regionStart = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var index, offset, record, nBlocks, maskBlocks, baseBytes, baseBytesOffset, buffer, sequenceBases, genomicPosition, baseIsMasked, currentNBlock, bytePosition, subPosition, byte;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getIndex()];
                    case 1:
                        index = _a.sent();
                        offset = index[seqName];
                        if (!offset) {
                            return [2 /*return*/, undefined];
                        }
                        return [4 /*yield*/, this._getSequenceRecord(offset)];
                    case 2:
                        record = _a.sent();
                        if (regionStart < 0) {
                            throw new TypeError('regionStart cannot be less than 0');
                        }
                        // end defaults to the end of the sequence
                        if (regionEnd === undefined || regionEnd > record.dnaSize) {
                            regionEnd = record.dnaSize;
                        }
                        nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);
                        maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);
                        baseBytes = Buffer.allocUnsafe(Math.ceil((regionEnd - regionStart) / 4) + 1);
                        baseBytesOffset = Math.floor(regionStart / 4);
                        return [4 /*yield*/, this.filehandle.read(baseBytes, 0, baseBytes.length, record.dnaPosition + baseBytesOffset)];
                    case 3:
                        buffer = (_a.sent()).buffer;
                        sequenceBases = '';
                        for (genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {
                            // check whether we are currently masked
                            while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {
                                maskBlocks.shift();
                            }
                            baseIsMasked = maskBlocks[0] &&
                                maskBlocks[0].start <= genomicPosition &&
                                maskBlocks[0].end > genomicPosition;
                            // process the N block if we have one
                            if (nBlocks[0] &&
                                genomicPosition >= nBlocks[0].start &&
                                genomicPosition < nBlocks[0].end) {
                                currentNBlock = nBlocks.shift();
                                for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {
                                    sequenceBases += baseIsMasked ? 'n' : 'N';
                                }
                                genomicPosition -= 1;
                            }
                            else {
                                bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;
                                subPosition = genomicPosition % 4;
                                byte = buffer[bytePosition];
                                sequenceBases += baseIsMasked
                                    ? maskedByteTo4Bases[byte][subPosition]
                                    : byteTo4Bases[byte][subPosition];
                            }
                        }
                        return [2 /*return*/, sequenceBases];
                }
            });
        });
    };
    TwoBitFile.prototype._getOverlappingBlocks = function (regionStart, regionEnd, blockStarts, blockSizes) {
        // find the start and end indexes of the blocks that match
        var startIndex;
        var endIndex;
        for (var i = 0; i < blockStarts.length; i += 1) {
            var blockStart = blockStarts[i];
            var blockSize = blockSizes[i];
            if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {
                // block does not overlap the region
                if (startIndex !== undefined) {
                    endIndex = i;
                    break;
                }
            }
            else if (startIndex === undefined) {
                startIndex = i;
            } // block does overlap the region, record this if it is the first
        }
        if (startIndex === undefined) {
            return [];
        }
        // now format some block objects to return
        if (endIndex === undefined) {
            endIndex = blockStarts.length;
        }
        var blocks = new Array(endIndex - startIndex);
        for (var blockNum = startIndex; blockNum < endIndex; blockNum += 1) {
            blocks[blockNum - startIndex] = {
                start: blockStarts[blockNum],
                end: blockStarts[blockNum] + blockSizes[blockNum],
                size: blockSizes[blockNum],
            };
        }
        return blocks;
    };
    return TwoBitFile;
}());
exports.default = TwoBitFile;
tinyMemoize(TwoBitFile, '_getParsers');
tinyMemoize(TwoBitFile, 'getIndex');
tinyMemoize(TwoBitFile, 'getHeader');
//# sourceMappingURL=twoBitFile.js.map