"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-empty-function */
var constants_1 = __importDefault(require("./constants"));
var SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('');
var CIGAR_DECODER = 'MIDNSHP=X???????'.split('');
/**
 * Class of each BAM record returned by this API.
 */
var BamRecord = /** @class */ (function () {
    function BamRecord(args) {
        this.data = {};
        this._tagList = [];
        this._allTagsParsed = false;
        var bytes = args.bytes, fileOffset = args.fileOffset;
        var byteArray = bytes.byteArray, start = bytes.start;
        this.data = {};
        this.bytes = bytes;
        this._id = fileOffset;
        this._refID = byteArray.readInt32LE(start + 4);
        this.data.start = byteArray.readInt32LE(start + 8);
        this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16;
    }
    BamRecord.prototype.get = function (field) {
        //@ts-ignore
        if (this[field]) {
            //@ts-ignore
            if (this.data[field]) {
                return this.data[field];
            }
            //@ts-ignore
            this.data[field] = this[field]();
            return this.data[field];
        }
        return this._get(field.toLowerCase());
    };
    BamRecord.prototype.end = function () {
        return this.get('start') + this.get('length_on_ref');
    };
    BamRecord.prototype.seq_id = function () {
        return this._refID;
    };
    // same as get(), except requires lower-case arguments.  used
    // internally to save lots of calls to field.toLowerCase()
    BamRecord.prototype._get = function (field) {
        if (field in this.data) {
            return this.data[field];
        }
        this.data[field] = this._parseTag(field);
        return this.data[field];
    };
    BamRecord.prototype._tags = function () {
        var _this = this;
        this._parseAllTags();
        var tags = ['seq'];
        if (!this.isSegmentUnmapped()) {
            tags.push('start', 'end', 'strand', 'score', 'qual', 'MQ', 'CIGAR', 'length_on_ref', 'template_length');
        }
        if (this.isPaired()) {
            tags.push('next_segment_position', 'pair_orientation');
        }
        tags = tags.concat(this._tagList || []);
        Object.keys(this.data).forEach(function (k) {
            if (k[0] !== '_' && k !== 'next_seq_id') {
                tags.push(k);
            }
        });
        var seen = {};
        return tags.filter(function (t) {
            if ((t in _this.data && _this.data[t] === undefined) ||
                t === 'CG' ||
                t === 'cg') {
                return false;
            }
            var lt = t.toLowerCase();
            var s = seen[lt];
            seen[lt] = true;
            return !s;
        });
    };
    BamRecord.prototype.parent = function () {
        return undefined;
    };
    BamRecord.prototype.children = function () {
        return this.get('subfeatures');
    };
    BamRecord.prototype.id = function () {
        return this._id;
    };
    // special parsers
    /**
     * Mapping quality score.
     */
    BamRecord.prototype.mq = function () {
        var mq = (this.get('_bin_mq_nl') & 0xff00) >> 8;
        return mq === 255 ? undefined : mq;
    };
    BamRecord.prototype.score = function () {
        return this.get('mq');
    };
    BamRecord.prototype.qual = function () {
        var _a;
        return (_a = this.qualRaw()) === null || _a === void 0 ? void 0 : _a.join(' ');
    };
    BamRecord.prototype.qualRaw = function () {
        if (this.isSegmentUnmapped()) {
            return undefined;
        }
        var _a = this.bytes, start = _a.start, byteArray = _a.byteArray;
        var p = start +
            36 +
            this.get('_l_read_name') +
            this.get('_n_cigar_op') * 4 +
            this.get('_seq_bytes');
        var lseq = this.get('seq_length');
        return byteArray.subarray(p, p + lseq);
    };
    BamRecord.prototype.strand = function () {
        return this.isReverseComplemented() ? -1 : 1;
    };
    BamRecord.prototype.multi_segment_next_segment_strand = function () {
        if (this.isMateUnmapped()) {
            return undefined;
        }
        return this.isMateReverseComplemented() ? -1 : 1;
    };
    BamRecord.prototype.name = function () {
        return this.get('_read_name');
    };
    BamRecord.prototype._read_name = function () {
        var nl = this.get('_l_read_name');
        var _a = this.bytes, byteArray = _a.byteArray, start = _a.start;
        return byteArray.toString('ascii', start + 36, start + 36 + nl - 1);
    };
    /**
     * Get the value of a tag, parsing the tags as far as necessary.
     * Only called if we have not already parsed that field.
     */
    BamRecord.prototype._parseTag = function (tagName) {
        // if all of the tags have been parsed and we're still being
        // called, we already know that we have no such tag, because
        // it would already have been cached.
        if (this._allTagsParsed) {
            return undefined;
        }
        var _a = this.bytes, byteArray = _a.byteArray, start = _a.start;
        var p = this._tagOffset ||
            start +
                36 +
                this.get('_l_read_name') +
                this.get('_n_cigar_op') * 4 +
                this.get('_seq_bytes') +
                this.get('seq_length');
        var blockEnd = this.bytes.end;
        var lcTag;
        while (p < blockEnd && lcTag !== tagName) {
            var tag = String.fromCharCode(byteArray[p], byteArray[p + 1]);
            lcTag = tag.toLowerCase();
            var type = String.fromCharCode(byteArray[p + 2]);
            p += 3;
            var value = void 0;
            switch (type) {
                case 'A':
                    value = String.fromCharCode(byteArray[p]);
                    p += 1;
                    break;
                case 'i':
                    value = byteArray.readInt32LE(p);
                    p += 4;
                    break;
                case 'I':
                    value = byteArray.readUInt32LE(p);
                    p += 4;
                    break;
                case 'c':
                    value = byteArray.readInt8(p);
                    p += 1;
                    break;
                case 'C':
                    value = byteArray.readUInt8(p);
                    p += 1;
                    break;
                case 's':
                    value = byteArray.readInt16LE(p);
                    p += 2;
                    break;
                case 'S':
                    value = byteArray.readUInt16LE(p);
                    p += 2;
                    break;
                case 'f':
                    value = byteArray.readFloatLE(p);
                    p += 4;
                    break;
                case 'Z':
                case 'H':
                    value = '';
                    while (p <= blockEnd) {
                        var cc = byteArray[p++];
                        if (cc === 0) {
                            break;
                        }
                        else {
                            value += String.fromCharCode(cc);
                        }
                    }
                    break;
                case 'B': {
                    value = '';
                    var cc = byteArray[p++];
                    var Btype = String.fromCharCode(cc);
                    var limit = byteArray.readInt32LE(p);
                    p += 4;
                    if (Btype === 'i') {
                        if (tag === 'CG') {
                            for (var k = 0; k < limit; k++) {
                                var cigop = byteArray.readInt32LE(p);
                                var lop = cigop >> 4;
                                var op = CIGAR_DECODER[cigop & 0xf];
                                value += lop + op;
                                p += 4;
                            }
                        }
                        else {
                            for (var k = 0; k < limit; k++) {
                                value += byteArray.readInt32LE(p);
                                if (k + 1 < limit) {
                                    value += ',';
                                }
                                p += 4;
                            }
                        }
                    }
                    if (Btype === 'I') {
                        if (tag === 'CG') {
                            for (var k = 0; k < limit; k++) {
                                var cigop = byteArray.readUInt32LE(p);
                                var lop = cigop >> 4;
                                var op = CIGAR_DECODER[cigop & 0xf];
                                value += lop + op;
                                p += 4;
                            }
                        }
                        else {
                            for (var k = 0; k < limit; k++) {
                                value += byteArray.readUInt32LE(p);
                                if (k + 1 < limit) {
                                    value += ',';
                                }
                                p += 4;
                            }
                        }
                    }
                    if (Btype === 's') {
                        for (var k = 0; k < limit; k++) {
                            value += byteArray.readInt16LE(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 2;
                        }
                    }
                    if (Btype === 'S') {
                        for (var k = 0; k < limit; k++) {
                            value += byteArray.readUInt16LE(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 2;
                        }
                    }
                    if (Btype === 'c') {
                        for (var k = 0; k < limit; k++) {
                            value += byteArray.readInt8(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 1;
                        }
                    }
                    if (Btype === 'C') {
                        for (var k = 0; k < limit; k++) {
                            value += byteArray.readUInt8(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 1;
                        }
                    }
                    if (Btype === 'f') {
                        for (var k = 0; k < limit; k++) {
                            value += byteArray.readFloatLE(p);
                            if (k + 1 < limit) {
                                value += ',';
                            }
                            p += 4;
                        }
                    }
                    break;
                }
                default:
                    console.warn("Unknown BAM tag type '".concat(type, "', tags may be incomplete"));
                    value = undefined;
                    p = blockEnd; // stop parsing tags
            }
            this._tagOffset = p;
            this._tagList.push(tag);
            if (lcTag === tagName) {
                return value;
            }
            this.data[lcTag] = value;
        }
        this._allTagsParsed = true;
        return undefined;
    };
    BamRecord.prototype._parseAllTags = function () {
        this._parseTag('');
    };
    BamRecord.prototype._parseCigar = function (cigar) {
        return (
        //@ts-ignore
        cigar
            .match(/\d+\D/g)
            //@ts-ignore
            .map(function (op) { return [op.match(/\D/)[0].toUpperCase(), parseInt(op, 10)]; }));
    };
    /**
     * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped
     */
    BamRecord.prototype.isPaired = function () {
        return !!(this.flags & constants_1.default.BAM_FPAIRED);
    };
    /** @returns {boolean} true if the read is paired, and both segments are mapped */
    BamRecord.prototype.isProperlyPaired = function () {
        return !!(this.flags & constants_1.default.BAM_FPROPER_PAIR);
    };
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */
    BamRecord.prototype.isSegmentUnmapped = function () {
        return !!(this.flags & constants_1.default.BAM_FUNMAP);
    };
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */
    BamRecord.prototype.isMateUnmapped = function () {
        return !!(this.flags & constants_1.default.BAM_FMUNMAP);
    };
    /** @returns {boolean} true if the read is mapped to the reverse strand */
    BamRecord.prototype.isReverseComplemented = function () {
        return !!(this.flags & constants_1.default.BAM_FREVERSE);
    };
    /** @returns {boolean} true if the mate is mapped to the reverse strand */
    BamRecord.prototype.isMateReverseComplemented = function () {
        return !!(this.flags & constants_1.default.BAM_FMREVERSE);
    };
    /** @returns {boolean} true if this is read number 1 in a pair */
    BamRecord.prototype.isRead1 = function () {
        return !!(this.flags & constants_1.default.BAM_FREAD1);
    };
    /** @returns {boolean} true if this is read number 2 in a pair */
    BamRecord.prototype.isRead2 = function () {
        return !!(this.flags & constants_1.default.BAM_FREAD2);
    };
    /** @returns {boolean} true if this is a secondary alignment */
    BamRecord.prototype.isSecondary = function () {
        return !!(this.flags & constants_1.default.BAM_FSECONDARY);
    };
    /** @returns {boolean} true if this read has failed QC checks */
    BamRecord.prototype.isFailedQc = function () {
        return !!(this.flags & constants_1.default.BAM_FQCFAIL);
    };
    /** @returns {boolean} true if the read is an optical or PCR duplicate */
    BamRecord.prototype.isDuplicate = function () {
        return !!(this.flags & constants_1.default.BAM_FDUP);
    };
    /** @returns {boolean} true if this is a supplementary alignment */
    BamRecord.prototype.isSupplementary = function () {
        return !!(this.flags & constants_1.default.BAM_FSUPPLEMENTARY);
    };
    BamRecord.prototype.cigar = function () {
        if (this.isSegmentUnmapped()) {
            return undefined;
        }
        var _a = this.bytes, byteArray = _a.byteArray, start = _a.start;
        var numCigarOps = this.get('_n_cigar_op');
        var p = start + 36 + this.get('_l_read_name');
        var seqLen = this.get('seq_length');
        var cigar = '';
        var lref = 0;
        // check for CG tag by inspecting whether the CIGAR field
        // contains a clip that consumes entire seqLen
        var cigop = byteArray.readInt32LE(p);
        var lop = cigop >> 4;
        var op = CIGAR_DECODER[cigop & 0xf];
        if (op === 'S' && lop === seqLen) {
            // if there is a CG the second CIGAR field will
            // be a N tag the represents the length on ref
            p += 4;
            cigop = byteArray.readInt32LE(p);
            lop = cigop >> 4;
            op = CIGAR_DECODER[cigop & 0xf];
            if (op !== 'N') {
                console.warn('CG tag with no N tag');
            }
            this.data.length_on_ref = lop;
            return this.get('CG');
        }
        else {
            for (var c = 0; c < numCigarOps; ++c) {
                cigop = byteArray.readInt32LE(p);
                lop = cigop >> 4;
                op = CIGAR_DECODER[cigop & 0xf];
                cigar += lop + op;
                // soft clip, hard clip, and insertion don't count toward
                // the length on the reference
                if (op !== 'H' && op !== 'S' && op !== 'I') {
                    lref += lop;
                }
                p += 4;
            }
            this.data.length_on_ref = lref;
            return cigar;
        }
    };
    BamRecord.prototype._flags = function () { };
    BamRecord.prototype.length_on_ref = function () {
        if (this.data.length_on_ref) {
            return this.data.length_on_ref;
        }
        else {
            this.get('cigar'); // the length_on_ref is set as a side effect
            return this.data.length_on_ref;
        }
    };
    BamRecord.prototype._n_cigar_op = function () {
        return this.get('_flag_nc') & 0xffff;
    };
    BamRecord.prototype._l_read_name = function () {
        return this.get('_bin_mq_nl') & 0xff;
    };
    /**
     * number of bytes in the sequence field
     */
    BamRecord.prototype._seq_bytes = function () {
        return (this.get('seq_length') + 1) >> 1;
    };
    BamRecord.prototype.getReadBases = function () {
        return this.seq();
    };
    BamRecord.prototype.seq = function () {
        var _a = this.bytes, byteArray = _a.byteArray, start = _a.start;
        var p = start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4;
        var seqBytes = this.get('_seq_bytes');
        var len = this.get('seq_length');
        var buf = '';
        var i = 0;
        for (var j = 0; j < seqBytes; ++j) {
            var sb = byteArray[p + j];
            buf += SEQRET_DECODER[(sb & 0xf0) >> 4];
            i++;
            if (i < len) {
                buf += SEQRET_DECODER[sb & 0x0f];
                i++;
            }
        }
        return buf;
    };
    // adapted from igv.js
    BamRecord.prototype.getPairOrientation = function () {
        if (!this.isSegmentUnmapped() &&
            !this.isMateUnmapped() &&
            this._refID === this._next_refid()) {
            var s1 = this.isReverseComplemented() ? 'R' : 'F';
            var s2 = this.isMateReverseComplemented() ? 'R' : 'F';
            var o1 = ' ';
            var o2 = ' ';
            if (this.isRead1()) {
                o1 = '1';
                o2 = '2';
            }
            else if (this.isRead2()) {
                o1 = '2';
                o2 = '1';
            }
            var tmp = [];
            var isize = this.template_length();
            if (isize > 0) {
                tmp[0] = s1;
                tmp[1] = o1;
                tmp[2] = s2;
                tmp[3] = o2;
            }
            else {
                tmp[2] = s1;
                tmp[3] = o1;
                tmp[0] = s2;
                tmp[1] = o2;
            }
            return tmp.join('');
        }
        return null;
    };
    BamRecord.prototype._bin_mq_nl = function () {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 12);
    };
    BamRecord.prototype._flag_nc = function () {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 16);
    };
    BamRecord.prototype.seq_length = function () {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 20);
    };
    BamRecord.prototype._next_refid = function () {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 24);
    };
    BamRecord.prototype._next_pos = function () {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 28);
    };
    BamRecord.prototype.template_length = function () {
        return this.bytes.byteArray.readInt32LE(this.bytes.start + 32);
    };
    BamRecord.prototype.toJSON = function () {
        var _this = this;
        var data = {};
        Object.keys(this).forEach(function (k) {
            if (k.charAt(0) === '_' || k === 'bytes') {
                return;
            }
            //@ts-ignore
            data[k] = _this[k];
        });
        return data;
    };
    return BamRecord;
}());
exports.default = BamRecord;
//# sourceMappingURL=record.js.map