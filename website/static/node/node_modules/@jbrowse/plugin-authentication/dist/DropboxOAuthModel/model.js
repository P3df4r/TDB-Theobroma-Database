"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropboxIcon = void 0;
const react_1 = __importDefault(require("react"));
const configuration_1 = require("@jbrowse/core/configuration");
const material_1 = require("@mui/material");
const mobx_state_tree_1 = require("mobx-state-tree");
const model_1 = __importDefault(require("../OAuthModel/model"));
const OAuthModel_1 = require("../OAuthModel");
/** Error messages from https://www.dropbox.com/developers/documentation/http/documentation#sharing-get_shared_link_file */
const dropboxErrorMessages = {
    shared_link_not_found: "The shared link wasn't found.",
    shared_link_access_denied: 'The caller is not allowed to access this shared link.',
    unsupported_link_type: 'This type of link is not supported; use files/export instead.',
    shared_link_is_directory: 'Directories cannot be retrieved by this endpoint.',
};
function DropboxIcon(props) {
    return (react_1.default.createElement(material_1.SvgIcon, { ...props },
        react_1.default.createElement("path", { d: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z" })));
}
exports.DropboxIcon = DropboxIcon;
async function getDescriptiveErrorMessage(response) {
    let errorMessage;
    try {
        errorMessage = await response.text();
    }
    catch (error) {
        errorMessage = '';
    }
    if (errorMessage) {
        let errorMessageParsed;
        try {
            errorMessageParsed = JSON.parse(errorMessage);
        }
        catch (error) {
            errorMessageParsed = undefined;
        }
        if (errorMessageParsed) {
            const messageTag = errorMessageParsed.error['.tag'];
            errorMessage = dropboxErrorMessages[messageTag] || messageTag;
        }
    }
    return `Network response failure â€” ${response.status} (${response.statusText})${errorMessage ? ` (${errorMessage})` : ''}`;
}
const stateModelFactory = (configSchema) => {
    return (0, model_1.default)(OAuthModel_1.configSchema)
        .named('DropboxOAuthInternetAccount')
        .props({
        type: mobx_state_tree_1.types.literal('DropboxOAuthInternetAccount'),
        configuration: (0, configuration_1.ConfigurationReference)(configSchema),
    })
        .views(() => ({
        get toggleContents() {
            return react_1.default.createElement(DropboxIcon, null);
        },
        get selectorLabel() {
            return 'Enter Dropbox share link';
        },
    }))
        .actions(self => ({
        getFetcher(location) {
            return async (input, init) => {
                const authToken = await self.getToken(location);
                const newInit = self.addAuthHeaderToInit({ ...init, method: 'POST' }, authToken);
                newInit.headers.append('Dropbox-API-Arg', JSON.stringify({ url: input }));
                const response = await fetch('https://content.dropboxapi.com/2/sharing/get_shared_link_file', newInit);
                if (!response.ok) {
                    const message = await getDescriptiveErrorMessage(response);
                    throw new Error(message);
                }
                return response;
            };
        },
        async validateToken(token, location) {
            const response = await fetch('https://api.dropboxapi.com/2/sharing/get_shared_link_metadata', {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${token}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url: location.uri,
                }),
            });
            if (!response.ok) {
                const refreshToken = self.hasRefreshToken && self.retrieveRefreshToken();
                if (refreshToken) {
                    self.removeRefreshToken();
                    const newToken = await self.exchangeRefreshForAccessToken(refreshToken);
                    return this.validateToken(newToken, location);
                }
                const message = await getDescriptiveErrorMessage(response);
                throw new Error(`Token could not be validated. ${message}`);
            }
            return token;
        },
    }));
};
exports.default = stateModelFactory;
//# sourceMappingURL=model.js.map