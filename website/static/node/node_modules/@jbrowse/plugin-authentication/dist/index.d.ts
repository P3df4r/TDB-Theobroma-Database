/// <reference types="react" />
import Plugin from '@jbrowse/core/Plugin';
import PluginManager from '@jbrowse/core/PluginManager';
import { configSchema as OAuthConfigSchema, modelFactory as OAuthInternetAccountModelFactory } from './OAuthModel';
import { configSchema as ExternalTokenConfigSchema, modelFactory as ExternalTokenInternetAccountModelFactory } from './ExternalTokenModel';
import { configSchema as HTTPBasicConfigSchema, modelFactory as HTTPBasicInternetAccountModelFactory } from './HTTPBasicModel';
import { configSchema as DropboxOAuthConfigSchema, modelFactory as DropboxOAuthInternetAccountModelFactory } from './DropboxOAuthModel';
import { configSchema as GoogleDriveOAuthConfigSchema, modelFactory as GoogleDriveOAuthInternetAccountModelFactory } from './GoogleDriveOAuthModel';
export default class AuthenticationPlugin extends Plugin {
    name: string;
    exports: {
        OAuthConfigSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType;
        OAuthInternetAccountModelFactory: (configSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType) => import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"OAuthInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        }, {
            readonly name: string;
            readonly description: string;
            readonly internetAccountId: string;
            readonly authHeader: string;
            readonly tokenType: string;
            readonly domains: string[];
            readonly toggleContents: import("react").ReactNode;
            readonly SelectorComponent: import("@jbrowse/core/util").AnyReactComponentType | undefined;
            readonly selectorLabel: string | undefined;
        } & {
            handlesLocation(location: import("@jbrowse/core/util").UriLocation): boolean;
            readonly tokenKey: string;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            storeToken(token: string): void;
            removeToken(): void;
            retrieveToken(): string | null;
            validateToken(token: string, loc: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            getToken(location?: import("@jbrowse/core/util").UriLocation | undefined): Promise<string>;
        } & {
            addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
                headers: Headers;
                body?: BodyInit | null | undefined;
                cache?: RequestCache | undefined;
                credentials?: RequestCredentials | undefined;
                integrity?: string | undefined;
                keepalive?: boolean | undefined;
                method?: string | undefined;
                mode?: RequestMode | undefined;
                redirect?: RequestRedirect | undefined;
                referrer?: string | undefined;
                referrerPolicy?: ReferrerPolicy | undefined;
                signal?: AbortSignal | null | undefined;
                window?: null | undefined;
            };
            getPreAuthorizationInformation(location: import("@jbrowse/core/util").UriLocation): Promise<{
                internetAccountType: string;
                authInfo: {
                    token: string;
                    configuration: any;
                };
            }>;
        } & {
            getFetcher(loc?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
        } & {
            openLocation(location: import("@jbrowse/core/util").UriLocation): import("@jbrowse/core/util/io").RemoteFileWithRangeCache;
        } & {
            readonly codeVerifierPKCE: string;
        } & {
            readonly authEndpoint: string;
            readonly tokenEndpoint: string;
            readonly needsPKCE: boolean;
            readonly clientId: string;
            readonly scopes: string;
            state(): string | undefined;
            readonly responseType: "code" | "token";
            readonly hasRefreshToken: boolean;
            readonly refreshTokenKey: string;
        } & {
            storeRefreshToken(refreshToken: string): void;
            removeRefreshToken(): void;
            retrieveRefreshToken(): string | null;
            exchangeAuthorizationForAccessToken(token: string, redirectUri: string): Promise<string>;
            exchangeRefreshForAccessToken(refreshToken: string): Promise<string>;
        } & {
            addMessageChannel(resolve: (token: string) => void, reject: (error: Error) => void): void;
            deleteMessageChannel(): void;
            finishOAuthWindow(event: MessageEvent<any>, resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            useEndpointForAuthorization(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        ExternalTokenConfigSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType;
        ExternalTokenInternetAccountModelFactory: (configSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType) => import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"ExternalTokenInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        }, {
            readonly name: string;
            readonly description: string;
            readonly internetAccountId: string;
            readonly authHeader: string;
            readonly tokenType: string;
            readonly domains: string[];
            readonly toggleContents: import("react").ReactNode;
            readonly SelectorComponent: import("@jbrowse/core/util").AnyReactComponentType | undefined;
            readonly selectorLabel: string | undefined;
        } & {
            handlesLocation(location: import("@jbrowse/core/util").UriLocation): boolean;
            readonly tokenKey: string;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            storeToken(token: string): void;
            removeToken(): void;
            retrieveToken(): string | null;
            validateToken(token: string, loc: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            getToken(location?: import("@jbrowse/core/util").UriLocation | undefined): Promise<string>;
        } & {
            addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
                headers: Headers;
                body?: BodyInit | null | undefined;
                cache?: RequestCache | undefined;
                credentials?: RequestCredentials | undefined;
                integrity?: string | undefined;
                keepalive?: boolean | undefined;
                method?: string | undefined;
                mode?: RequestMode | undefined;
                redirect?: RequestRedirect | undefined;
                referrer?: string | undefined;
                referrerPolicy?: ReferrerPolicy | undefined;
                signal?: AbortSignal | null | undefined;
                window?: null | undefined;
            };
            getPreAuthorizationInformation(location: import("@jbrowse/core/util").UriLocation): Promise<{
                internetAccountType: string;
                authInfo: {
                    token: string;
                    configuration: any;
                };
            }>;
        } & {
            getFetcher(loc?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
        } & {
            openLocation(location: import("@jbrowse/core/util").UriLocation): import("@jbrowse/core/util/io").RemoteFileWithRangeCache;
        } & {
            readonly validateWithHEAD: boolean;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        HTTPBasicConfigSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType;
        HTTPBasicInternetAccountModelFactory: (configSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType) => import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"HTTPBasicInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        }, {
            readonly name: string;
            readonly description: string;
            readonly internetAccountId: string;
            readonly authHeader: string;
            readonly tokenType: string;
            readonly domains: string[];
            readonly toggleContents: import("react").ReactNode;
            readonly SelectorComponent: import("@jbrowse/core/util").AnyReactComponentType | undefined;
            readonly selectorLabel: string | undefined;
        } & {
            handlesLocation(location: import("@jbrowse/core/util").UriLocation): boolean;
            readonly tokenKey: string;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            storeToken(token: string): void;
            removeToken(): void;
            retrieveToken(): string | null;
            validateToken(token: string, loc: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            getToken(location?: import("@jbrowse/core/util").UriLocation | undefined): Promise<string>;
        } & {
            addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
                headers: Headers;
                body?: BodyInit | null | undefined;
                cache?: RequestCache | undefined;
                credentials?: RequestCredentials | undefined;
                integrity?: string | undefined;
                keepalive?: boolean | undefined;
                method?: string | undefined;
                mode?: RequestMode | undefined;
                redirect?: RequestRedirect | undefined;
                referrer?: string | undefined;
                referrerPolicy?: ReferrerPolicy | undefined;
                signal?: AbortSignal | null | undefined;
                window?: null | undefined;
            };
            getPreAuthorizationInformation(location: import("@jbrowse/core/util").UriLocation): Promise<{
                internetAccountType: string;
                authInfo: {
                    token: string;
                    configuration: any;
                };
            }>;
        } & {
            getFetcher(loc?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
        } & {
            openLocation(location: import("@jbrowse/core/util").UriLocation): import("@jbrowse/core/util/io").RemoteFileWithRangeCache;
        } & {
            readonly validateWithHEAD: boolean;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        DropboxOAuthConfigSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType;
        DropboxOAuthInternetAccountModelFactory: (configSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType) => import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"OAuthInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"DropboxOAuthInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        }, {
            readonly name: string;
            readonly description: string;
            readonly internetAccountId: string;
            readonly authHeader: string;
            readonly tokenType: string;
            readonly domains: string[];
            readonly toggleContents: import("react").ReactNode;
            readonly SelectorComponent: import("@jbrowse/core/util").AnyReactComponentType | undefined;
            readonly selectorLabel: string | undefined;
        } & {
            handlesLocation(location: import("@jbrowse/core/util").UriLocation): boolean;
            readonly tokenKey: string;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            storeToken(token: string): void;
            removeToken(): void;
            retrieveToken(): string | null;
            validateToken(token: string, loc: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            getToken(location?: import("@jbrowse/core/util").UriLocation | undefined): Promise<string>;
        } & {
            addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
                headers: Headers;
                body?: BodyInit | null | undefined;
                cache?: RequestCache | undefined;
                credentials?: RequestCredentials | undefined;
                integrity?: string | undefined;
                keepalive?: boolean | undefined;
                method?: string | undefined;
                mode?: RequestMode | undefined;
                redirect?: RequestRedirect | undefined;
                referrer?: string | undefined;
                referrerPolicy?: ReferrerPolicy | undefined;
                signal?: AbortSignal | null | undefined;
                window?: null | undefined;
            };
            getPreAuthorizationInformation(location: import("@jbrowse/core/util").UriLocation): Promise<{
                internetAccountType: string;
                authInfo: {
                    token: string;
                    configuration: any;
                };
            }>;
        } & {
            getFetcher(loc?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
        } & {
            openLocation(location: import("@jbrowse/core/util").UriLocation): import("@jbrowse/core/util/io").RemoteFileWithRangeCache;
        } & {
            readonly codeVerifierPKCE: string;
        } & {
            readonly authEndpoint: string;
            readonly tokenEndpoint: string;
            readonly needsPKCE: boolean;
            readonly clientId: string;
            readonly scopes: string;
            state(): string | undefined;
            readonly responseType: "code" | "token";
            readonly hasRefreshToken: boolean;
            readonly refreshTokenKey: string;
        } & {
            storeRefreshToken(refreshToken: string): void;
            removeRefreshToken(): void;
            retrieveRefreshToken(): string | null;
            exchangeAuthorizationForAccessToken(token: string, redirectUri: string): Promise<string>;
            exchangeRefreshForAccessToken(refreshToken: string): Promise<string>;
        } & {
            addMessageChannel(resolve: (token: string) => void, reject: (error: Error) => void): void;
            deleteMessageChannel(): void;
            finishOAuthWindow(event: MessageEvent<any>, resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            useEndpointForAuthorization(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            readonly toggleContents: JSX.Element;
            readonly selectorLabel: string;
        } & {
            getFetcher(location?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        GoogleDriveOAuthConfigSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType;
        GoogleDriveOAuthInternetAccountModelFactory: (configSchema: import("@jbrowse/core/configuration").AnyConfigurationSchemaType) => import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"OAuthInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        } & {
            type: import("mobx-state-tree").ISimpleType<"GoogleDriveOAuthInternetAccount">;
            configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
        }, {
            readonly name: string;
            readonly description: string;
            readonly internetAccountId: string;
            readonly authHeader: string;
            readonly tokenType: string;
            readonly domains: string[];
            readonly toggleContents: import("react").ReactNode;
            readonly SelectorComponent: import("@jbrowse/core/util").AnyReactComponentType | undefined;
            readonly selectorLabel: string | undefined;
        } & {
            handlesLocation(location: import("@jbrowse/core/util").UriLocation): boolean;
            readonly tokenKey: string;
        } & {
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
            storeToken(token: string): void;
            removeToken(): void;
            retrieveToken(): string | null;
            validateToken(token: string, loc: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            getToken(location?: import("@jbrowse/core/util").UriLocation | undefined): Promise<string>;
        } & {
            addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
                headers: Headers;
                body?: BodyInit | null | undefined;
                cache?: RequestCache | undefined;
                credentials?: RequestCredentials | undefined;
                integrity?: string | undefined;
                keepalive?: boolean | undefined;
                method?: string | undefined;
                mode?: RequestMode | undefined;
                redirect?: RequestRedirect | undefined;
                referrer?: string | undefined;
                referrerPolicy?: ReferrerPolicy | undefined;
                signal?: AbortSignal | null | undefined;
                window?: null | undefined;
            };
            getPreAuthorizationInformation(location: import("@jbrowse/core/util").UriLocation): Promise<{
                internetAccountType: string;
                authInfo: {
                    token: string;
                    configuration: any;
                };
            }>;
        } & {
            getFetcher(loc?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
        } & {
            openLocation(location: import("@jbrowse/core/util").UriLocation): import("@jbrowse/core/util/io").RemoteFileWithRangeCache;
        } & {
            readonly codeVerifierPKCE: string;
        } & {
            readonly authEndpoint: string;
            readonly tokenEndpoint: string;
            readonly needsPKCE: boolean;
            readonly clientId: string;
            readonly scopes: string;
            state(): string | undefined;
            readonly responseType: "code" | "token";
            readonly hasRefreshToken: boolean;
            readonly refreshTokenKey: string;
        } & {
            storeRefreshToken(refreshToken: string): void;
            removeRefreshToken(): void;
            retrieveRefreshToken(): string | null;
            exchangeAuthorizationForAccessToken(token: string, redirectUri: string): Promise<string>;
            exchangeRefreshForAccessToken(refreshToken: string): Promise<string>;
        } & {
            addMessageChannel(resolve: (token: string) => void, reject: (error: Error) => void): void;
            deleteMessageChannel(): void;
            finishOAuthWindow(event: MessageEvent<any>, resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            useEndpointForAuthorization(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        } & {
            readonly toggleContents: JSX.Element;
            readonly selectorLabel: string;
        } & {
            getFetcher(location?: import("@jbrowse/core/util").UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
            openLocation(location: import("@jbrowse/core/util").UriLocation): import("./GoogleDriveOAuthModel/model").GoogleDriveFile;
            validateToken(token: string, location: import("@jbrowse/core/util").UriLocation): Promise<string>;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
    };
    install(pluginManager: PluginManager): void;
}
export { OAuthConfigSchema, OAuthInternetAccountModelFactory, ExternalTokenConfigSchema, ExternalTokenInternetAccountModelFactory, HTTPBasicConfigSchema, HTTPBasicInternetAccountModelFactory, DropboxOAuthConfigSchema, DropboxOAuthInternetAccountModelFactory, GoogleDriveOAuthConfigSchema, GoogleDriveOAuthInternetAccountModelFactory, };
