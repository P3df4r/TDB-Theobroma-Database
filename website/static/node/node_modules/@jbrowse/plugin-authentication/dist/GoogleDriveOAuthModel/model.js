"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleDriveFile = void 0;
const react_1 = __importDefault(require("react"));
const configuration_1 = require("@jbrowse/core/configuration");
const mobx_state_tree_1 = require("mobx-state-tree");
const io_1 = require("@jbrowse/core/util/io");
const material_1 = require("@mui/material");
const model_1 = __importDefault(require("../OAuthModel/model"));
const OAuthModel_1 = require("../OAuthModel");
class GoogleDriveFile extends io_1.RemoteFileWithRangeCache {
    constructor(source, opts) {
        super(source, opts);
        this.statsPromise = this.fetch(source, {
            metadataOnly: true,
        }).then((response) => response.json());
    }
    async fetch(input, opts) {
        return super.fetch(input, opts);
    }
    async stat() {
        return this.statsPromise;
    }
}
exports.GoogleDriveFile = GoogleDriveFile;
function GoogleDriveIcon(props) {
    return (react_1.default.createElement(material_1.SvgIcon, { ...props },
        react_1.default.createElement("path", { d: "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z" })));
}
async function getDescriptiveErrorMessage(response) {
    let errorMessage;
    try {
        errorMessage = await response.text();
    }
    catch (error) {
        errorMessage = '';
    }
    if (errorMessage) {
        let errorMessageParsed;
        try {
            errorMessageParsed = JSON.parse(errorMessage);
        }
        catch (error) {
            errorMessageParsed = undefined;
        }
        if (errorMessageParsed) {
            errorMessage = errorMessageParsed.error.message;
        }
    }
    return `Network response failure â€” ${response.status} (${response.statusText})${errorMessage ? ` (${errorMessage})` : ''}`;
}
const stateModelFactory = (configSchema) => {
    return (0, model_1.default)(OAuthModel_1.configSchema)
        .named('GoogleDriveOAuthInternetAccount')
        .props({
        type: mobx_state_tree_1.types.literal('GoogleDriveOAuthInternetAccount'),
        configuration: (0, configuration_1.ConfigurationReference)(configSchema),
    })
        .views(() => ({
        get toggleContents() {
            return react_1.default.createElement(GoogleDriveIcon, null);
        },
        get selectorLabel() {
            return 'Enter Google Drive share link';
        },
    }))
        .actions(self => ({
        getFetcher(location) {
            return async (input, init) => {
                const urlId = String(input).match(/[-\w]{25,}/);
                const driveUrl = new URL(`https://www.googleapis.com/drive/v3/files/${urlId}`);
                const searchParams = new URLSearchParams();
                if (init === null || init === void 0 ? void 0 : init.metadataOnly) {
                    searchParams.append('fields', 'size');
                }
                else {
                    searchParams.append('alt', 'media');
                }
                driveUrl.search = searchParams.toString();
                const authToken = await self.getToken(location);
                const newInit = self.addAuthHeaderToInit({ ...init, method: 'GET', credentials: 'same-origin' }, authToken);
                const response = await fetch(driveUrl.toString(), newInit);
                if (!response.ok) {
                    const message = await getDescriptiveErrorMessage(response);
                    throw new Error(message);
                }
                return response;
            };
        },
        openLocation(location) {
            return new GoogleDriveFile(location.uri, {
                fetch: this.getFetcher(location),
            });
        },
        async validateToken(token, location) {
            const urlId = location.uri.match(/[-\w]{25,}/);
            const response = await fetch(`https://www.googleapis.com/drive/v3/files/${urlId}`, {
                headers: {
                    Authorization: `Bearer ${token}`,
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
            });
            if (!response.ok) {
                const message = await getDescriptiveErrorMessage(response);
                throw new Error(`Token could not be validated. ${message}`);
            }
            return token;
        },
    }));
};
exports.default = stateModelFactory;
//# sourceMappingURL=model.js.map