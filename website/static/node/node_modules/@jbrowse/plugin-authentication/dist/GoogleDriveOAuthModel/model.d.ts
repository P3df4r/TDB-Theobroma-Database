import React from 'react';
import { Instance } from 'mobx-state-tree';
import { RemoteFileWithRangeCache } from '@jbrowse/core/util/io';
import { UriLocation } from '@jbrowse/core/util/types';
import { FilehandleOptions, Stats, PolyfilledResponse } from 'generic-filehandle';
import { GoogleDriveOAuthInternetAccountConfigModel } from './configSchema';
export interface RequestInitWithMetadata extends RequestInit {
    metadataOnly?: boolean;
}
interface GoogleDriveFilehandleOptions extends FilehandleOptions {
    fetch(input: RequestInfo, opts?: RequestInitWithMetadata): Promise<PolyfilledResponse>;
}
export declare class GoogleDriveFile extends RemoteFileWithRangeCache {
    private statsPromise;
    constructor(source: string, opts: GoogleDriveFilehandleOptions);
    fetch(input: RequestInfo, opts?: RequestInitWithMetadata): Promise<PolyfilledResponse>;
    stat(): Promise<Stats>;
}
declare const stateModelFactory: (configSchema: GoogleDriveOAuthInternetAccountConfigModel) => import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").ISimpleType<string>;
} & {
    type: import("mobx-state-tree").ISimpleType<"OAuthInternetAccount">;
    configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
} & {
    type: import("mobx-state-tree").ISimpleType<"GoogleDriveOAuthInternetAccount">;
    configuration: import("mobx-state-tree").ITypeUnion<any, any, any>;
}, {
    readonly name: string;
    readonly description: string;
    readonly internetAccountId: string;
    readonly authHeader: string;
    readonly tokenType: string;
    readonly domains: string[];
    readonly toggleContents: React.ReactNode;
    readonly SelectorComponent: import("@jbrowse/core/util/types").AnyReactComponentType | undefined;
    readonly selectorLabel: string | undefined;
} & {
    handlesLocation(location: UriLocation): boolean;
    readonly tokenKey: string;
} & {
    getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): void;
    storeToken(token: string): void;
    removeToken(): void;
    retrieveToken(): string | null;
    validateToken(token: string, loc: UriLocation): Promise<string>;
} & {
    getToken(location?: UriLocation | undefined): Promise<string>;
} & {
    addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
        headers: Headers;
        body?: BodyInit | null | undefined;
        cache?: RequestCache | undefined;
        credentials?: RequestCredentials | undefined;
        integrity?: string | undefined;
        keepalive?: boolean | undefined;
        method?: string | undefined;
        mode?: RequestMode | undefined;
        redirect?: RequestRedirect | undefined;
        referrer?: string | undefined;
        referrerPolicy?: ReferrerPolicy | undefined;
        signal?: AbortSignal | null | undefined;
        window?: null | undefined;
    };
    getPreAuthorizationInformation(location: UriLocation): Promise<{
        internetAccountType: string;
        authInfo: {
            token: string;
            configuration: any;
        };
    }>;
} & {
    getFetcher(loc?: UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
} & {
    openLocation(location: UriLocation): RemoteFileWithRangeCache;
} & {
    readonly codeVerifierPKCE: string;
} & {
    readonly authEndpoint: string;
    readonly tokenEndpoint: string;
    readonly needsPKCE: boolean;
    readonly clientId: string;
    readonly scopes: string;
    state(): string | undefined;
    readonly responseType: "code" | "token";
    readonly hasRefreshToken: boolean;
    readonly refreshTokenKey: string;
} & {
    storeRefreshToken(refreshToken: string): void;
    removeRefreshToken(): void;
    retrieveRefreshToken(): string | null;
    exchangeAuthorizationForAccessToken(token: string, redirectUri: string): Promise<string>;
    exchangeRefreshForAccessToken(refreshToken: string): Promise<string>;
} & {
    addMessageChannel(resolve: (token: string) => void, reject: (error: Error) => void): void;
    deleteMessageChannel(): void;
    finishOAuthWindow(event: MessageEvent<any>, resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
    useEndpointForAuthorization(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
    getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
    validateToken(token: string, location: UriLocation): Promise<string>;
} & {
    readonly toggleContents: JSX.Element;
    readonly selectorLabel: string;
} & {
    getFetcher(location?: UriLocation): (input: RequestInfo, init?: RequestInit) => Promise<Response>;
    openLocation(location: UriLocation): GoogleDriveFile;
    validateToken(token: string, location: UriLocation): Promise<string>;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export default stateModelFactory;
export type GoogleDriveOAuthStateModel = ReturnType<typeof stateModelFactory>;
export type GoogleDriveOAuthModel = Instance<GoogleDriveOAuthStateModel>;
