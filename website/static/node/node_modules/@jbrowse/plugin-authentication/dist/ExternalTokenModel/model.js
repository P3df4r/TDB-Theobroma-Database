"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const configuration_1 = require("@jbrowse/core/configuration");
const models_1 = require("@jbrowse/core/pluggableElementTypes/models");
const mobx_state_tree_1 = require("mobx-state-tree");
const ExternalTokenEntryForm_1 = require("./ExternalTokenEntryForm");
const stateModelFactory = (configSchema) => {
    return models_1.InternetAccount.named('ExternalTokenInternetAccount')
        .props({
        type: mobx_state_tree_1.types.literal('ExternalTokenInternetAccount'),
        configuration: (0, configuration_1.ConfigurationReference)(configSchema),
    })
        .views(self => ({
        get validateWithHEAD() {
            return (0, configuration_1.getConf)(self, 'validateWithHEAD');
        },
    }))
        .actions(self => ({
        getTokenFromUser(resolve, reject) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const { session } = (0, mobx_state_tree_1.getRoot)(self);
            session.queueDialog((doneCallback) => [
                ExternalTokenEntryForm_1.ExternalTokenEntryForm,
                {
                    internetAccountId: self.internetAccountId,
                    handleClose: (token) => {
                        if (token) {
                            resolve(token);
                        }
                        else {
                            reject(new Error('user cancelled entry'));
                        }
                        doneCallback();
                    },
                },
            ]);
        },
        async validateToken(token, location) {
            if (!self.validateWithHEAD) {
                return token;
            }
            const newInit = self.addAuthHeaderToInit({ method: 'HEAD' }, token);
            const response = await fetch(location.uri, newInit);
            if (!response.ok) {
                let errorMessage;
                try {
                    errorMessage = await response.text();
                }
                catch (error) {
                    errorMessage = '';
                }
                throw new Error(`Token could not be validated â€” ${response.status} (${response.statusText})${errorMessage ? ` (${errorMessage})` : ''}`);
            }
            return token;
        },
    }));
};
exports.default = stateModelFactory;
//# sourceMappingURL=model.js.map