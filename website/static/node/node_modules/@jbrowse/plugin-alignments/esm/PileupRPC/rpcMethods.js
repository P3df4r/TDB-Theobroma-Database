import RpcMethodType from '@jbrowse/core/pluggableElementTypes/RpcMethodType';
import { getAdapter } from '@jbrowse/core/data_adapters/dataAdapterCache';
import { renameRegionsIfNeeded } from '@jbrowse/core/util';
import { toArray } from 'rxjs/operators';
// locals
import { getTagAlt } from '../util';
import { getModificationTypes } from '../BamAdapter/MismatchParser';
export class PileupGetGlobalValueForTag extends RpcMethodType {
    constructor() {
        super(...arguments);
        this.name = 'PileupGetGlobalValueForTag';
    }
    async serializeArguments(args, rpcDriverClassName) {
        var _a;
        const { rootModel } = this.pluginManager;
        const assemblyManager = (_a = rootModel === null || rootModel === void 0 ? void 0 : rootModel.session) === null || _a === void 0 ? void 0 : _a.assemblyManager;
        if (!assemblyManager) {
            throw new Error('no assembly manager available');
        }
        const renamedArgs = await renameRegionsIfNeeded(assemblyManager, args);
        return super.serializeArguments(renamedArgs, rpcDriverClassName);
    }
    async execute(args, rpcDriverClassName) {
        const pm = this.pluginManager;
        const deArgs = await this.deserializeArguments(args, rpcDriverClassName);
        const { adapterConfig, sessionId, regions, tag } = deArgs;
        const dataAdapter = (await getAdapter(pm, sessionId, adapterConfig))
            .dataAdapter;
        const features = dataAdapter.getFeaturesInMultipleRegions(regions);
        const featuresArray = await features.pipe(toArray()).toPromise();
        const uniqueValues = new Set();
        featuresArray.forEach(feature => {
            const tags = feature.get('tags');
            const val = tags ? tags[tag] : feature.get(tag);
            if (val !== undefined) {
                uniqueValues.add(`${val}`);
            }
        });
        return [...uniqueValues];
    }
}
export class PileupGetVisibleModifications extends RpcMethodType {
    constructor() {
        super(...arguments);
        this.name = 'PileupGetVisibleModifications';
    }
    async serializeArguments(args, rpcDriverClassName) {
        var _a;
        const { rootModel } = this.pluginManager;
        const assemblyManager = (_a = rootModel === null || rootModel === void 0 ? void 0 : rootModel.session) === null || _a === void 0 ? void 0 : _a.assemblyManager;
        if (!assemblyManager) {
            throw new Error('no assembly manager available');
        }
        const renamedArgs = await renameRegionsIfNeeded(assemblyManager, args);
        return super.serializeArguments(renamedArgs, rpcDriverClassName);
    }
    async execute(args, rpcDriverClassName) {
        const pm = this.pluginManager;
        const deArgs = await this.deserializeArguments(args, rpcDriverClassName);
        const { adapterConfig, sessionId, regions } = deArgs;
        const dataAdapter = (await getAdapter(pm, sessionId, adapterConfig))
            .dataAdapter;
        const features = dataAdapter.getFeaturesInMultipleRegions(regions);
        const featuresArray = await features.pipe(toArray()).toPromise();
        const uniqueValues = new Set();
        featuresArray.forEach(feature => {
            const val = getTagAlt(feature, 'MM', 'Mm') || '';
            if (val !== undefined) {
                getModificationTypes(val).forEach(t => uniqueValues.add(t));
            }
        });
        return [...uniqueValues];
    }
}
//# sourceMappingURL=rpcMethods.js.map