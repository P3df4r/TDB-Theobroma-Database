import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';
import SimpleFeature from '@jbrowse/core/util/simpleFeature';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import { toArray } from 'rxjs/operators';
import { getTag, getTagAlt, fetchSequence, shouldFetchReferenceSequence, } from '../util';
import { parseCigar, getNextRefPos, getModificationPositions, } from '../BamAdapter/MismatchParser';
function mismatchLen(mismatch) {
    return !isInterbase(mismatch.type) ? mismatch.length : 1;
}
function isInterbase(type) {
    return type === 'softclip' || type === 'hardclip' || type === 'insertion';
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function inc(bin, strand, type, field) {
    let thisBin = bin[type][field];
    if (thisBin === undefined) {
        thisBin = bin[type][field] = {
            total: 0,
            '-1': 0,
            '0': 0,
            '1': 0,
        };
    }
    thisBin.total++;
    thisBin[strand]++;
}
export default class SNPCoverageAdapter extends BaseFeatureDataAdapter {
    async configure() {
        var _a, _b;
        const subadapterConfig = this.getConf('subadapter');
        const sequenceConf = this.getConf(['subadapter', 'sequenceAdapter']);
        const dataAdapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, subadapterConfig));
        const sequenceAdapter = sequenceConf
            ? await ((_b = this.getSubAdapter) === null || _b === void 0 ? void 0 : _b.call(this, sequenceConf))
            : undefined;
        if (!dataAdapter) {
            throw new Error('Failed to get subadapter');
        }
        return {
            subadapter: dataAdapter.dataAdapter,
            sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter,
        };
    }
    async fetchSequence(region) {
        const { sequenceAdapter } = await this.configure();
        if (!sequenceAdapter) {
            return undefined;
        }
        return fetchSequence(region, sequenceAdapter);
    }
    getFeatures(region, opts = {}) {
        return ObservableCreate(async (observer) => {
            const { subadapter } = await this.configure();
            const feats = await subadapter
                .getFeatures(region, opts)
                .pipe(toArray())
                .toPromise();
            const { bins, skipmap } = await this.generateCoverageBins(feats, region, opts);
            bins.forEach((bin, index) => {
                const start = region.start + index;
                observer.next(new SimpleFeature({
                    id: `${this.id}-${start}`,
                    data: {
                        score: bin.total,
                        snpinfo: bin,
                        start,
                        end: start + 1,
                        refName: region.refName,
                    },
                }));
            });
            // make fake features from the coverage
            Object.entries(skipmap).forEach(([key, skip]) => {
                observer.next(new SimpleFeature({
                    id: key,
                    data: {
                        type: 'skip',
                        start: skip.start,
                        end: skip.end,
                        strand: skip.strand,
                        score: skip.score,
                        xs: skip.xs,
                    },
                }));
            });
            observer.complete();
        }, opts.signal);
    }
    async estimateRegionsStats(regions, opts) {
        const { subadapter } = await this.configure();
        return subadapter.estimateRegionsStats(regions, opts);
    }
    async getRefNames(opts = {}) {
        const { subadapter } = await this.configure();
        return subadapter.getRefNames(opts);
    }
    freeResources( /* { region } */) { }
    async generateCoverageBins(features, region, opts) {
        var _a;
        const { colorBy } = opts;
        const binMax = Math.ceil(region.end - region.start);
        const skipmap = {};
        const regionSeq = features.length && shouldFetchReferenceSequence((_a = opts.colorBy) === null || _a === void 0 ? void 0 : _a.type)
            ? await this.fetchSequence(region)
            : undefined;
        const bins = [];
        for (let i = 0; i < features.length; i++) {
            const feature = features[i];
            const fstart = feature.get('start');
            const fend = feature.get('end');
            const fstrand = feature.get('strand');
            for (let j = fstart; j < fend + 1; j++) {
                const i = j - region.start;
                if (i >= 0 && i < binMax) {
                    if (bins[i] === undefined) {
                        bins[i] = {
                            total: 0,
                            all: 0,
                            ref: 0,
                            '-1': 0,
                            '0': 0,
                            '1': 0,
                            lowqual: {},
                            cov: {},
                            delskips: {},
                            noncov: {},
                        };
                    }
                    if (j !== fend) {
                        bins[i].total++;
                        bins[i].all++;
                        bins[i].ref++;
                        bins[i][fstrand]++;
                    }
                }
            }
            if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {
                const seq = feature.get('seq');
                const mm = getTagAlt(feature, 'MM', 'Mm') || '';
                const ops = parseCigar(feature.get('CIGAR'));
                const fend = feature.get('end');
                getModificationPositions(mm, seq, fstrand).forEach(({ type, positions }) => {
                    const mod = `mod_${type}`;
                    for (const pos of getNextRefPos(ops, positions)) {
                        const epos = pos + fstart - region.start;
                        if (epos >= 0 && epos < bins.length && pos + fstart < fend) {
                            const bin = bins[epos];
                            if (bin) {
                                inc(bin, fstrand, 'cov', mod);
                            }
                            else {
                                console.warn('Undefined position in modifications snpcoverage encountered');
                            }
                        }
                    }
                });
            }
            // methylation based coloring takes into account both reference
            // sequence CpG detection and reads
            else if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {
                if (!regionSeq) {
                    throw new Error('no region sequence detected, need sequenceAdapter configuration');
                }
                const seq = feature.get('seq');
                const mm = getTagAlt(feature, 'MM', 'Mm') || '';
                const methBins = new Array(region.end - region.start).fill(0);
                const ops = parseCigar(feature.get('CIGAR'));
                getModificationPositions(mm, seq, fstrand).forEach(({ type, positions }) => {
                    // we are processing methylation
                    if (type === 'm') {
                        for (const pos of getNextRefPos(ops, positions)) {
                            const epos = pos + fstart - region.start;
                            if (epos >= 0 && epos < methBins.length) {
                                methBins[epos] = 1;
                            }
                        }
                    }
                });
                for (let j = fstart; j < fend; j++) {
                    const i = j - region.start;
                    if (i >= 0 && i < bins.length - 1) {
                        const l1 = regionSeq[i].toLowerCase();
                        const l2 = regionSeq[i + 1].toLowerCase();
                        const bin = bins[i];
                        const bin1 = bins[i + 1];
                        // color
                        if (l1 === 'c' && l2 === 'g') {
                            if (methBins[i] || methBins[i + 1]) {
                                inc(bin, fstrand, 'cov', 'meth');
                                inc(bin1, fstrand, 'cov', 'meth');
                                bins[i].ref--;
                                bins[i][fstrand]--;
                                bins[i + 1].ref--;
                                bins[i + 1][fstrand]--;
                            }
                            else {
                                inc(bin, fstrand, 'cov', 'unmeth');
                                inc(bin1, fstrand, 'cov', 'unmeth');
                                bins[i].ref--;
                                bins[i][fstrand]--;
                                bins[i + 1].ref--;
                                bins[i + 1][fstrand]--;
                            }
                        }
                    }
                }
            }
            // normal SNP based coloring
            const mismatches = feature.get('mismatches') || [];
            const colorSNPs = (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) !== 'modifications' && (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) !== 'methylation';
            for (let i = 0; i < mismatches.length; i++) {
                const mismatch = mismatches[i];
                const mstart = fstart + mismatch.start;
                const mlen = mismatchLen(mismatch);
                const mend = mstart + mlen;
                for (let j = mstart; j < mstart + mlen; j++) {
                    const epos = j - region.start;
                    if (epos >= 0 && epos < bins.length) {
                        const bin = bins[epos];
                        const { base, type } = mismatch;
                        const interbase = isInterbase(type);
                        if (!interbase) {
                            bin.ref--;
                            bin[fstrand]--;
                        }
                        else {
                            inc(bin, fstrand, 'noncov', type);
                        }
                        if (type === 'deletion' || type === 'skip') {
                            inc(bin, fstrand, 'delskips', type);
                            bin.total--;
                        }
                        else if (!interbase && colorSNPs) {
                            inc(bin, fstrand, 'cov', base);
                            bin.refbase = mismatch.altbase;
                        }
                    }
                }
                if (mismatch.type === 'skip') {
                    const hash = `${mstart}_${mend}_${fstrand}`;
                    if (skipmap[hash] === undefined) {
                        skipmap[hash] = {
                            feature: feature,
                            start: mstart,
                            end: mend,
                            strand: fstrand,
                            xs: getTag(feature, 'XS') || getTag(feature, 'TS'),
                            score: 0,
                        };
                    }
                    skipmap[hash].score++;
                }
            }
        }
        return { bins, skipmap };
    }
}
const { capabilities } = SNPCoverageAdapter;
export { capabilities };
//# sourceMappingURL=SNPCoverageAdapter.js.map