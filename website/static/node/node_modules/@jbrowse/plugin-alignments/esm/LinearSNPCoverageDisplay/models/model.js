import { addDisposer, types, cast, getEnv, getSnapshot } from 'mobx-state-tree';
import { observable, autorun } from 'mobx';
import { getConf, readConfObject, } from '@jbrowse/core/configuration';
import { linearWiggleDisplayModelFactory } from '@jbrowse/plugin-wiggle';
import { getContainingView } from '@jbrowse/core/util';
// locals
import Tooltip from '../components/Tooltip';
import { getUniqueModificationValues } from '../../shared';
// using a map because it preserves order
const rendererTypes = new Map([['snpcoverage', 'SNPCoverageRenderer']]);
/**
 * #stateModel LinearSNPCoverageDisplay
 * extends `LinearWiggleDisplay`
 */
function stateModelFactory(pluginManager, configSchema) {
    return types
        .compose('LinearSNPCoverageDisplay', linearWiggleDisplayModelFactory(pluginManager, configSchema), types.model({
        /**
         * #property
         */
        type: types.literal('LinearSNPCoverageDisplay'),
        /**
         * #property
         */
        drawInterbaseCounts: types.maybe(types.boolean),
        /**
         * #property
         */
        drawIndicators: types.maybe(types.boolean),
        /**
         * #property
         */
        drawArcs: types.maybe(types.boolean),
        /**
         * #property
         */
        filterBy: types.optional(types.model({
            flagInclude: types.optional(types.number, 0),
            flagExclude: types.optional(types.number, 1540),
            readName: types.maybe(types.string),
            tagFilter: types.maybe(types.model({ tag: types.string, value: types.string })),
        }), {}),
        /**
         * #property
         */
        colorBy: types.maybe(types.model({
            type: types.string,
            tag: types.maybe(types.string),
        })),
    }))
        .volatile(() => ({
        modificationTagMap: observable.map({}),
    }))
        .actions(self => ({
        /**
         * #action
         */
        setConfig(configuration) {
            self.configuration = configuration;
        },
        /**
         * #action
         */
        setFilterBy(filter) {
            self.filterBy = cast(filter);
        },
        /**
         * #action
         */
        setColorBy(colorBy) {
            self.colorBy = cast(colorBy);
        },
        /**
         * #action
         */
        updateModificationColorMap(uniqueModifications) {
            const colorPalette = ['red', 'blue', 'green', 'orange', 'purple'];
            let i = 0;
            uniqueModifications.forEach(value => {
                if (!self.modificationTagMap.has(value)) {
                    const newColor = colorPalette[i++];
                    self.modificationTagMap.set(value, newColor);
                }
            });
        },
    }))
        .views(self => {
        const { renderProps: superRenderProps } = self;
        return {
            /**
             * #getter
             */
            get rendererConfig() {
                var _a, _b, _c;
                const configBlob = getConf(self, ['renderers', self.rendererTypeName]) || {};
                return self.rendererType.configSchema.create({
                    ...configBlob,
                    drawInterbaseCounts: (_a = self.drawInterbaseCounts) !== null && _a !== void 0 ? _a : configBlob.drawInterbaseCounts,
                    drawIndicators: (_b = self.drawIndicators) !== null && _b !== void 0 ? _b : configBlob.drawIndicators,
                    drawArcs: (_c = self.drawArcs) !== null && _c !== void 0 ? _c : configBlob.drawArcs,
                }, getEnv(self));
            },
            /**
             * #getter
             */
            get drawArcsSetting() {
                var _a;
                return ((_a = self.drawArcs) !== null && _a !== void 0 ? _a : readConfObject(this.rendererConfig, 'drawArcs'));
            },
            /**
             * #getter
             */
            get drawInterbaseCountsSetting() {
                var _a;
                return ((_a = self.drawInterbaseCounts) !== null && _a !== void 0 ? _a : readConfObject(this.rendererConfig, 'drawInterbaseCounts'));
            },
            /**
             * #getter
             */
            get drawIndicatorsSetting() {
                var _a;
                return ((_a = self.drawIndicators) !== null && _a !== void 0 ? _a : readConfObject(this.rendererConfig, 'drawIndicators'));
            },
            /**
             * #getter
             */
            get modificationsReady() {
                var _a;
                return ((_a = self.colorBy) === null || _a === void 0 ? void 0 : _a.type) === 'modifications'
                    ? Object.keys(JSON.parse(JSON.stringify(self.modificationTagMap)))
                        .length > 0
                    : true;
            },
            /**
             * #method
             */
            renderProps() {
                const superProps = superRenderProps();
                const { colorBy, filterBy, modificationTagMap } = self;
                return {
                    ...superProps,
                    notReady: superProps.notReady || !this.modificationsReady,
                    modificationTagMap: Object.fromEntries(modificationTagMap.toJSON()),
                    // must use getSnapshot because otherwise changes to e.g. just the
                    // colorBy.type are not read
                    colorBy: colorBy ? getSnapshot(colorBy) : undefined,
                    filterBy: filterBy ? getSnapshot(filterBy) : undefined,
                };
            },
        };
    })
        .actions(self => ({
        /**
         * #action
         */
        toggleDrawIndicators() {
            self.drawIndicators = !self.drawIndicatorsSetting;
        },
        /**
         * #action
         */
        toggleDrawInterbaseCounts() {
            self.drawInterbaseCounts = !self.drawInterbaseCountsSetting;
        },
        /**
         * #action
         */
        toggleDrawArcs() {
            self.drawArcs = !self.drawArcsSetting;
        },
        afterAttach() {
            addDisposer(self, autorun(async () => {
                try {
                    const { colorBy } = self;
                    const view = getContainingView(self);
                    if (!view.initialized ||
                        !self.estimatedStatsReady ||
                        self.regionTooLarge) {
                        return;
                    }
                    const { staticBlocks } = view;
                    if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {
                        const adapter = getConf(self.parentTrack, 'adapter');
                        self.updateModificationColorMap(await getUniqueModificationValues(self, adapter, colorBy, staticBlocks));
                    }
                }
                catch (error) {
                    console.error(error);
                    self.setError(error);
                }
            }, { delay: 1000 }));
        },
    }))
        .views(self => {
        const { trackMenuItems: superTrackMenuItems } = self;
        return {
            /**
             * #getter
             */
            get TooltipComponent() {
                return Tooltip;
            },
            /**
             * #getter
             */
            get adapterConfig() {
                const subadapter = getConf(self.parentTrack, 'adapter');
                return {
                    type: 'SNPCoverageAdapter',
                    subadapter,
                };
            },
            /**
             * #getter
             */
            get rendererTypeName() {
                return rendererTypes.get('snpcoverage');
            },
            /**
             * #getter
             */
            get needsScalebar() {
                return true;
            },
            /**
             * #method
             */
            contextMenuItems() {
                return [];
            },
            /**
             * #method
             */
            trackMenuItems() {
                return [
                    ...superTrackMenuItems(),
                    {
                        label: 'Draw insertion/clipping indicators',
                        type: 'checkbox',
                        checked: self.drawIndicatorsSetting,
                        onClick: () => self.toggleDrawIndicators(),
                    },
                    {
                        label: 'Draw insertion/clipping counts',
                        type: 'checkbox',
                        checked: self.drawInterbaseCountsSetting,
                        onClick: () => self.toggleDrawInterbaseCounts(),
                    },
                    {
                        label: 'Draw arcs',
                        type: 'checkbox',
                        checked: self.drawArcsSetting,
                        onClick: () => self.toggleDrawArcs(),
                    },
                ];
            },
        };
    });
}
export default stateModelFactory;
//# sourceMappingURL=model.js.map