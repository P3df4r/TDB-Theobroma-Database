"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const copy_to_clipboard_1 = __importDefault(require("copy-to-clipboard"));
const configuration_1 = require("@jbrowse/core/configuration");
const tracks_1 = require("@jbrowse/core/util/tracks");
const util_1 = require("@jbrowse/core/util");
const plugin_linear_genome_view_1 = require("@jbrowse/plugin-linear-genome-view");
// icons
const Visibility_1 = __importDefault(require("@mui/icons-material/Visibility"));
const Icons_1 = require("@jbrowse/core/ui/Icons");
const MenuOpen_1 = __importDefault(require("@mui/icons-material/MenuOpen"));
const Sort_1 = __importDefault(require("@mui/icons-material/Sort"));
const Palette_1 = __importDefault(require("@mui/icons-material/Palette"));
const ClearAll_1 = __importDefault(require("@mui/icons-material/ClearAll"));
const LinearPileupDisplayBlurb_1 = __importDefault(require("./components/LinearPileupDisplayBlurb"));
const shared_1 = require("../shared");
// async
const ColorByTagDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/ColorByTag'))));
const FilterByTagDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/FilterByTag'))));
const SortByTagDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/SortByTag'))));
const SetFeatureHeightDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/SetFeatureHeight'))));
const SetMaxHeightDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/SetMaxHeight'))));
const ModificationsDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./components/ColorByModifications'))));
// using a map because it preserves order
const rendererTypes = new Map([
    ['pileup', 'PileupRenderer'],
    ['svg', 'SvgFeatureRenderer'],
]);
/**
 * #stateModel LinearPileupDisplay
 * extends `BaseLinearDisplay`
 */
function stateModelFactory(configSchema) {
    return mobx_state_tree_1.types
        .compose('LinearPileupDisplay', plugin_linear_genome_view_1.BaseLinearDisplay, mobx_state_tree_1.types.model({
        /**
         * #property
         */
        type: mobx_state_tree_1.types.literal('LinearPileupDisplay'),
        /**
         * #property
         */
        configuration: (0, configuration_1.ConfigurationReference)(configSchema),
        /**
         * #property
         */
        showSoftClipping: false,
        /**
         * #property
         */
        featureHeight: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
        /**
         * #property
         */
        noSpacing: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.boolean),
        /**
         * #property
         */
        fadeLikelihood: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.boolean),
        /**
         * #property
         */
        trackMaxHeight: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
        /**
         * #property
         */
        mismatchAlpha: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.boolean),
        /**
         * #property
         */
        sortedBy: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.model({
            type: mobx_state_tree_1.types.string,
            pos: mobx_state_tree_1.types.number,
            tag: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
            refName: mobx_state_tree_1.types.string,
            assemblyName: mobx_state_tree_1.types.string,
        })),
        /**
         * #property
         */
        colorBy: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.model({
            type: mobx_state_tree_1.types.string,
            tag: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
            extra: mobx_state_tree_1.types.frozen(),
        })),
        /**
         * #property
         */
        filterBy: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.model({
            flagInclude: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
            flagExclude: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 1540),
            readName: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
            tagFilter: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.model({ tag: mobx_state_tree_1.types.string, value: mobx_state_tree_1.types.string })),
        }), {}),
    }))
        .volatile(() => ({
        colorTagMap: mobx_1.observable.map({}),
        modificationTagMap: mobx_1.observable.map({}),
        featureUnderMouseVolatile: undefined,
        currSortBpPerPx: 0,
        ready: false,
    }))
        .actions(self => ({
        /**
         * #action
         */
        setReady(flag) {
            self.ready = flag;
        },
        /**
         * #action
         */
        setCurrSortBpPerPx(n) {
            self.currSortBpPerPx = n;
        },
        /**
         * #action
         */
        setMaxHeight(n) {
            self.trackMaxHeight = n;
        },
        /**
         * #action
         */
        setFeatureHeight(n) {
            self.featureHeight = n;
        },
        /**
         * #action
         */
        setNoSpacing(flag) {
            self.noSpacing = flag;
        },
        /**
         * #action
         */
        setColorScheme(colorScheme) {
            self.colorTagMap = mobx_1.observable.map({}); // clear existing mapping
            self.colorBy = (0, mobx_state_tree_1.cast)(colorScheme);
            self.ready = false;
        },
        /**
         * #action
         */
        updateModificationColorMap(uniqueModifications) {
            const colorPalette = ['red', 'blue', 'green', 'orange', 'purple'];
            uniqueModifications.forEach(value => {
                if (!self.modificationTagMap.has(value)) {
                    const totalKeys = [...self.modificationTagMap.keys()].length;
                    const newColor = colorPalette[totalKeys];
                    self.modificationTagMap.set(value, newColor);
                }
            });
        },
        /**
         * #action
         */
        updateColorTagMap(uniqueTag) {
            // pale color scheme
            // https://cran.r-project.org/web/packages/khroma/vignettes/tol.html
            // e.g. "tol_light"
            const colorPalette = [
                '#BBCCEE',
                'pink',
                '#CCDDAA',
                '#EEEEBB',
                '#FFCCCC',
                'lightblue',
                'lightgreen',
                'tan',
                '#CCEEFF',
                'lightsalmon',
            ];
            uniqueTag.forEach(value => {
                if (!self.colorTagMap.has(value)) {
                    const totalKeys = [...self.colorTagMap.keys()].length;
                    const newColor = colorPalette[totalKeys];
                    self.colorTagMap.set(value, newColor);
                }
            });
        },
        /**
         * #action
         */
        setFeatureUnderMouse(feat) {
            self.featureUnderMouseVolatile = feat;
        },
    }))
        .actions(self => ({
        afterAttach() {
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(async () => {
                try {
                    const { rpcManager } = (0, util_1.getSession)(self);
                    const view = (0, util_1.getContainingView)(self);
                    const { sortedBy, colorBy, parentTrack, adapterConfig, rendererType, } = self;
                    if (!view.initialized ||
                        !self.estimatedStatsReady ||
                        self.regionTooLarge) {
                        return;
                    }
                    const { staticBlocks, bpPerPx } = view;
                    // continually generate the vc pairing, set and rerender if any
                    // new values seen
                    if (colorBy === null || colorBy === void 0 ? void 0 : colorBy.tag) {
                        self.updateColorTagMap(await (0, shared_1.getUniqueTagValues)(self, colorBy, staticBlocks));
                    }
                    if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {
                        const adapter = (0, configuration_1.getConf)(parentTrack, ['adapter']);
                        self.updateModificationColorMap(await (0, shared_1.getUniqueModificationValues)(self, adapter, colorBy, staticBlocks));
                    }
                    if (sortedBy) {
                        const { pos, refName, assemblyName } = sortedBy;
                        // render just the sorted region first
                        // @ts-ignore
                        await self.rendererType.renderInClient(rpcManager, {
                            assemblyName,
                            regions: [
                                {
                                    start: pos,
                                    end: pos + 1,
                                    refName,
                                    assemblyName,
                                },
                            ],
                            adapterConfig: adapterConfig,
                            rendererType: rendererType.name,
                            sessionId: (0, tracks_1.getRpcSessionId)(self),
                            layoutId: view.id,
                            timeout: 1000000,
                            ...self.renderProps(),
                        });
                        self.setReady(true);
                        self.setCurrSortBpPerPx(bpPerPx);
                    }
                    else {
                        self.setReady(true);
                    }
                }
                catch (e) {
                    console.error(e);
                    self.setError(e);
                }
            }, { delay: 1000 }));
            // autorun synchronizes featureUnderMouse with featureIdUnderMouse
            // asynchronously. this is needed due to how we do not serialize all
            // features from the BAM/CRAM over the rpc
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(async () => {
                var _a;
                const session = (0, util_1.getSession)(self);
                try {
                    const featureId = self.featureIdUnderMouse;
                    if (((_a = self.featureUnderMouse) === null || _a === void 0 ? void 0 : _a.id()) !== featureId) {
                        if (!featureId) {
                            self.setFeatureUnderMouse(undefined);
                        }
                        else {
                            const sessionId = (0, tracks_1.getRpcSessionId)(self);
                            const view = (0, util_1.getContainingView)(self);
                            const { feature } = (await session.rpcManager.call(sessionId, 'CoreGetFeatureDetails', {
                                featureId,
                                sessionId,
                                layoutId: view.id,
                                rendererType: 'PileupRenderer',
                            }));
                            // check featureIdUnderMouse is still the same as the
                            // feature.id that was returned e.g. that the user hasn't
                            // moused over to a new position during the async operation
                            // above
                            // @ts-ignore
                            if (self.featureIdUnderMouse === feature.uniqueId) {
                                // @ts-ignore
                                self.setFeatureUnderMouse(new util_1.SimpleFeature(feature));
                            }
                        }
                    }
                }
                catch (e) {
                    console.error(e);
                    session.notify(`${e}`, 'error');
                }
            }));
        },
        /**
         * #action
         */
        selectFeature(feature) {
            const session = (0, util_1.getSession)(self);
            if ((0, util_1.isSessionModelWithWidgets)(session)) {
                const featureWidget = session.addWidget('AlignmentsFeatureWidget', 'alignmentFeature', { featureData: feature.toJSON(), view: (0, util_1.getContainingView)(self) });
                session.showWidget(featureWidget);
            }
            session.setSelection(feature);
        },
        /**
         * #action
         */
        clearSelected() {
            self.sortedBy = undefined;
        },
        /**
         * #action
         * uses copy-to-clipboard and generates notification
         */
        copyFeatureToClipboard(feature) {
            const { uniqueId, ...rest } = feature.toJSON();
            const session = (0, util_1.getSession)(self);
            (0, copy_to_clipboard_1.default)(JSON.stringify(rest, null, 4));
            session.notify('Copied to clipboard', 'success');
        },
        /**
         * #action
         */
        toggleSoftClipping() {
            self.showSoftClipping = !self.showSoftClipping;
        },
        /**
         * #action
         */
        toggleMismatchAlpha() {
            self.mismatchAlpha = !self.mismatchAlpha;
        },
        /**
         * #action
         */
        setConfig(configuration) {
            self.configuration = configuration;
        },
        /**
         * #action
         */
        setSortedBy(type, tag) {
            const { centerLineInfo } = (0, util_1.getContainingView)(self);
            if (!centerLineInfo) {
                return;
            }
            const { refName, assemblyName, offset } = centerLineInfo;
            const centerBp = Math.round(offset) + 1;
            if (centerBp < 0 || !refName) {
                return;
            }
            self.sortedBy = {
                type,
                pos: centerBp,
                refName,
                assemblyName,
                tag,
            };
            self.ready = false;
        },
        setFilterBy(filter) {
            self.filterBy = (0, mobx_state_tree_1.cast)(filter);
        },
    }))
        .actions(self => {
        // resets the sort object and refresh whole display on reload
        const superReload = self.reload;
        return {
            /**
             * #action
             */
            reload() {
                self.clearSelected();
                superReload();
            },
        };
    })
        .views(self => ({
        /**
         * #getter
         */
        get maxHeight() {
            const conf = (0, configuration_1.getConf)(self, ['renderers', self.rendererTypeName]) || {};
            return self.trackMaxHeight !== undefined
                ? self.trackMaxHeight
                : conf.maxHeight;
        },
        /**
         * #getter
         */
        get rendererConfig() {
            const configBlob = (0, configuration_1.getConf)(self, ['renderers', self.rendererTypeName]) || {};
            return self.rendererType.configSchema.create({
                ...configBlob,
                height: self.featureHeight,
                noSpacing: self.noSpacing,
                maxHeight: this.maxHeight,
                mismatchAlpha: self.mismatchAlpha,
            }, (0, util_1.getEnv)(self));
        },
        /**
         * #getter
         */
        get featureHeightSetting() {
            return (self.featureHeight || (0, configuration_1.readConfObject)(this.rendererConfig, 'height'));
        },
        /**
         * #getter
         */
        get mismatchAlphaSetting() {
            return self.mismatchAlpha !== undefined
                ? self.mismatchAlpha
                : (0, configuration_1.readConfObject)(this.rendererConfig, 'mismatchAlpha');
        },
        /**
         * #getter
         */
        get featureUnderMouse() {
            return self.featureUnderMouseVolatile;
        },
    }))
        .views(self => {
        const { trackMenuItems: superTrackMenuItems, renderProps: superRenderProps, } = self;
        return {
            /**
             * #getter
             */
            get rendererTypeName() {
                const viewName = (0, configuration_1.getConf)(self, 'defaultRendering');
                const rendererType = rendererTypes.get(viewName);
                if (!rendererType) {
                    throw new Error(`unknown alignments view name ${viewName}`);
                }
                return rendererType;
            },
            /**
             * #method
             */
            contextMenuItems() {
                const feat = self.contextMenuFeature;
                const contextMenuItems = feat
                    ? [
                        {
                            label: 'Open feature details',
                            icon: MenuOpen_1.default,
                            onClick: () => {
                                self.clearFeatureSelection();
                                if (feat) {
                                    self.selectFeature(feat);
                                }
                            },
                        },
                        {
                            label: 'Copy info to clipboard',
                            icon: Icons_1.ContentCopy,
                            onClick: () => {
                                if (feat) {
                                    self.copyFeatureToClipboard(feat);
                                }
                            },
                        },
                    ]
                    : [];
                return contextMenuItems;
            },
            /**
             * #getter
             */
            get DisplayBlurb() {
                return LinearPileupDisplayBlurb_1.default;
            },
            /**
             * #method
             */
            renderProps() {
                const view = (0, util_1.getContainingView)(self);
                const { colorTagMap, modificationTagMap, sortedBy, colorBy, filterBy, rpcDriverName, currSortBpPerPx, ready, } = self;
                const superProps = superRenderProps();
                return {
                    ...superProps,
                    notReady: superProps.notReady ||
                        !ready ||
                        (sortedBy && currSortBpPerPx !== view.bpPerPx),
                    rpcDriverName,
                    displayModel: self,
                    sortedBy,
                    colorBy,
                    filterBy: JSON.parse(JSON.stringify(filterBy)),
                    colorTagMap: Object.fromEntries(colorTagMap.toJSON()),
                    modificationTagMap: Object.fromEntries(modificationTagMap.toJSON()),
                    showSoftClip: self.showSoftClipping,
                    config: self.rendererConfig,
                    async onFeatureClick(_, featureId) {
                        const session = (0, util_1.getSession)(self);
                        const { rpcManager } = session;
                        try {
                            const f = featureId || self.featureIdUnderMouse;
                            if (!f) {
                                self.clearFeatureSelection();
                            }
                            else {
                                const sessionId = (0, tracks_1.getRpcSessionId)(self);
                                const { feature } = (await rpcManager.call(sessionId, 'CoreGetFeatureDetails', {
                                    featureId: f,
                                    sessionId,
                                    layoutId: (0, util_1.getContainingView)(self).id,
                                    rendererType: 'PileupRenderer',
                                }));
                                if (feature) {
                                    // @ts-ignore
                                    self.selectFeature(new util_1.SimpleFeature(feature));
                                }
                            }
                        }
                        catch (e) {
                            console.error(e);
                            session.notify(`${e}`);
                        }
                    },
                    onClick() {
                        self.clearFeatureSelection();
                    },
                    // similar to click but opens a menu with further options
                    async onFeatureContextMenu(_, featureId) {
                        const session = (0, util_1.getSession)(self);
                        const { rpcManager } = session;
                        try {
                            const f = featureId || self.featureIdUnderMouse;
                            if (!f) {
                                self.clearFeatureSelection();
                            }
                            else {
                                const sessionId = (0, tracks_1.getRpcSessionId)(self);
                                const { feature } = (await rpcManager.call(sessionId, 'CoreGetFeatureDetails', {
                                    featureId: f,
                                    sessionId,
                                    layoutId: (0, util_1.getContainingView)(self).id,
                                    rendererType: 'PileupRenderer',
                                }));
                                if (feature) {
                                    self.setContextMenuFeature(new util_1.SimpleFeature(feature));
                                }
                            }
                        }
                        catch (e) {
                            console.error(e);
                            session.notify(`${e}`);
                        }
                    },
                };
            },
            /**
             * #method
             */
            trackMenuItems() {
                return [
                    ...superTrackMenuItems(),
                    {
                        label: 'Show soft clipping',
                        icon: Visibility_1.default,
                        type: 'checkbox',
                        checked: self.showSoftClipping,
                        onClick: () => {
                            self.toggleSoftClipping();
                            // if toggling from off to on, will break sort for this track
                            // so clear it
                            if (self.showSoftClipping) {
                                self.clearSelected();
                            }
                        },
                    },
                    {
                        label: 'Sort by',
                        icon: Sort_1.default,
                        disabled: self.showSoftClipping,
                        subMenu: [
                            ...['Start location', 'Read strand', 'Base pair'].map(option => ({
                                label: option,
                                onClick: () => self.setSortedBy(option),
                            })),
                            {
                                label: 'Sort by tag...',
                                onClick: () => {
                                    (0, util_1.getSession)(self).queueDialog(handleClose => [
                                        SortByTagDlg,
                                        { model: self, handleClose },
                                    ]);
                                },
                            },
                            {
                                label: 'Clear sort',
                                onClick: () => self.clearSelected(),
                            },
                        ],
                    },
                    {
                        label: 'Color scheme',
                        icon: Palette_1.default,
                        subMenu: [
                            {
                                label: 'Normal',
                                onClick: () => self.setColorScheme({ type: 'normal' }),
                            },
                            {
                                label: 'Mapping quality',
                                onClick: () => self.setColorScheme({ type: 'mappingQuality' }),
                            },
                            {
                                label: 'Strand',
                                onClick: () => self.setColorScheme({ type: 'strand' }),
                            },
                            {
                                label: 'Pair orientation',
                                onClick: () => self.setColorScheme({ type: 'pairOrientation' }),
                            },
                            {
                                label: 'Per-base quality',
                                onClick: () => self.setColorScheme({ type: 'perBaseQuality' }),
                            },
                            {
                                label: 'Per-base lettering',
                                onClick: () => self.setColorScheme({ type: 'perBaseLettering' }),
                            },
                            {
                                label: 'Modifications or methylation',
                                onClick: () => {
                                    (0, util_1.getSession)(self).queueDialog(doneCallback => [
                                        ModificationsDlg,
                                        { model: self, handleClose: doneCallback },
                                    ]);
                                },
                            },
                            {
                                label: 'Insert size',
                                onClick: () => self.setColorScheme({ type: 'insertSize' }),
                            },
                            {
                                label: 'Stranded paired-end',
                                onClick: () => self.setColorScheme({ type: 'reverseTemplate' }),
                            },
                            {
                                label: 'Color by tag...',
                                onClick: () => {
                                    (0, util_1.getSession)(self).queueDialog(doneCallback => [
                                        ColorByTagDlg,
                                        { model: self, handleClose: doneCallback },
                                    ]);
                                },
                            },
                        ],
                    },
                    {
                        label: 'Filter by',
                        icon: ClearAll_1.default,
                        onClick: () => {
                            (0, util_1.getSession)(self).queueDialog(doneCallback => [
                                FilterByTagDlg,
                                { model: self, handleClose: doneCallback },
                            ]);
                        },
                    },
                    {
                        label: 'Set feature height',
                        onClick: () => {
                            (0, util_1.getSession)(self).queueDialog(doneCallback => [
                                SetFeatureHeightDlg,
                                { model: self, handleClose: doneCallback },
                            ]);
                        },
                    },
                    {
                        label: 'Set max height',
                        onClick: () => {
                            (0, util_1.getSession)(self).queueDialog(doneCallback => [
                                SetMaxHeightDlg,
                                { model: self, handleClose: doneCallback },
                            ]);
                        },
                    },
                    {
                        label: 'Fade mismatches by quality',
                        type: 'checkbox',
                        checked: self.mismatchAlphaSetting,
                        onClick: () => self.toggleMismatchAlpha(),
                    },
                ];
            },
        };
    });
}
exports.default = stateModelFactory;
//# sourceMappingURL=model.js.map