"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bam_1 = require("@gmod/bam");
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const util_1 = require("@jbrowse/core/util");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const operators_1 = require("rxjs/operators");
// locals
const BamSlightlyLazyFeature_1 = __importDefault(require("./BamSlightlyLazyFeature"));
class BamAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    // derived classes may not use the same configuration so a custom
    // configure method allows derived classes to override this behavior
    async configurePre() {
        const bamLocation = this.getConf('bamLocation');
        const location = this.getConf(['index', 'location']);
        const indexType = this.getConf(['index', 'indexType']);
        const pm = this.pluginManager;
        const csi = indexType === 'CSI';
        const bam = new bam_1.BamFile({
            bamFilehandle: (0, io_1.openLocation)(bamLocation, pm),
            csiFilehandle: csi ? (0, io_1.openLocation)(location, pm) : undefined,
            baiFilehandle: !csi ? (0, io_1.openLocation)(location, pm) : undefined,
            // chunkSizeLimit and fetchSizeLimit are more troublesome than
            // helpful, and have given overly large values on the ultra long
            // nanopore reads even with 500MB limits, so disabled with infinity
            chunkSizeLimit: Infinity,
            fetchSizeLimit: Infinity,
            yieldThreadTime: Infinity,
        });
        const adapterConfig = this.getConf('sequenceAdapter');
        if (adapterConfig && this.getSubAdapter) {
            const { dataAdapter } = await this.getSubAdapter(adapterConfig);
            return {
                bam,
                sequenceAdapter: dataAdapter,
            };
        }
        else {
            return { bam };
        }
    }
    async configure() {
        if (!this.configureP) {
            this.configureP = this.configurePre().catch(e => {
                this.configureP = undefined;
                throw e;
            });
        }
        return this.configureP;
    }
    async getHeader(opts) {
        const { bam } = await this.configure();
        return bam.getHeaderText(opts);
    }
    async setupPre(opts) {
        const { statusCallback = () => { } } = opts || {};
        const { bam } = await this.configure();
        this.samHeader = await (0, util_1.updateStatus)('Downloading index', statusCallback, async () => {
            const samHeader = await bam.getHeader(opts);
            // use the @SQ lines in the header to figure out the
            // mapping between ref ref ID numbers and names
            const idToName = [];
            const nameToId = {};
            samHeader
                .filter(l => l.tag === 'SQ')
                .forEach((sqLine, refId) => {
                sqLine.data.forEach(item => {
                    if (item.tag === 'SN') {
                        // this is the ref name
                        const refName = item.value;
                        nameToId[refName] = refId;
                        idToName[refId] = refName;
                    }
                });
            });
            return { idToName, nameToId };
        });
        return this.samHeader;
    }
    async setup(opts) {
        if (!this.setupP) {
            this.setupP = this.setupPre(opts).catch(e => {
                this.setupP = undefined;
                throw e;
            });
        }
        return this.setupP;
    }
    async getRefNames(opts) {
        const { idToName } = await this.setup(opts);
        return idToName;
    }
    async seqFetch(refName, start, end) {
        const { sequenceAdapter } = await this.configure();
        const refSeqStore = sequenceAdapter;
        if (!refSeqStore) {
            return undefined;
        }
        if (!refName) {
            return undefined;
        }
        const features = refSeqStore.getFeatures({
            refName,
            start,
            end,
            assemblyName: '',
        });
        const seqChunks = await features.pipe((0, operators_1.toArray)()).toPromise();
        let sequence = '';
        seqChunks
            .sort((a, b) => a.get('start') - b.get('start'))
            .forEach(chunk => {
            const chunkStart = chunk.get('start');
            const chunkEnd = chunk.get('end');
            const trimStart = Math.max(start - chunkStart, 0);
            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);
            const trimLength = trimEnd - trimStart;
            const chunkSeq = chunk.get('seq') || chunk.get('residues');
            sequence += chunkSeq.substr(trimStart, trimLength);
        });
        if (sequence.length !== end - start) {
            throw new Error(`sequence fetch failed: fetching ${refName}:${(start - 1).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(end - start).toLocaleString()}`);
        }
        return sequence;
    }
    getFeatures(region, opts) {
        const { refName, start, end, originalRefName } = region;
        const { signal, filterBy, statusCallback = () => { } } = opts || {};
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const { bam } = await this.configure();
            await this.setup(opts);
            statusCallback('Downloading alignments');
            const records = await bam.getRecordsForRange(refName, start, end, opts);
            const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};
            for (const record of records) {
                let ref;
                if (!record.get('MD')) {
                    ref = await this.seqFetch(originalRefName || refName, record.get('start'), record.get('end'));
                }
                const flags = record.flags;
                if (!((flags & flagInclude) === flagInclude && !(flags & flagExclude))) {
                    continue;
                }
                if (tagFilter) {
                    const val = record.get(tagFilter.tag);
                    if (!(val === '*' ? val !== undefined : val === tagFilter.value)) {
                        continue;
                    }
                }
                if (readName && record.get('name') !== readName) {
                    continue;
                }
                observer.next(new BamSlightlyLazyFeature_1.default(record, this, ref));
            }
            statusCallback('');
            observer.complete();
        }, signal);
    }
    async estimateRegionsStats(regions, opts) {
        const { bam } = await this.configure();
        // this is a method to avoid calling on htsget adapters
        // @ts-ignore
        if (bam.index.filehandle !== '?') {
            const bytes = await (0, util_1.bytesForRegions)(regions, bam);
            const fetchSizeLimit = this.getConf('fetchSizeLimit');
            return { bytes, fetchSizeLimit };
        }
        else {
            return super.estimateRegionsStats(regions, opts);
        }
    }
    freeResources( /* { region } */) { }
    // depends on setup being called before the BAM constructor
    refIdToName(refId) {
        var _a;
        return (_a = this.samHeader) === null || _a === void 0 ? void 0 : _a.idToName[refId];
    }
}
exports.default = BamAdapter;
//# sourceMappingURL=BamAdapter.js.map