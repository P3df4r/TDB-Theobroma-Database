"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PileupGetVisibleModifications = exports.PileupGetGlobalValueForTag = void 0;
const RpcMethodType_1 = __importDefault(require("@jbrowse/core/pluggableElementTypes/RpcMethodType"));
const dataAdapterCache_1 = require("@jbrowse/core/data_adapters/dataAdapterCache");
const util_1 = require("@jbrowse/core/util");
const operators_1 = require("rxjs/operators");
// locals
const util_2 = require("../util");
const MismatchParser_1 = require("../BamAdapter/MismatchParser");
class PileupGetGlobalValueForTag extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'PileupGetGlobalValueForTag';
    }
    async serializeArguments(args, rpcDriverClassName) {
        var _a;
        const { rootModel } = this.pluginManager;
        const assemblyManager = (_a = rootModel === null || rootModel === void 0 ? void 0 : rootModel.session) === null || _a === void 0 ? void 0 : _a.assemblyManager;
        if (!assemblyManager) {
            throw new Error('no assembly manager available');
        }
        const renamedArgs = await (0, util_1.renameRegionsIfNeeded)(assemblyManager, args);
        return super.serializeArguments(renamedArgs, rpcDriverClassName);
    }
    async execute(args, rpcDriverClassName) {
        const pm = this.pluginManager;
        const deArgs = await this.deserializeArguments(args, rpcDriverClassName);
        const { adapterConfig, sessionId, regions, tag } = deArgs;
        const dataAdapter = (await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig))
            .dataAdapter;
        const features = dataAdapter.getFeaturesInMultipleRegions(regions);
        const featuresArray = await features.pipe((0, operators_1.toArray)()).toPromise();
        const uniqueValues = new Set();
        featuresArray.forEach(feature => {
            const tags = feature.get('tags');
            const val = tags ? tags[tag] : feature.get(tag);
            if (val !== undefined) {
                uniqueValues.add(`${val}`);
            }
        });
        return [...uniqueValues];
    }
}
exports.PileupGetGlobalValueForTag = PileupGetGlobalValueForTag;
class PileupGetVisibleModifications extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'PileupGetVisibleModifications';
    }
    async serializeArguments(args, rpcDriverClassName) {
        var _a;
        const { rootModel } = this.pluginManager;
        const assemblyManager = (_a = rootModel === null || rootModel === void 0 ? void 0 : rootModel.session) === null || _a === void 0 ? void 0 : _a.assemblyManager;
        if (!assemblyManager) {
            throw new Error('no assembly manager available');
        }
        const renamedArgs = await (0, util_1.renameRegionsIfNeeded)(assemblyManager, args);
        return super.serializeArguments(renamedArgs, rpcDriverClassName);
    }
    async execute(args, rpcDriverClassName) {
        const pm = this.pluginManager;
        const deArgs = await this.deserializeArguments(args, rpcDriverClassName);
        const { adapterConfig, sessionId, regions } = deArgs;
        const dataAdapter = (await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig))
            .dataAdapter;
        const features = dataAdapter.getFeaturesInMultipleRegions(regions);
        const featuresArray = await features.pipe((0, operators_1.toArray)()).toPromise();
        const uniqueValues = new Set();
        featuresArray.forEach(feature => {
            const val = (0, util_2.getTagAlt)(feature, 'MM', 'Mm') || '';
            if (val !== undefined) {
                (0, MismatchParser_1.getModificationTypes)(val).forEach(t => uniqueValues.add(t));
            }
        });
        return [...uniqueValues];
    }
}
exports.PileupGetVisibleModifications = PileupGetVisibleModifications;
//# sourceMappingURL=rpcMethods.js.map