"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const configuration_1 = require("@jbrowse/core/configuration");
const models_1 = require("@jbrowse/core/pluggableElementTypes/models");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const util_1 = require("@jbrowse/core/util");
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const minDisplayHeight = 20;
/**
 * #stateModel LinearAlignmentsDisplay
 * extends `BaseDisplay`
 */
function stateModelFactory(pluginManager, configSchema) {
    return mobx_state_tree_1.types
        .compose('LinearAlignmentsDisplay', models_1.BaseDisplay, mobx_state_tree_1.types.model({
        /**
         * #property
         * refers to LinearPileupDisplay sub-display model
         */
        PileupDisplay: mobx_state_tree_1.types.maybe(pluginManager.getDisplayType('LinearPileupDisplay').stateModel),
        /**
         * #property
         * refers to LinearSNPCoverageDisplay sub-display model
         */
        SNPCoverageDisplay: mobx_state_tree_1.types.maybe(pluginManager.getDisplayType('LinearSNPCoverageDisplay').stateModel),
        /**
         * #property
         */
        snpCovHeight: 45,
        /**
         * #property
         */
        type: mobx_state_tree_1.types.literal('LinearAlignmentsDisplay'),
        /**
         * #property
         */
        configuration: (0, configuration_1.ConfigurationReference)(configSchema),
        /**
         * #property
         */
        height: 250,
        /**
         * #property
         */
        showCoverage: true,
        /**
         * #property
         */
        showPileup: true,
        /**
         * #property
         */
        userFeatureScreenDensity: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
    }))
        .volatile(() => ({
        scrollTop: 0,
    }))
        .actions(self => ({
        /**
         * #action
         */
        toggleCoverage() {
            self.showCoverage = !self.showCoverage;
        },
        /**
         * #action
         */
        togglePileup() {
            self.showPileup = !self.showPileup;
        },
        /**
         * #action
         */
        setScrollTop(scrollTop) {
            self.scrollTop = scrollTop;
        },
        /**
         * #action
         */
        setSNPCoverageHeight(n) {
            self.snpCovHeight = n;
        },
    }))
        .views(self => {
        const { trackMenuItems: superTrackMenuItems } = self;
        return {
            /**
             * #getter
             */
            get pileupDisplayConfig() {
                const conf = (0, configuration_1.getConf)(self, 'pileupDisplay');
                const track = (0, util_1.getContainingTrack)(self);
                return {
                    ...conf,
                    type: 'LinearPileupDisplay',
                    name: `${(0, configuration_1.getConf)(track, 'name')} pileup`,
                    displayId: `${self.configuration.displayId}_pileup_xyz`, // xyz to avoid someone accidentally naming the displayId similar to this
                };
            },
            /**
             * #method
             */
            getFeatureByID(blockKey, id) {
                return self.PileupDisplay.getFeatureByID(blockKey, id);
            },
            /**
             * #method
             */
            searchFeatureByID(id) {
                return self.PileupDisplay.searchFeatureByID(id);
            },
            /**
             * #getter
             */
            get features() {
                return self.PileupDisplay.features;
            },
            /**
             * #getter
             */
            get DisplayBlurb() {
                var _a;
                return (_a = self.PileupDisplay) === null || _a === void 0 ? void 0 : _a.DisplayBlurb;
            },
            /**
             * #getter
             */
            get sortedBy() {
                return self.PileupDisplay.sortedBy;
            },
            /**
             * #getter
             */
            get sortedByPosition() {
                return self.PileupDisplay.sortedByPosition;
            },
            /**
             * #getter
             */
            get sortedByRefName() {
                return self.PileupDisplay.sortedByRefName;
            },
            /**
             * #getter
             */
            get snpCoverageDisplayConfig() {
                const conf = (0, configuration_1.getConf)(self, 'snpCoverageDisplay');
                const track = (0, util_1.getContainingTrack)(self);
                return {
                    ...conf,
                    type: 'LinearSNPCoverageDisplay',
                    name: `${(0, configuration_1.getConf)(track, 'name')} snp coverage`,
                    displayId: `${self.configuration.displayId}_snpcoverage_xyz`, // xyz to avoid someone accidentally naming the displayId similar to this
                };
            },
            /**
             * #method
             */
            trackMenuItems() {
                return [
                    ...superTrackMenuItems(),
                    {
                        type: 'subMenu',
                        label: 'Pileup settings',
                        subMenu: self.PileupDisplay.trackMenuItems(),
                    },
                    {
                        type: 'subMenu',
                        label: 'SNPCoverage settings',
                        subMenu: self.SNPCoverageDisplay.trackMenuItems(),
                    },
                ];
            },
        };
    })
        .actions(self => ({
        /**
         * #action
         */
        setSNPCoverageDisplay(configuration) {
            self.SNPCoverageDisplay = {
                type: 'LinearSNPCoverageDisplay',
                configuration,
                height: self.snpCovHeight,
            };
        },
        /**
         * #action
         */
        updateStatsLimit(stats) {
            self.PileupDisplay.updateStatsLimit(stats);
            self.SNPCoverageDisplay.updateStatsLimit(stats);
        },
        /**
         * #action
         */
        setPileupDisplay(configuration) {
            self.PileupDisplay = {
                type: 'LinearPileupDisplay',
                configuration,
            };
        },
        /**
         * #action
         */
        setHeight(displayHeight) {
            if (displayHeight > minDisplayHeight) {
                self.height = displayHeight;
            }
            else {
                self.height = minDisplayHeight;
            }
            return self.height;
        },
        /**
         * #action
         */
        resizeHeight(distance) {
            const oldHeight = self.height;
            const newHeight = this.setHeight(self.height + distance);
            return newHeight - oldHeight;
        },
    }))
        .actions(self => ({
        afterAttach() {
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(() => {
                if (!self.SNPCoverageDisplay) {
                    self.setSNPCoverageDisplay(self.snpCoverageDisplayConfig);
                }
                else if (!(0, fast_deep_equal_1.default)(self.snpCoverageDisplayConfig, (0, mobx_state_tree_1.getSnapshot)(self.SNPCoverageDisplay.configuration))) {
                    self.SNPCoverageDisplay.setHeight(self.snpCovHeight);
                    self.SNPCoverageDisplay.setConfig(self.snpCoverageDisplayConfig);
                }
                if (!self.PileupDisplay) {
                    self.setPileupDisplay(self.pileupDisplayConfig);
                }
                else if (!(0, fast_deep_equal_1.default)(self.pileupDisplayConfig, (0, mobx_state_tree_1.getSnapshot)(self.PileupDisplay.configuration))) {
                    self.PileupDisplay.setConfig(self.pileupDisplayConfig);
                }
                // propagate the filterBy setting from pileupdisplay to snpcoverage
                // note: the snpcoverage display is not able to control filterBy
                // itself
                if (self.PileupDisplay.filterBy &&
                    !(0, fast_deep_equal_1.default)((0, mobx_state_tree_1.getSnapshot)(self.PileupDisplay.filterBy), (0, mobx_state_tree_1.getSnapshot)(self.SNPCoverageDisplay.filterBy))) {
                    self.SNPCoverageDisplay.setFilterBy((0, mobx_state_tree_1.getSnapshot)(self.PileupDisplay.filterBy));
                }
                if (self.PileupDisplay.colorBy &&
                    !(0, fast_deep_equal_1.default)((0, mobx_state_tree_1.getSnapshot)(self.PileupDisplay.colorBy), self.SNPCoverageDisplay.colorBy
                        ? (0, mobx_state_tree_1.getSnapshot)(self.SNPCoverageDisplay.colorBy)
                        : {})) {
                    self.SNPCoverageDisplay.setColorBy((0, mobx_state_tree_1.getSnapshot)(self.PileupDisplay.colorBy));
                }
            }));
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(() => {
                self.setSNPCoverageHeight(self.SNPCoverageDisplay.height);
            }));
        },
        /**
         * #action
         */
        async renderSvg(opts) {
            const pileupHeight = self.height - self.SNPCoverageDisplay.height;
            await (0, mobx_1.when)(() => self.PileupDisplay.ready);
            return (react_1.default.createElement(react_1.default.Fragment, null,
                react_1.default.createElement("g", null, await self.SNPCoverageDisplay.renderSvg(opts)),
                react_1.default.createElement("g", { transform: `translate(0 ${self.SNPCoverageDisplay.height})` }, await self.PileupDisplay.renderSvg({
                    ...opts,
                    overrideHeight: pileupHeight,
                }))));
        },
    }));
}
exports.default = stateModelFactory;
//# sourceMappingURL=model.js.map