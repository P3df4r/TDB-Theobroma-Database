"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cram_1 = require("@gmod/cram");
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const util_1 = require("@jbrowse/core/util");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const operators_1 = require("rxjs/operators");
const CramSlightlyLazyFeature_1 = __importDefault(require("./CramSlightlyLazyFeature"));
class CramAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    constructor() {
        super(...arguments);
        this.samHeader = {};
        // maps a seqId to original refname, passed specially to render args, to a seqid
        this.seqIdToOriginalRefName = [];
    }
    async configurePre() {
        const cramLocation = this.getConf('cramLocation');
        const craiLocation = this.getConf('craiLocation');
        if (!cramLocation) {
            throw new Error('missing cramLocation argument');
        }
        if (!craiLocation) {
            throw new Error('missing craiLocation argument');
        }
        const pm = this.pluginManager;
        const cram = new cram_1.IndexedCramFile({
            cramFilehandle: (0, io_1.openLocation)(cramLocation, pm),
            index: new cram_1.CraiIndex({ filehandle: (0, io_1.openLocation)(craiLocation, pm) }),
            seqFetch: (...args) => this.seqFetch(...args),
            checkSequenceMD5: false,
            fetchSizeLimit: 200000000, // just make this a large size to avoid hitting it
        });
        if (!this.getSubAdapter) {
            throw new Error('Error getting subadapter');
        }
        const seqConf = this.getConf('sequenceAdapter');
        const subadapter = await this.getSubAdapter(seqConf);
        return {
            cram,
            sequenceAdapter: subadapter.dataAdapter,
        };
    }
    async configure() {
        if (!this.configureP) {
            this.configureP = this.configurePre().catch(e => {
                this.configureP = undefined;
                throw e;
            });
        }
        return this.configureP;
    }
    async getHeader(opts) {
        const { cram } = await this.configure();
        return cram.cram.getHeaderText();
    }
    async seqFetch(seqId, start, end) {
        start -= 1; // convert from 1-based closed to interbase
        const { sequenceAdapter } = await this.configure();
        const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId);
        if (!refName) {
            throw new Error('unknown');
        }
        const seqChunks = await sequenceAdapter
            .getFeatures({
            refName,
            start,
            end,
            assemblyName: '',
        })
            .pipe((0, operators_1.toArray)())
            .toPromise();
        const sequence = seqChunks
            .sort((a, b) => a.get('start') - b.get('start'))
            .map(chunk => {
            const chunkStart = chunk.get('start');
            const chunkEnd = chunk.get('end');
            const trimStart = Math.max(start - chunkStart, 0);
            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);
            const trimLength = trimEnd - trimStart;
            const chunkSeq = chunk.get('seq') || chunk.get('residues');
            return chunkSeq.substr(trimStart, trimLength);
        })
            .join('');
        if (sequence.length !== end - start) {
            throw new Error(`sequence fetch failed: fetching ${refName}:${(start - 1).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(end - start).toLocaleString()}`);
        }
        return sequence;
    }
    async setupPre(opts) {
        const { statusCallback = () => { } } = opts || {};
        const conf = await this.configure();
        statusCallback('Downloading index');
        const { cram } = conf;
        const samHeader = await cram.cram.getSamHeader();
        // use the @SQ lines in the header to figure out the
        // mapping between ref ID numbers and names
        const idToName = [];
        const nameToId = {};
        samHeader
            .filter(l => l.tag === 'SQ')
            .forEach((sqLine, refId) => {
            sqLine.data.forEach(item => {
                if (item.tag === 'SN') {
                    // this is the ref name
                    const refName = item.value;
                    nameToId[refName] = refId;
                    idToName[refId] = refName;
                }
            });
        });
        const readGroups = samHeader
            .filter(l => l.tag === 'RG')
            .map(rgLine => { var _a; return (_a = rgLine.data.find(item => item.tag === 'ID')) === null || _a === void 0 ? void 0 : _a.value; });
        const data = { idToName, nameToId, readGroups };
        statusCallback('');
        this.samHeader = data;
        return { samHeader: data, ...conf };
    }
    async setup(opts) {
        if (!this.setupP) {
            this.setupP = this.setupPre(opts).catch(e => {
                this.setupP = undefined;
                throw e;
            });
        }
        return this.setupP;
    }
    async getRefNames(opts) {
        const { samHeader } = await this.setup(opts);
        if (!samHeader.idToName) {
            throw new Error('CRAM file has no header lines');
        }
        return samHeader.idToName;
    }
    // use info from the SAM header if possible, but fall back to using
    // the ref seq order from when the browser's refseqs were loaded
    refNameToId(refName) {
        if (this.samHeader.nameToId) {
            return this.samHeader.nameToId[refName];
        }
        if (this.seqIdToRefName) {
            return this.seqIdToRefName.indexOf(refName);
        }
        return undefined;
    }
    // use info from the SAM header if possible, but fall back to using
    // the ref seq order from when the browser's refseqs were loaded
    refIdToName(refId) {
        var _a, _b;
        return ((_a = this.samHeader.idToName) === null || _a === void 0 ? void 0 : _a[refId]) || ((_b = this.seqIdToRefName) === null || _b === void 0 ? void 0 : _b[refId]);
    }
    refIdToOriginalName(refId) {
        return this.seqIdToOriginalRefName[refId];
    }
    getFeatures(region, opts) {
        const { signal, filterBy, statusCallback = () => { } } = opts || {};
        const { refName, start, end, originalRefName } = region;
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const { cram } = await this.setup(opts);
            const refId = this.refNameToId(refName);
            if (refId === undefined) {
                console.warn('Unknown refName', refName);
                observer.complete();
                return;
            }
            if (originalRefName) {
                this.seqIdToOriginalRefName[refId] = originalRefName;
            }
            statusCallback('Downloading alignments');
            const records = await cram.getRecordsForRange(refId, start, end);
            (0, util_1.checkAbortSignal)(signal);
            const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};
            let filtered = records.filter(record => {
                const flags = record.flags;
                return (flags & flagInclude) === flagInclude && !(flags & flagExclude);
            });
            if (tagFilter) {
                filtered = filtered.filter(record => {
                    // @ts-ignore
                    const val = record[tagFilter.tag];
                    return val === '*' ? val !== undefined : val === tagFilter.value;
                });
            }
            if (readName) {
                filtered = filtered.filter(record => record.readName === readName);
            }
            filtered.forEach(record => {
                observer.next(this.cramRecordToFeature(record));
            });
            statusCallback('');
            observer.complete();
        }, signal);
    }
    freeResources( /* { region } */) { }
    cramRecordToFeature(record) {
        return new CramSlightlyLazyFeature_1.default(record, this);
    }
    // we return the configured fetchSizeLimit, and the bytes for the region
    async estimateRegionsStats(regions, opts) {
        const bytes = await this.bytesForRegions(regions, opts);
        const fetchSizeLimit = this.getConf('fetchSizeLimit');
        return {
            bytes,
            fetchSizeLimit,
        };
    }
    /**
     * get the approximate number of bytes queried from the file for the given
     * query regions
     * @param regions - list of query regions
     */
    async bytesForRegions(regions, _opts) {
        const { cram } = await this.configure();
        const blockResults = await Promise.all(regions.map(region => {
            const { refName, start, end } = region;
            const chrId = this.refNameToId(refName);
            return chrId !== undefined
                ? cram.index.getEntriesForRange(chrId, start, end)
                : [{ sliceBytes: 0 }];
        }));
        return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0);
    }
}
exports.default = CramAdapter;
//# sourceMappingURL=CramAdapter.js.map