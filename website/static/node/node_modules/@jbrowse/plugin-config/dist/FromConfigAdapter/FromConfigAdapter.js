"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const simpleFeature_1 = __importDefault(require("@jbrowse/core/util/simpleFeature"));
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const configuration_1 = require("@jbrowse/core/configuration");
/**
 * Adapter that just returns the features defined in its `features` configuration
 * key, like:
 *   `"features": [ { "refName": "ctgA", "start":1, "end":20 }, ... ]`
 */
class FromConfigAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    constructor(conf, getSubAdapter, pluginManager) {
        super(conf, getSubAdapter, pluginManager);
        const feats = (0, configuration_1.readConfObject)(conf, 'features');
        this.features = FromConfigAdapter.makeFeatures(feats || []);
    }
    static makeFeatures(fdata) {
        const features = new Map();
        for (let i = 0; i < fdata.length; i += 1) {
            if (fdata[i]) {
                const f = this.makeFeature(fdata[i]);
                const refName = f.get('refName');
                let bucket = features.get(refName);
                if (!bucket) {
                    bucket = [];
                    features.set(refName, bucket);
                }
                bucket.push(f);
            }
        }
        // sort the features on each reference sequence by start coordinate
        for (const refFeatures of features.values()) {
            refFeatures.sort((a, b) => a.get('start') - b.get('start'));
        }
        return features;
    }
    static makeFeature(data) {
        return new simpleFeature_1.default(data);
    }
    async getRefNames() {
        return [...this.features.keys()];
    }
    async getRefNameAliases() {
        return Array.from(this.features.values()).map(featureArray => ({
            refName: featureArray[0].get('refName'),
            aliases: featureArray[0].get('aliases'),
        }));
    }
    getFeatures(region) {
        const { refName, start, end } = region;
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const features = this.features.get(refName) || [];
            for (let i = 0; i < features.length; i++) {
                const f = features[i];
                if (f.get('end') > start && f.get('start') < end) {
                    observer.next(f);
                }
            }
            observer.complete();
        });
    }
    freeResources( /* { region } */) { }
}
exports.default = FromConfigAdapter;
//# sourceMappingURL=FromConfigAdapter.js.map