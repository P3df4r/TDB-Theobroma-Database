"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const configuration_1 = require("@jbrowse/core/configuration");
const material_1 = require("@mui/material");
const mui_1 = require("tss-react/mui");
const mobx_react_1 = require("mobx-react");
const mobx_state_tree_1 = require("mobx-state-tree");
const pluralize_1 = require("pluralize");
// icons
const ExpandMore_1 = __importDefault(require("@mui/icons-material/ExpandMore"));
// locals
const SlotEditor_1 = __importDefault(require("./SlotEditor"));
const TypeSelector_1 = __importDefault(require("./TypeSelector"));
const useStyles = (0, mui_1.makeStyles)()(theme => ({
    expandIcon: {
        color: '#fff',
    },
    root: {
        padding: theme.spacing(1, 3, 1, 1),
    },
    expansionPanelDetails: {
        display: 'block',
        padding: theme.spacing(1),
    },
    accordion: {
        border: `1px solid ${theme.palette.text.primary}`,
    },
    noOverflow: {
        width: '100%',
        overflowX: 'auto',
    },
}));
const Member = (0, mobx_react_1.observer)((props) => {
    const { classes } = useStyles();
    const { slotName, slotSchema, schema, slot = schema[slotName], path = [], } = props;
    let typeSelector;
    if ((0, configuration_1.isConfigurationSchemaType)(slotSchema)) {
        if (slot.length) {
            return slot.map((subslot, slotIndex) => {
                const key = `${(0, pluralize_1.singular)(slotName)} ${slotIndex + 1}`;
                return react_1.default.createElement(Member, { ...props, key: key, slot: subslot, slotName: key });
            });
        }
        // if this is an explicitly typed schema, make a type-selecting dropdown
        // that can be used to change its type
        const typeNameChoices = (0, configuration_1.getTypeNamesFromExplicitlyTypedUnion)(slotSchema);
        if (typeNameChoices.length) {
            typeSelector = (react_1.default.createElement(TypeSelector_1.default, { typeNameChoices: typeNameChoices, slotName: slotName, slot: slot, onChange: evt => {
                    if (evt.target.value !== slot.type) {
                        schema.setSubschema(slotName, { type: evt.target.value });
                    }
                } }));
        }
        return (react_1.default.createElement(material_1.Accordion, { defaultExpanded: true, className: classes.accordion },
            react_1.default.createElement(material_1.AccordionSummary, { expandIcon: react_1.default.createElement(ExpandMore_1.default, { className: classes.expandIcon }) },
                react_1.default.createElement(material_1.Typography, null, [...path, slotName].join('âž”'))),
            react_1.default.createElement(material_1.AccordionDetails, { className: classes.expansionPanelDetails },
                typeSelector,
                react_1.default.createElement(material_1.FormGroup, { className: classes.noOverflow },
                    react_1.default.createElement(Schema, { schema: slot, path: [...path, slotName] })))));
    }
    if ((0, configuration_1.isConfigurationSlotType)(slotSchema)) {
        // this is a regular config slot
        return react_1.default.createElement(SlotEditor_1.default, { key: slotName, slot: slot, slotSchema: slotSchema });
    }
    return null;
});
const Schema = (0, mobx_react_1.observer)(({ schema, path = [], }) => {
    const properties = (0, mobx_state_tree_1.getMembers)(schema).properties;
    return (react_1.default.createElement(react_1.default.Fragment, null, Object.entries(properties).map(([slotName, slotSchema]) => (react_1.default.createElement(Member, { key: slotName, slotName: slotName, slotSchema: slotSchema, path: path, schema: schema })))));
});
const ConfigurationEditor = (0, mobx_react_1.observer)(({ model, }) => {
    const { classes } = useStyles();
    // key forces a re-render, otherwise the same field can end up being used
    // for different tracks since only the backing model changes for example
    // see pr #804
    const { target } = model;
    const key = target && (0, configuration_1.readConfObject)(target, 'trackId');
    const name = target && (0, configuration_1.readConfObject)(target, 'name');
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(material_1.Accordion, { key: key, defaultExpanded: true, className: classes.accordion },
            react_1.default.createElement(material_1.AccordionSummary, { expandIcon: react_1.default.createElement(ExpandMore_1.default, { className: classes.expandIcon }) },
                react_1.default.createElement(material_1.Typography, null, name !== null && name !== void 0 ? name : 'Configuration')),
            react_1.default.createElement(material_1.AccordionDetails, { className: classes.expansionPanelDetails, "data-testid": "configEditor" }, !target ? 'no target set' : react_1.default.createElement(Schema, { schema: target }))),
        react_1.default.createElement("div", { style: { height: 300 } })));
});
exports.default = ConfigurationEditor;
//# sourceMappingURL=ConfigurationEditor.js.map