import React, { useEffect, useState } from 'react';
import { observer } from 'mobx-react';
import { getPropertyMembers } from 'mobx-state-tree';
import { getEnv } from '@jbrowse/core/util';
import { FileSelector, SanitizedHTML } from '@jbrowse/core/ui';
import { getPropertyType, getSubType, getUnionSubTypes, } from '@jbrowse/core/util/mst-reflection';
import { Card, CardContent, CardHeader, Checkbox, FormControl, FormControlLabel, FormHelperText, IconButton, InputAdornment, InputLabel, MenuItem, Paper, SvgIcon, TextField, } from '@mui/material';
import { makeStyles } from 'tss-react/mui';
// icons
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import RadioButtonUncheckedIcon from '@mui/icons-material/RadioButtonUnchecked';
// locals
import StringArrayEditor from './StringArrayEditor';
import CallbackEditor from './CallbackEditor';
import ColorEditor from './ColorEditor';
import JsonEditor from './JsonEditor';
// adds ability to have html in helperText. note that FormHelperTextProps is
// div because the default is p which does not like div children
function MyTextField(props) {
    const { helperText } = props;
    return (React.createElement(TextField, { ...props, helperText: React.createElement(SanitizedHTML, { html: helperText || '' }), FormHelperTextProps: {
            // @ts-ignore
            component: 'div',
        }, fullWidth: true }));
}
const StringEditor = observer(({ slot, }) => (React.createElement(MyTextField, { label: slot.name, helperText: slot.description, value: slot.value, onChange: evt => slot.set(evt.target.value) })));
const TextEditor = observer(({ slot, }) => (React.createElement(TextField, { label: slot.name, helperText: slot.description, multiline: true, value: slot.value, onChange: evt => slot.set(evt.target.value) })));
// checked checkbox, looks like a styled (x)
const SvgCheckbox = () => (React.createElement(SvgIcon, null,
    React.createElement("path", { d: "M20.41,3C21.8,5.71 22.35,8.84 22,12C21.8,15.16 20.7,18.29 18.83,21L17.3,20C18.91,17.57 19.85,14.8 20,12C20.34,9.2 19.89,6.43 18.7,4L20.41,3M5.17,3L6.7,4C5.09,6.43 4.15,9.2 4,12C3.66,14.8 4.12,17.57 5.3,20L3.61,21C2.21,18.29 1.65,15.17 2,12C2.2,8.84 3.3,5.71 5.17,3M12.08,10.68L14.4,7.45H16.93L13.15,12.45L15.35,17.37H13.09L11.71,14L9.28,17.33H6.76L10.66,12.21L8.53,7.45H10.8L12.08,10.68Z" })));
const useMapEditorStyles = makeStyles()(theme => ({
    card: {
        marginTop: theme.spacing(1),
    },
}));
const StringArrayMapEditor = observer(({ slot, }) => {
    const { classes } = useMapEditorStyles();
    const [value, setValue] = useState('');
    return (React.createElement(React.Fragment, null,
        React.createElement(InputLabel, null, slot.name),
        Array.from(slot.value, ([key, val]) => (React.createElement(Card, { raised: true, key: key, className: classes.card },
            React.createElement(CardHeader, { title: key, action: React.createElement(IconButton, { color: "secondary", onClick: () => slot.remove(key) },
                    React.createElement(DeleteIcon, null)) }),
            React.createElement(CardContent, null,
                React.createElement(StringArrayEditor, { slot: {
                        name: slot.name,
                        value: val,
                        description: `Values associated with entry ${key}`,
                        setAtIndex: (idx, val) => slot.setAtKeyIndex(key, idx, val),
                        removeAtIndex: (idx) => slot.removeAtKeyIndex(key, idx),
                        add: (val) => slot.addToKey(key, val),
                    } }))))),
        React.createElement(Card, { raised: true, className: classes.card },
            React.createElement(CardHeader, { disableTypography: true, title: React.createElement(TextField, { fullWidth: true, value: value, placeholder: "add new", onChange: event => setValue(event.target.value), InputProps: {
                        endAdornment: (React.createElement(InputAdornment, { position: "end" },
                            React.createElement(IconButton, { disabled: value === '', onClick: () => {
                                    slot.add(value, []);
                                    setValue('');
                                }, color: "secondary" },
                                React.createElement(AddIcon, null)))),
                    } }) })),
        React.createElement(FormHelperText, null, slot.description)));
});
const NumberMapEditor = observer(({ slot, }) => {
    const { classes } = useMapEditorStyles();
    const [value, setValue] = useState('');
    return (React.createElement(React.Fragment, null,
        React.createElement(InputLabel, null, slot.name),
        Array.from(slot.value, ([key, val]) => (React.createElement(Card, { raised: true, key: key, className: classes.card },
            React.createElement(CardHeader, { title: key, action: React.createElement(IconButton, { color: "secondary", onClick: () => slot.remove(key) },
                    React.createElement(DeleteIcon, null)) }),
            React.createElement(CardContent, null,
                React.createElement(NumberEditor, { slot: {
                        value: val,
                        set: (val) => slot.add(key, val),
                    } }))))),
        React.createElement(Card, { raised: true, className: classes.card },
            React.createElement(CardHeader, { disableTypography: true, title: React.createElement(TextField, { fullWidth: true, value: value, placeholder: "add new", onChange: event => setValue(event.target.value), InputProps: {
                        endAdornment: (React.createElement(InputAdornment, { position: "end" },
                            React.createElement(IconButton, { disabled: value === '', onClick: () => {
                                    slot.add(value, 0);
                                    setValue('');
                                }, color: "secondary" },
                                React.createElement(AddIcon, null)))),
                    } }) })),
        React.createElement(FormHelperText, null, slot.description)));
});
const NumberEditor = observer(({ slot, }) => {
    const [val, setVal] = useState(slot.value);
    useEffect(() => {
        var _a;
        const num = parseFloat(val);
        if (!Number.isNaN(num)) {
            slot.set(num);
        }
        else {
            (_a = slot.reset) === null || _a === void 0 ? void 0 : _a.call(slot);
        }
    }, [slot, val]);
    return (React.createElement(MyTextField, { label: slot.name, helperText: slot.description, value: val, type: "number", onChange: evt => setVal(evt.target.value) }));
});
const IntegerEditor = observer(({ slot, }) => {
    const [val, setVal] = useState(slot.value);
    useEffect(() => {
        const num = parseInt(val, 10);
        if (!Number.isNaN(num)) {
            slot.set(num);
        }
    }, [slot, val]);
    return (React.createElement(MyTextField, { label: slot.name, helperText: slot.description, value: val, type: "number", onChange: evt => setVal(evt.target.value) }));
});
const BooleanEditor = observer(({ slot, }) => (React.createElement(FormControl, null,
    React.createElement(FormControlLabel, { label: slot.name, control: React.createElement(Checkbox, { checked: slot.value, onChange: evt => slot.set(evt.target.checked) }) }),
    React.createElement(FormHelperText, null, slot.description))));
const StringEnumEditor = observer(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
({ slot, slotSchema }) => {
    const p = getPropertyMembers(getSubType(slotSchema));
    const choices = getUnionSubTypes(getUnionSubTypes(getSubType(getPropertyType(p, 'value')))[1]).map(t => t.value);
    return (React.createElement(MyTextField, { value: slot.value, label: slot.name, select: true, helperText: slot.description, onChange: evt => slot.set(evt.target.value) }, choices.map(str => (React.createElement(MenuItem, { key: str, value: str }, str)))));
});
const FileSelectorWrapper = observer(({ slot, }) => {
    var _a;
    return (React.createElement(FileSelector, { location: slot.value, setLocation: location => slot.set(location), name: slot.name, description: slot.description, rootModel: (_a = getEnv(slot).pluginManager) === null || _a === void 0 ? void 0 : _a.rootModel }));
});
const valueComponents = {
    string: StringEditor,
    text: TextEditor,
    fileLocation: FileSelectorWrapper,
    stringArray: StringArrayEditor,
    stringArrayMap: StringArrayMapEditor,
    numberMap: NumberMapEditor,
    number: NumberEditor,
    integer: IntegerEditor,
    color: ColorEditor,
    stringEnum: StringEnumEditor,
    boolean: BooleanEditor,
    frozen: JsonEditor,
    configRelationships: JsonEditor,
};
export const useSlotEditorStyles = makeStyles()(theme => ({
    paper: {
        display: 'flex',
        marginBottom: theme.spacing(2),
        position: 'relative',
    },
    paperContent: {
        width: '100%',
    },
    slotModeSwitch: {
        width: 24,
        background: theme.palette.secondary.light,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
    },
}));
const SlotEditor = observer(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
({ slot, slotSchema }) => {
    const { classes } = useSlotEditorStyles();
    const { type } = slot;
    let ValueComponent = slot.isCallback
        ? CallbackEditor
        : // @ts-ignore
            valueComponents[type];
    if (!ValueComponent) {
        console.warn(`no slot editor defined for ${type}, editing as string`);
        ValueComponent = StringEditor;
    }
    if (!(type in valueComponents)) {
        console.warn(`SlotEditor needs to implement ${type}`);
    }
    return (React.createElement(Paper, { className: classes.paper },
        React.createElement("div", { className: classes.paperContent },
            React.createElement(ValueComponent, { slot: slot, slotSchema: slotSchema })),
        React.createElement("div", { className: classes.slotModeSwitch }, slot.contextVariable.length ? (React.createElement(IconButton, { onClick: () => slot.isCallback
                ? slot.convertToValue()
                : slot.convertToCallback(), title: `convert to ${slot.isCallback ? 'regular value' : 'callback'}`, color: "secondary" }, !slot.isCallback ? (React.createElement(RadioButtonUncheckedIcon, null)) : (React.createElement(SvgCheckbox, null)))) : null)));
});
export default SlotEditor;
//# sourceMappingURL=SlotEditor.js.map