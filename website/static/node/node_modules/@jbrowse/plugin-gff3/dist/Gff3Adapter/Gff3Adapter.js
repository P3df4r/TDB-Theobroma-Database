"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const interval_tree_1 = __importDefault(require("@flatten-js/interval-tree"));
const simpleFeature_1 = __importDefault(require("@jbrowse/core/util/simpleFeature"));
const bgzf_filehandle_1 = require("@gmod/bgzf-filehandle");
const gff_1 = __importDefault(require("@gmod/gff"));
function isGzip(buf) {
    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
}
class default_1 extends BaseAdapter_1.BaseFeatureDataAdapter {
    async loadDataP() {
        const pm = this.pluginManager;
        const buf = await (0, io_1.openLocation)(this.getConf('gffLocation'), pm).readFile();
        const buffer = isGzip(buf) ? await (0, bgzf_filehandle_1.unzip)(buf) : buf;
        // 512MB  max chrome string length is 512MB
        if (buffer.length > 536870888) {
            throw new Error('Data exceeds maximum string length (512MB)');
        }
        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);
        const lines = data.split(/\n|\r\n|\r/);
        const headerLines = [];
        for (let i = 0; i < lines.length && lines[i].startsWith('#'); i++) {
            headerLines.push(lines[i]);
        }
        const header = headerLines.join('\n');
        const feats = gff_1.default.parseStringSync(data, {
            parseFeatures: true,
            parseComments: false,
            parseDirectives: false,
            parseSequences: false,
            disableDerivesFromReferences: true,
        });
        const intervalTree = feats
            .flat()
            .map((f, i) => new simpleFeature_1.default({
            data: this.featureData(f),
            id: `${this.id}-offset-${i}`,
        }))
            .reduce((acc, obj) => {
            const key = obj.get('refName');
            if (!acc[key]) {
                acc[key] = new interval_tree_1.default();
            }
            acc[key].insert([obj.get('start'), obj.get('end')], obj);
            return acc;
        }, {});
        return { header, intervalTree };
    }
    async loadData() {
        if (!this.gffFeatures) {
            this.gffFeatures = this.loadDataP().catch(e => {
                this.gffFeatures = undefined;
                throw e;
            });
        }
        return this.gffFeatures;
    }
    async getRefNames(opts = {}) {
        const { intervalTree } = await this.loadData();
        return Object.keys(intervalTree);
    }
    async getHeader() {
        const { header } = await this.loadData();
        return header;
    }
    getFeatures(query, opts = {}) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            var _a;
            try {
                const { start, end, refName } = query;
                const { intervalTree } = await this.loadData();
                (_a = intervalTree[refName]) === null || _a === void 0 ? void 0 : _a.search([start, end]).forEach(f => observer.next(f));
                observer.complete();
            }
            catch (e) {
                observer.error(e);
            }
        }, opts.signal);
    }
    featureData(data) {
        const f = { ...data };
        f.start -= 1; // convert to interbase
        if (data.strand === '+') {
            f.strand = 1;
        }
        else if (data.strand === '-') {
            f.strand = -1;
        }
        else if (data.strand === '.') {
            f.strand = 0;
        }
        else {
            f.strand = undefined;
        }
        f.phase = Number(data.phase);
        f.refName = data.seq_id;
        if (data.score === null) {
            delete f.score;
        }
        if (data.phase === null) {
            delete f.score;
        }
        const defaultFields = [
            'start',
            'end',
            'seq_id',
            'score',
            'type',
            'source',
            'phase',
            'strand',
        ];
        const dataAttributes = data.attributes || {};
        Object.keys(dataAttributes).forEach(a => {
            let b = a.toLowerCase();
            if (defaultFields.includes(b)) {
                // add "suffix" to tag name if it already exists
                // reproduces behavior of NCList
                b += '2';
            }
            if (dataAttributes[a] !== null) {
                let attr = dataAttributes[a];
                if (Array.isArray(attr) && attr.length === 1) {
                    ;
                    [attr] = attr;
                }
                f[b] = attr;
            }
        });
        f.refName = f.seq_id;
        // the SimpleFeature constructor takes care of recursively inflating subfeatures
        if (data.child_features && data.child_features.length) {
            f.subfeatures = data.child_features
                .map(childLocs => childLocs.map(childLoc => this.featureData(childLoc)))
                .flat();
        }
        delete f.child_features;
        delete f.data;
        // delete f.derived_features
        delete f.attributes;
        delete f.seq_id;
        return f;
    }
    freeResources( /* { region } */) { }
}
exports.default = default_1;
//# sourceMappingURL=Gff3Adapter.js.map