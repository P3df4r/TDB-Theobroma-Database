import React from 'react';
import { measureText, getContainingView, getContainingTrack, } from '@jbrowse/core/util';
import { getConf } from '@jbrowse/core/configuration';
import { BaseLinearDisplayComponent, } from '@jbrowse/plugin-linear-genome-view';
import { observer } from 'mobx-react';
import YScaleBar from './YScaleBar';
const trackLabelFontSize = 12.8;
function getOffset(model) {
    const { prefersOffset } = model;
    const { trackLabels } = getContainingView(model);
    const track = getContainingTrack(model);
    const trackName = getConf(track, 'name');
    return trackLabels === 'overlapping' && !prefersOffset
        ? measureText(trackName, trackLabelFontSize) + 100
        : 10;
}
const Wrapper = observer(({ children, model, exportSVG, }) => {
    if (exportSVG) {
        return React.createElement(React.Fragment, null, children);
    }
    else {
        const { height } = model;
        return (React.createElement("svg", { style: {
                position: 'absolute',
                top: 0,
                left: 0,
                pointerEvents: 'none',
                height,
                width: getContainingView(model).width,
            } }, children));
    }
});
const RectBg = (props) => {
    const { color = 'rgb(255,255,255,0.8)' } = props;
    return React.createElement("rect", { ...props, fill: color });
};
const ScoreLegend = observer(({ model }) => {
    const { ticks, scaleType } = model;
    const { width } = getContainingView(model);
    const legend = `[${ticks.values[0]}-${ticks.values[1]}]` +
        (scaleType === 'log' ? ' (log scale)' : '');
    const len = measureText(legend, 14);
    const padding = 25;
    const xpos = width - len - padding;
    return (React.createElement(React.Fragment, null,
        React.createElement(RectBg, { y: 0, x: xpos, width: len + 6, height: 16 }),
        React.createElement("text", { y: 13, x: xpos }, legend)));
});
const ColorLegend = observer(({ model, rowHeight, labelWidth, exportSVG, }) => {
    const { needsCustomLegend, needsScalebar, needsFullHeightScalebar, rowHeightTooSmallForScalebar, renderColorBoxes, sources, } = model;
    const svgFontSize = Math.min(rowHeight, 12);
    const canDisplayLabel = rowHeight > 11;
    const colorBoxWidth = renderColorBoxes ? 15 : 0;
    const legendWidth = labelWidth + colorBoxWidth + 5;
    const svgOffset = exportSVG ? 10 : 0;
    const extraOffset = svgOffset || (needsScalebar && !rowHeightTooSmallForScalebar ? 50 : 0);
    return sources ? (React.createElement(React.Fragment, null,
        /* 0.25 for hanging letters like g */
        needsFullHeightScalebar ? (React.createElement(RectBg, { y: 0, x: extraOffset, width: legendWidth, height: (sources.length + 0.25) * rowHeight })) : null,
        sources.map((source, idx) => {
            const boxHeight = Math.min(20, rowHeight);
            return (React.createElement(React.Fragment, { key: source.name + '-' + idx },
                !needsFullHeightScalebar ? (React.createElement(RectBg, { y: idx * rowHeight + 1, x: extraOffset, width: legendWidth, height: boxHeight })) : null,
                source.color ? (React.createElement(RectBg, { y: idx * rowHeight + 1, x: extraOffset, width: colorBoxWidth, height: needsCustomLegend ? rowHeight : boxHeight, color: source.color })) : null,
                canDisplayLabel ? (React.createElement("text", { y: idx * rowHeight + 13, x: extraOffset + colorBoxWidth + 2, fontSize: svgFontSize }, source.name)) : null));
        }))) : null;
});
export const StatBars = observer((props) => {
    const { model, orientation, exportSVG } = props;
    const { stats, needsCustomLegend, needsFullHeightScalebar, rowHeightTooSmallForScalebar, rowHeight, sources, ticks, } = model;
    const svgFontSize = Math.min(rowHeight, 12);
    const canDisplayLabel = rowHeight > 11;
    const { width: viewWidth } = getContainingView(model);
    const minWidth = 20;
    const ready = stats && sources;
    if (!ready) {
        return null;
    }
    const labelWidth = Math.max(...(sources
        .map(s => measureText(s.name, svgFontSize))
        .map(width => (canDisplayLabel ? width : minWidth)) || [0]));
    return (React.createElement(Wrapper, { ...props }, needsFullHeightScalebar ? (React.createElement(React.Fragment, null,
        React.createElement("g", { transform: `translate(${!exportSVG ? getOffset(model) : 0},0)` },
            React.createElement(YScaleBar, { model: model, orientation: orientation })),
        React.createElement("g", { transform: `translate(${viewWidth - labelWidth - 100},0)` },
            React.createElement(ColorLegend, { exportSVG: exportSVG, model: model, rowHeight: 12, labelWidth: labelWidth })))) : (React.createElement(React.Fragment, null,
        React.createElement(ColorLegend, { exportSVG: exportSVG, model: model, rowHeight: model.rowHeight, labelWidth: labelWidth }),
        rowHeightTooSmallForScalebar || needsCustomLegend ? (React.createElement(ScoreLegend, { ...props })) : (sources.map((_source, idx) => (React.createElement("g", { transform: `translate(0 ${rowHeight * idx})`, key: JSON.stringify(ticks) + '-' + idx },
            React.createElement(YScaleBar, { model: model, orientation: orientation })))))))));
});
const LinearWiggleDisplay = observer((props) => {
    const { model } = props;
    return (React.createElement("div", null,
        React.createElement(BaseLinearDisplayComponent, { ...props }),
        React.createElement(StatBars, { model: model })));
});
export default LinearWiggleDisplay;
export { YScaleBar };
//# sourceMappingURL=WiggleDisplayComponent.js.map