import { FeatureStats } from '@jbrowse/core/util/stats';
import { AnyConfigurationModel } from '@jbrowse/core/configuration';
export declare const YSCALEBAR_LABEL_OFFSET = 5;
export interface ScaleOpts {
    domain: number[];
    range: number[];
    scaleType: string;
    pivotValue?: number;
    inverted: boolean;
}
export interface Source {
    name: string;
    color?: string;
    group?: string;
}
/**
 * produces a d3-scale from arguments. applies a "nice domain" adjustment
 *
 * @param object - containing attributes
 *   - domain [min,max]
 *   - range [min,max]
 *   - bounds [min,max]
 *   - scaleType (linear or log)
 *   - pivotValue (number)
 *   - inverted (boolean)
 */
export declare function getScale({ domain, range, scaleType, pivotValue, inverted, }: ScaleOpts): import("d3-scale").ScaleLinear<number, number, never> | import("d3-scale").ScaleQuantize<number, never>;
/**
 * gets the origin for drawing the graph. for linear this is 0, for log this is arbitrarily set to log(1)==0
 *
 * @param scaleType -
 */
export declare function getOrigin(scaleType: string): 1 | 0;
/**
 * produces a "nice" domain that actually rounds down to 0 for the min
 * or 0 to the max depending on if all values are positive or negative
 *
 * @param object - containing attributes
 *   - domain [min,max]
 *   - bounds [min,max]
 *   - mean
 *   - stddev
 *   - scaleType (linear or log)
 */
export declare function getNiceDomain({ scaleType, domain, bounds, }: {
    scaleType: string;
    domain: number[];
    bounds: number[];
}): [number, number];
export declare function groupBy<T>(array: T[], predicate: (v: T) => string): {
    [key: string]: T[];
};
export declare function getStats(self: {
    adapterConfig: AnyConfigurationModel;
    autoscaleType: string;
    setMessage: (str: string) => void;
}, opts: {
    headers?: Record<string, string>;
    signal?: AbortSignal;
    filters?: string[];
}): Promise<FeatureStats>;
export declare function statsAutorun(self: {
    estimatedStatsReady: boolean;
    regionTooLarge: boolean;
    setLoading: (aborter: AbortController) => void;
    setError: (error: unknown) => void;
    updateStats: (stats: FeatureStats, statsRegion: string) => void;
    renderProps: () => Record<string, unknown>;
    adapterConfig: AnyConfigurationModel;
    autoscaleType: string;
    setMessage: (str: string) => void;
}): void;
export declare function toP(s?: number): number;
export declare function round(value: number): number;
