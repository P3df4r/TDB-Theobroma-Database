"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const plugin_linear_genome_view_1 = require("@jbrowse/plugin-linear-genome-view");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const react_d3_axis_mod_1 = require("react-d3-axis-mod");
const util_2 = require("../../util");
const Tooltip_1 = __importDefault(require("../components/Tooltip"));
const WiggleDisplayComponent_1 = require("../components/WiggleDisplayComponent");
const SetMinMaxDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('../components/SetMinMaxDialog'))));
const SetColorDlg = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('../components/SetColorDialog'))));
// using a map because it preserves order
const rendererTypes = new Map([
    ['xyplot', 'XYPlotRenderer'],
    ['density', 'DensityRenderer'],
    ['line', 'LinePlotRenderer'],
]);
/**
 * #stateModel LinearWiggleDisplay
 * Extends `BaseLinearDisplay`
 */
function stateModelFactory(pluginManager, configSchema) {
    return mobx_state_tree_1.types
        .compose('LinearWiggleDisplay', plugin_linear_genome_view_1.BaseLinearDisplay, mobx_state_tree_1.types.model({
        /**
         * #property
         */
        type: mobx_state_tree_1.types.literal('LinearWiggleDisplay'),
        /**
         * #property
         */
        configuration: (0, configuration_1.ConfigurationReference)(configSchema),
        /**
         * #property
         */
        selectedRendering: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ''),
        /**
         * #property
         */
        resolution: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 1),
        /**
         * #property
         */
        fill: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.boolean),
        /**
         * #property
         */
        minSize: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
        /**
         * #property
         */
        color: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        posColor: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        negColor: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        summaryScoreMode: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        rendererTypeNameState: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        scale: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        autoscale: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        /**
         * #property
         */
        displayCrossHatches: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.boolean),
        /**
         * #property
         */
        constraints: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.model({
            max: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
            min: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.number),
        }), {}),
    }))
        .volatile(() => ({
        statsReady: false,
        message: undefined,
        stats: { scoreMin: 0, scoreMax: 50 },
        statsFetchInProgress: undefined,
    }))
        .actions(self => ({
        /**
         * #action
         */
        updateStats(stats) {
            const { scoreMin, scoreMax } = stats;
            const EPSILON = 0.000001;
            if (Math.abs(self.stats.scoreMax - scoreMax) > EPSILON ||
                Math.abs(self.stats.scoreMin - scoreMin) > EPSILON) {
                self.stats = { scoreMin, scoreMax };
            }
            self.statsReady = true;
        },
        /**
         * #action
         */
        setColor(color) {
            self.color = color;
        },
        /**
         * #action
         */
        setPosColor(color) {
            self.posColor = color;
        },
        /**
         * #action
         */
        setNegColor(color) {
            self.negColor = color;
        },
        /**
         * #action
         */
        setLoading(aborter) {
            const { statsFetchInProgress: statsFetch } = self;
            if (statsFetch !== undefined && !statsFetch.signal.aborted) {
                statsFetch.abort();
            }
            self.statsFetchInProgress = aborter;
        },
        /**
         * #action
         * this overrides the BaseLinearDisplayModel to avoid popping up a
         * feature detail display, but still sets the feature selection on the
         * model so listeners can detect a click
         */
        selectFeature(feature) {
            const session = (0, util_1.getSession)(self);
            if ((0, util_1.isSelectionContainer)(session)) {
                session.setSelection(feature);
            }
        },
        /**
         * #action
         */
        setResolution(res) {
            self.resolution = res;
        },
        /**
         * #action
         */
        setFill(fill) {
            if (fill === 0) {
                self.fill = true;
                self.minSize = 0;
            }
            else if (fill === 1) {
                self.fill = false;
                self.minSize = 1;
            }
            else if (fill === 2) {
                self.fill = false;
                self.minSize = 2;
            }
        },
        /**
         * #action
         */
        toggleLogScale() {
            if (self.scale !== 'log') {
                self.scale = 'log';
            }
            else {
                self.scale = 'linear';
            }
        },
        /**
         * #action
         */
        setScaleType(scale) {
            self.scale = scale;
        },
        /**
         * #action
         */
        setSummaryScoreMode(val) {
            self.summaryScoreMode = val;
        },
        /**
         * #action
         */
        setAutoscale(val) {
            self.autoscale = val;
        },
        /**
         * #action
         */
        setMaxScore(val) {
            self.constraints.max = val;
        },
        /**
         * #action
         */
        setRendererType(val) {
            self.rendererTypeNameState = val;
        },
        /**
         * #action
         */
        setMinScore(val) {
            self.constraints.min = val;
        },
        /**
         * #action
         */
        toggleCrossHatches() {
            self.displayCrossHatches = !self.displayCrossHatches;
        },
        /**
         * #action
         */
        setCrossHatches(cross) {
            self.displayCrossHatches = cross;
        },
    }))
        .views(self => ({
        /**
         * #getter
         */
        get TooltipComponent() {
            return Tooltip_1.default;
        },
        /**
         * #getter
         */
        get adapterTypeName() {
            return self.adapterConfig.type;
        },
        /**
         * #getter
         */
        get rendererTypeNameSimple() {
            return self.rendererTypeNameState || (0, configuration_1.getConf)(self, 'defaultRendering');
        },
        /**
         * #getter
         */
        get rendererTypeName() {
            const name = this.rendererTypeNameSimple;
            const rendererType = rendererTypes.get(name);
            if (!rendererType) {
                throw new Error(`unknown renderer ${name}`);
            }
            return rendererType;
        },
        /**
         * #getter
         * subclasses can define these, as snpcoverage track does
         */
        get filters() {
            return undefined;
        },
        /**
         * #getter
         */
        get scaleType() {
            return self.scale || (0, configuration_1.getConf)(self, 'scaleType');
        },
        /**
         * #getter
         */
        get maxScore() {
            var _a;
            return (_a = self.constraints.max) !== null && _a !== void 0 ? _a : (0, configuration_1.getConf)(self, 'maxScore');
        },
        /**
         * #getter
         */
        get minScore() {
            var _a;
            return (_a = self.constraints.min) !== null && _a !== void 0 ? _a : (0, configuration_1.getConf)(self, 'minScore');
        },
    }))
        .views(self => ({
        /**
         * #getter
         */
        get rendererConfig() {
            const configBlob = (0, configuration_1.getConf)(self, ['renderers', self.rendererTypeName]) || {};
            const { color, displayCrossHatches, fill, minSize, negColor, posColor, summaryScoreMode, scaleType, } = self;
            return self.rendererType.configSchema.create({
                ...configBlob,
                ...(scaleType ? { scaleType } : {}),
                ...(fill !== undefined ? { filled: fill } : {}),
                ...(displayCrossHatches !== undefined
                    ? { displayCrossHatches }
                    : {}),
                ...(summaryScoreMode !== undefined ? { summaryScoreMode } : {}),
                ...(color !== undefined ? { color } : {}),
                ...(negColor !== undefined ? { negColor } : {}),
                ...(posColor !== undefined ? { posColor } : {}),
                ...(minSize !== undefined ? { minSize } : {}),
            }, (0, util_1.getEnv)(self));
        },
    }))
        .views(self => {
        let oldDomain = [0, 0];
        return {
            /**
             * #getter
             */
            get filled() {
                const { fill, rendererConfig: conf } = self;
                return fill !== null && fill !== void 0 ? fill : (0, configuration_1.readConfObject)(conf, 'filled');
            },
            /**
             * #getter
             */
            get summaryScoreModeSetting() {
                const { summaryScoreMode, rendererConfig: conf } = self;
                return summaryScoreMode !== null && summaryScoreMode !== void 0 ? summaryScoreMode : (0, configuration_1.readConfObject)(conf, 'summaryScoreMode');
            },
            /**
             * #getter
             */
            get domain() {
                const { stats, scaleType, minScore, maxScore } = self;
                const ret = (0, util_2.getNiceDomain)({
                    domain: [stats.scoreMin, stats.scoreMax],
                    bounds: [minScore, maxScore],
                    scaleType,
                });
                // avoid weird scalebar if log value and empty region displayed
                if (scaleType === 'log' && ret[1] === Number.MIN_VALUE) {
                    return [0, Number.MIN_VALUE];
                }
                // avoid returning a new object if it matches the old value
                if (JSON.stringify(oldDomain) !== JSON.stringify(ret)) {
                    oldDomain = ret;
                }
                return oldDomain;
            },
            /**
             * #getter
             */
            get needsScalebar() {
                return (self.rendererTypeName === 'XYPlotRenderer' ||
                    self.rendererTypeName === 'LinePlotRenderer');
            },
            /**
             * #getter
             */
            get scaleOpts() {
                return {
                    domain: this.domain,
                    stats: self.stats,
                    autoscaleType: this.autoscaleType,
                    scaleType: self.scaleType,
                    inverted: (0, configuration_1.getConf)(self, 'inverted'),
                };
            },
            /**
             * #getter
             */
            get canHaveFill() {
                return self.rendererTypeName === 'XYPlotRenderer';
            },
            /**
             * #getter
             */
            get autoscaleType() {
                var _a;
                return (_a = self.autoscale) !== null && _a !== void 0 ? _a : (0, configuration_1.getConf)(self, 'autoscale');
            },
            /**
             * #getter
             */
            get displayCrossHatchesSetting() {
                const { displayCrossHatches: hatches, rendererConfig: conf } = self;
                return hatches !== null && hatches !== void 0 ? hatches : (0, configuration_1.readConfObject)(conf, 'displayCrossHatches');
            },
        };
    })
        .views(self => ({
        /**
         * #getter
         */
        get ticks() {
            const { scaleType, domain, height } = self;
            const minimalTicks = (0, configuration_1.getConf)(self, 'minimalTicks');
            const inverted = (0, configuration_1.getConf)(self, 'inverted');
            const range = [height - util_2.YSCALEBAR_LABEL_OFFSET, util_2.YSCALEBAR_LABEL_OFFSET];
            const scale = (0, util_2.getScale)({
                scaleType,
                domain,
                range,
                inverted,
            });
            const ticks = (0, react_d3_axis_mod_1.axisPropsFromTickScale)(scale, 4);
            return height < 100 || minimalTicks
                ? { ...ticks, values: domain }
                : ticks;
        },
        /**
         * #getter
         */
        get adapterCapabilities() {
            const type = self.adapterTypeName;
            return pluginManager.getAdapterType(type).adapterCapabilities;
        },
    }))
        .views(self => {
        const { renderProps: superRenderProps } = self;
        return {
            /**
             * #method
             */
            renderProps() {
                const superProps = superRenderProps();
                const { filters, ticks, height, resolution, scaleOpts } = self;
                return {
                    ...superProps,
                    notReady: superProps.notReady || !self.statsReady,
                    rpcDriverName: self.rpcDriverName,
                    displayModel: self,
                    config: self.rendererConfig,
                    displayCrossHatches: self.displayCrossHatchesSetting,
                    scaleOpts,
                    resolution,
                    height,
                    ticks,
                    filters,
                };
            },
            /**
             * #getter
             */
            get hasResolution() {
                return self.adapterCapabilities.includes('hasResolution');
            },
            /**
             * #getter
             */
            get hasGlobalStats() {
                return self.adapterCapabilities.includes('hasGlobalStats');
            },
            /**
             * #getter
             */
            get fillSetting() {
                if (self.filled) {
                    return 0;
                }
                else if (!self.filled && self.minSize === 1) {
                    return 1;
                }
                else {
                    return 2;
                }
            },
        };
    })
        .views(self => {
        const { trackMenuItems: superTrackMenuItems } = self;
        const hasRenderings = (0, configuration_1.getConf)(self, 'defaultRendering');
        return {
            /**
             * #method
             */
            trackMenuItems() {
                return [
                    ...superTrackMenuItems(),
                    ...(self.hasResolution
                        ? [
                            {
                                label: 'Resolution',
                                subMenu: [
                                    {
                                        label: 'Finer resolution',
                                        onClick: () => self.setResolution(self.resolution * 5),
                                    },
                                    {
                                        label: 'Coarser resolution',
                                        onClick: () => self.setResolution(self.resolution / 5),
                                    },
                                ],
                            },
                            {
                                label: 'Summary score mode',
                                subMenu: ['min', 'max', 'avg', 'whiskers'].map(elt => ({
                                    label: elt,
                                    type: 'radio',
                                    checked: self.summaryScoreModeSetting === elt,
                                    onClick: () => self.setSummaryScoreMode(elt),
                                })),
                            },
                        ]
                        : []),
                    ...(self.canHaveFill
                        ? [
                            {
                                label: 'Fill mode',
                                subMenu: ['filled', 'no fill', 'no fill w/ emphasis'].map((elt, idx) => ({
                                    label: elt,
                                    type: 'radio',
                                    checked: self.fillSetting === idx,
                                    onClick: () => self.setFill(idx),
                                })),
                            },
                        ]
                        : []),
                    {
                        label: self.scaleType === 'log' ? 'Set linear scale' : 'Set log scale',
                        onClick: () => self.toggleLogScale(),
                    },
                    ...(self.needsScalebar
                        ? [
                            {
                                type: 'checkbox',
                                label: 'Draw cross hatches',
                                checked: self.displayCrossHatchesSetting,
                                onClick: () => self.toggleCrossHatches(),
                            },
                        ]
                        : []),
                    ...(hasRenderings
                        ? [
                            {
                                label: 'Renderer type',
                                subMenu: ['xyplot', 'density', 'line'].map(key => ({
                                    label: key,
                                    type: 'radio',
                                    checked: self.rendererTypeNameSimple === key,
                                    onClick: () => self.setRendererType(key),
                                })),
                            },
                        ]
                        : []),
                    {
                        label: 'Autoscale type',
                        subMenu: [
                            ['local', 'Local'],
                            ...(self.hasGlobalStats
                                ? [
                                    ['global', 'Global'],
                                    ['globalsd', 'Global ± 3σ'],
                                ]
                                : []),
                            ['localsd', 'Local ± 3σ'],
                        ].map(([val, label]) => ({
                            label,
                            type: 'radio',
                            checked: self.autoscaleType === val,
                            onClick: () => self.setAutoscale(val),
                        })),
                    },
                    {
                        label: 'Set min/max score',
                        onClick: () => {
                            (0, util_1.getSession)(self).queueDialog(handleClose => [
                                SetMinMaxDlg,
                                { model: self, handleClose },
                            ]);
                        },
                    },
                    {
                        label: 'Set color',
                        onClick: () => {
                            (0, util_1.getSession)(self).queueDialog(handleClose => [
                                SetColorDlg,
                                { model: self, handleClose },
                            ]);
                        },
                    },
                ];
            },
        };
    })
        .actions(self => {
        const { reload: superReload, renderSvg: superRenderSvg } = self;
        return {
            /**
             * #action
             * re-runs stats and refresh whole display on reload
             */
            async reload() {
                self.setError();
                const aborter = new AbortController();
                self.setLoading(aborter);
                try {
                    const stats = await (0, util_2.getStats)(self, {
                        signal: aborter.signal,
                        ...self.renderProps(),
                    });
                    if ((0, mobx_state_tree_1.isAlive)(self)) {
                        self.updateStats(stats);
                        superReload();
                    }
                }
                catch (e) {
                    self.setError(e);
                }
            },
            afterAttach() {
                (0, util_2.statsAutorun)(self);
            },
            /**
             * #action
             */
            async renderSvg(opts) {
                await (0, mobx_1.when)(() => self.statsReady && !!self.regionCannotBeRenderedText);
                const { needsScalebar, stats } = self;
                const { offsetPx } = (0, util_1.getContainingView)(self);
                return (react_1.default.createElement(react_1.default.Fragment, null,
                    react_1.default.createElement("g", { id: "snpcov" }, await superRenderSvg(opts)),
                    needsScalebar && stats ? (react_1.default.createElement("g", { transform: `translate(${Math.max(-offsetPx, 0)})` },
                        react_1.default.createElement(WiggleDisplayComponent_1.YScaleBar, { model: self, orientation: "left" }))) : null));
            },
        };
    });
}
exports.default = stateModelFactory;
//# sourceMappingURL=model.js.map