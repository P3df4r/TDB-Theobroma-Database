"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const util_1 = require("@jbrowse/core/util");
const rxjs_2 = require("rxjs");
const operators_1 = require("rxjs/operators");
function getFilename(uri) {
    const filename = uri.slice(uri.lastIndexOf('/') + 1);
    return filename.slice(0, filename.lastIndexOf('.'));
}
class MultiWiggleAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    async getAdapters() {
        const getSubAdapter = this.getSubAdapter;
        if (!getSubAdapter) {
            throw new Error('no getSubAdapter available');
        }
        let subConfs = this.getConf('subadapters');
        if (!(subConfs === null || subConfs === void 0 ? void 0 : subConfs.length)) {
            const entries = this.getConf('bigWigs');
            subConfs = entries.map(entry => ({
                type: 'BigWigAdapter',
                source: getFilename(entry),
                bigWigLocation: {
                    uri: entry,
                },
            }));
        }
        return Promise.all(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        subConfs.map(async (conf) => {
            const dataAdapter = (await getSubAdapter(conf))
                .dataAdapter;
            return {
                source: conf.name || dataAdapter.id,
                ...conf,
                dataAdapter,
            };
        }));
    }
    // note: can't really have dis-agreeing refNames
    async getRefNames(opts) {
        const adapters = await this.getAdapters();
        const allNames = await Promise.all(adapters.map(a => a.dataAdapter.getRefNames(opts)));
        return [...new Set(allNames.flat())];
    }
    async getGlobalStats(opts) {
        const adapters = await this.getAdapters();
        const stats = (await Promise.all(
        // @ts-ignore
        adapters.map(adp => { var _a, _b; return (_b = (_a = adp.dataAdapter).getGlobalStats) === null || _b === void 0 ? void 0 : _b.call(_a, opts); }))).filter(f => !!f);
        const scoreMin = Math.min(...stats.map(s => s.scoreMin));
        const scoreMax = Math.max(...stats.map(s => s.scoreMax));
        return { scoreMin, scoreMax };
    }
    getFeatures(region, opts = {}) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const adapters = await this.getAdapters();
            (0, rxjs_2.merge)(...adapters.map(adp => adp.dataAdapter.getFeatures(region, opts).pipe((0, operators_1.map)(p => 
            // add source field if it does not exist
            p.get('source')
                ? p
                : new util_1.SimpleFeature({
                    ...p.toJSON(),
                    uniqueId: adp.source + '-' + p.id(),
                    source: adp.source,
                }))))).subscribe(observer);
        }, opts.signal);
    }
    // always render bigwig instead of calculating a feature density for it
    async estimateRegionsStats(_regions) {
        return { featureDensity: 0 };
    }
    // in another adapter type, this could be dynamic depending on region or
    // something, but it is static for this particular multi-wiggle adapter type
    async getSources() {
        const adapters = await this.getAdapters();
        return adapters.map(({ dataAdapter, source, name, ...rest }) => ({
            name: source,
            __name: name,
            ...rest,
        }));
    }
    freeResources() { }
}
exports.default = MultiWiggleAdapter;
MultiWiggleAdapter.capabilities = [
    'hasResolution',
    'hasLocalStats',
    'hasGlobalStats',
];
//# sourceMappingURL=MultiWiggleAdapter.js.map