"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YScaleBar = exports.StatBars = void 0;
const react_1 = __importDefault(require("react"));
const util_1 = require("@jbrowse/core/util");
const configuration_1 = require("@jbrowse/core/configuration");
const plugin_linear_genome_view_1 = require("@jbrowse/plugin-linear-genome-view");
const mobx_react_1 = require("mobx-react");
const YScaleBar_1 = __importDefault(require("./YScaleBar"));
exports.YScaleBar = YScaleBar_1.default;
const trackLabelFontSize = 12.8;
function getOffset(model) {
    const { prefersOffset } = model;
    const { trackLabels } = (0, util_1.getContainingView)(model);
    const track = (0, util_1.getContainingTrack)(model);
    const trackName = (0, configuration_1.getConf)(track, 'name');
    return trackLabels === 'overlapping' && !prefersOffset
        ? (0, util_1.measureText)(trackName, trackLabelFontSize) + 100
        : 10;
}
const Wrapper = (0, mobx_react_1.observer)(({ children, model, exportSVG, }) => {
    if (exportSVG) {
        return react_1.default.createElement(react_1.default.Fragment, null, children);
    }
    else {
        const { height } = model;
        return (react_1.default.createElement("svg", { style: {
                position: 'absolute',
                top: 0,
                left: 0,
                pointerEvents: 'none',
                height,
                width: (0, util_1.getContainingView)(model).width,
            } }, children));
    }
});
const RectBg = (props) => {
    const { color = 'rgb(255,255,255,0.8)' } = props;
    return react_1.default.createElement("rect", { ...props, fill: color });
};
const ScoreLegend = (0, mobx_react_1.observer)(({ model }) => {
    const { ticks, scaleType } = model;
    const { width } = (0, util_1.getContainingView)(model);
    const legend = `[${ticks.values[0]}-${ticks.values[1]}]` +
        (scaleType === 'log' ? ' (log scale)' : '');
    const len = (0, util_1.measureText)(legend, 14);
    const padding = 25;
    const xpos = width - len - padding;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(RectBg, { y: 0, x: xpos, width: len + 6, height: 16 }),
        react_1.default.createElement("text", { y: 13, x: xpos }, legend)));
});
const ColorLegend = (0, mobx_react_1.observer)(({ model, rowHeight, labelWidth, exportSVG, }) => {
    const { needsCustomLegend, needsScalebar, needsFullHeightScalebar, rowHeightTooSmallForScalebar, renderColorBoxes, sources, } = model;
    const svgFontSize = Math.min(rowHeight, 12);
    const canDisplayLabel = rowHeight > 11;
    const colorBoxWidth = renderColorBoxes ? 15 : 0;
    const legendWidth = labelWidth + colorBoxWidth + 5;
    const svgOffset = exportSVG ? 10 : 0;
    const extraOffset = svgOffset || (needsScalebar && !rowHeightTooSmallForScalebar ? 50 : 0);
    return sources ? (react_1.default.createElement(react_1.default.Fragment, null,
        /* 0.25 for hanging letters like g */
        needsFullHeightScalebar ? (react_1.default.createElement(RectBg, { y: 0, x: extraOffset, width: legendWidth, height: (sources.length + 0.25) * rowHeight })) : null,
        sources.map((source, idx) => {
            const boxHeight = Math.min(20, rowHeight);
            return (react_1.default.createElement(react_1.default.Fragment, { key: source.name + '-' + idx },
                !needsFullHeightScalebar ? (react_1.default.createElement(RectBg, { y: idx * rowHeight + 1, x: extraOffset, width: legendWidth, height: boxHeight })) : null,
                source.color ? (react_1.default.createElement(RectBg, { y: idx * rowHeight + 1, x: extraOffset, width: colorBoxWidth, height: needsCustomLegend ? rowHeight : boxHeight, color: source.color })) : null,
                canDisplayLabel ? (react_1.default.createElement("text", { y: idx * rowHeight + 13, x: extraOffset + colorBoxWidth + 2, fontSize: svgFontSize }, source.name)) : null));
        }))) : null;
});
exports.StatBars = (0, mobx_react_1.observer)((props) => {
    const { model, orientation, exportSVG } = props;
    const { stats, needsCustomLegend, needsFullHeightScalebar, rowHeightTooSmallForScalebar, rowHeight, sources, ticks, } = model;
    const svgFontSize = Math.min(rowHeight, 12);
    const canDisplayLabel = rowHeight > 11;
    const { width: viewWidth } = (0, util_1.getContainingView)(model);
    const minWidth = 20;
    const ready = stats && sources;
    if (!ready) {
        return null;
    }
    const labelWidth = Math.max(...(sources
        .map(s => (0, util_1.measureText)(s.name, svgFontSize))
        .map(width => (canDisplayLabel ? width : minWidth)) || [0]));
    return (react_1.default.createElement(Wrapper, { ...props }, needsFullHeightScalebar ? (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("g", { transform: `translate(${!exportSVG ? getOffset(model) : 0},0)` },
            react_1.default.createElement(YScaleBar_1.default, { model: model, orientation: orientation })),
        react_1.default.createElement("g", { transform: `translate(${viewWidth - labelWidth - 100},0)` },
            react_1.default.createElement(ColorLegend, { exportSVG: exportSVG, model: model, rowHeight: 12, labelWidth: labelWidth })))) : (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(ColorLegend, { exportSVG: exportSVG, model: model, rowHeight: model.rowHeight, labelWidth: labelWidth }),
        rowHeightTooSmallForScalebar || needsCustomLegend ? (react_1.default.createElement(ScoreLegend, { ...props })) : (sources.map((_source, idx) => (react_1.default.createElement("g", { transform: `translate(0 ${rowHeight * idx})`, key: JSON.stringify(ticks) + '-' + idx },
            react_1.default.createElement(YScaleBar_1.default, { model: model, orientation: orientation })))))))));
});
const LinearWiggleDisplay = (0, mobx_react_1.observer)((props) => {
    const { model } = props;
    return (react_1.default.createElement("div", null,
        react_1.default.createElement(plugin_linear_genome_view_1.BaseLinearDisplayComponent, { ...props }),
        react_1.default.createElement(exports.StatBars, { model: model })));
});
exports.default = LinearWiggleDisplay;
//# sourceMappingURL=WiggleDisplayComponent.js.map