"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.round = exports.toP = exports.statsAutorun = exports.getStats = exports.groupBy = exports.getNiceDomain = exports.getOrigin = exports.getScale = exports.YSCALEBAR_LABEL_OFFSET = void 0;
const d3_scale_1 = require("d3-scale");
const mobx_1 = require("mobx");
const util_1 = require("@jbrowse/core/util");
const tracks_1 = require("@jbrowse/core/util/tracks");
const mobx_state_tree_1 = require("mobx-state-tree");
const configuration_1 = require("@jbrowse/core/configuration");
exports.YSCALEBAR_LABEL_OFFSET = 5;
/**
 * produces a d3-scale from arguments. applies a "nice domain" adjustment
 *
 * @param object - containing attributes
 *   - domain [min,max]
 *   - range [min,max]
 *   - bounds [min,max]
 *   - scaleType (linear or log)
 *   - pivotValue (number)
 *   - inverted (boolean)
 */
function getScale({ domain = [], range = [], scaleType, pivotValue, inverted, }) {
    let scale;
    const [min, max] = domain;
    if (min === undefined || max === undefined) {
        throw new Error('invalid domain');
    }
    if (scaleType === 'linear') {
        scale = (0, d3_scale_1.scaleLinear)();
    }
    else if (scaleType === 'log') {
        scale = (0, d3_scale_1.scaleLog)();
        scale.base(2);
    }
    else if (scaleType === 'quantize') {
        scale = (0, d3_scale_1.scaleQuantize)();
    }
    else {
        throw new Error('undefined scaleType');
    }
    scale.domain(pivotValue !== undefined ? [min, pivotValue, max] : [min, max]);
    scale.nice();
    const [rangeMin, rangeMax] = range;
    if (rangeMin === undefined || rangeMax === undefined) {
        throw new Error('invalid range');
    }
    scale.range(inverted ? range.slice().reverse() : range);
    return scale;
}
exports.getScale = getScale;
/**
 * gets the origin for drawing the graph. for linear this is 0, for log this is arbitrarily set to log(1)==0
 *
 * @param scaleType -
 */
function getOrigin(scaleType /* , pivot, stats */) {
    // if (pivot) {
    //   if (pivot === 'mean') {
    //     return stats.scoreMean || 0
    //   }
    //   if (pivot === 'zero') {
    //     return 0
    //   }
    //   return parseFloat()
    // }
    // if (scaleType === 'z_score') {
    //   return stats.scoreMean || 0
    // }
    if (scaleType === 'log') {
        return 1;
    }
    return 0;
}
exports.getOrigin = getOrigin;
/**
 * produces a "nice" domain that actually rounds down to 0 for the min
 * or 0 to the max depending on if all values are positive or negative
 *
 * @param object - containing attributes
 *   - domain [min,max]
 *   - bounds [min,max]
 *   - mean
 *   - stddev
 *   - scaleType (linear or log)
 */
function getNiceDomain({ scaleType, domain, bounds, }) {
    const [minScore, maxScore] = bounds;
    let [min, max] = domain;
    if (scaleType === 'linear') {
        if (max < 0) {
            max = 0;
        }
        if (min > 0) {
            min = 0;
        }
    }
    if (scaleType === 'log') {
        // if the min is 0, assume that it's just something
        // with no read coverage and that we should ignore it in calculations
        // if it's greater than 1 pin to 1 for the full range also
        // otherwise, we may see bigwigs with fractional values
        if (min === 0 || min > 1) {
            min = 1;
        }
    }
    if (min === undefined || max === undefined) {
        throw new Error('invalid domain supplied to stats function');
    }
    if (minScore !== undefined && minScore !== Number.MIN_VALUE) {
        min = minScore;
    }
    if (maxScore !== undefined && maxScore !== Number.MAX_VALUE) {
        max = maxScore;
    }
    const getScaleType = (type) => {
        if (type === 'linear') {
            return (0, d3_scale_1.scaleLinear)();
        }
        if (type === 'log') {
            const scale = (0, d3_scale_1.scaleLog)();
            scale.base(2);
            return scale;
        }
        if (type === 'quantize') {
            return (0, d3_scale_1.scaleQuantize)();
        }
        throw new Error(`undefined scaleType ${type}`);
    };
    const scale = getScaleType(scaleType);
    scale.domain([min, max]);
    scale.nice();
    return scale.domain();
}
exports.getNiceDomain = getNiceDomain;
function groupBy(array, predicate) {
    return array.reduce((acc, value) => {
        var _a;
        const entry = (acc[_a = predicate(value)] || (acc[_a] = []));
        entry.push(value);
        return acc;
    }, {});
}
exports.groupBy = groupBy;
async function getStats(self, opts) {
    const { rpcManager } = (0, util_1.getSession)(self);
    const nd = (0, configuration_1.getConf)(self, 'numStdDev') || 3;
    const { adapterConfig, autoscaleType } = self;
    const sessionId = (0, tracks_1.getRpcSessionId)(self);
    const params = {
        sessionId,
        adapterConfig,
        statusCallback: (message) => {
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                self.setMessage(message);
            }
        },
        ...opts,
    };
    if (autoscaleType === 'global' || autoscaleType === 'globalsd') {
        const results = (await rpcManager.call(sessionId, 'WiggleGetGlobalStats', params));
        const { scoreMin, scoreMean, scoreStdDev } = results;
        // globalsd uses heuristic to avoid unnecessary scoreMin<0
        // if the scoreMin is never less than 0
        // helps with most coverage bigwigs just being >0
        return autoscaleType === 'globalsd'
            ? {
                ...results,
                scoreMin: scoreMin >= 0 ? 0 : scoreMean - nd * scoreStdDev,
                scoreMax: scoreMean + nd * scoreStdDev,
            }
            : results;
    }
    if (autoscaleType === 'local' || autoscaleType === 'localsd') {
        const { dynamicBlocks, bpPerPx } = (0, util_1.getContainingView)(self);
        const results = (await rpcManager.call(sessionId, 'WiggleGetMultiRegionStats', {
            ...params,
            regions: dynamicBlocks.contentBlocks.map(region => {
                const { start, end } = region;
                return {
                    ...JSON.parse(JSON.stringify(region)),
                    start: Math.floor(start),
                    end: Math.ceil(end),
                };
            }),
            bpPerPx,
        }));
        const { scoreMin, scoreMean, scoreStdDev } = results;
        // localsd uses heuristic to avoid unnecessary scoreMin<0 if the
        // scoreMin is never less than 0 helps with most coverage bigwigs
        // just being >0
        return autoscaleType === 'localsd'
            ? {
                ...results,
                scoreMin: scoreMin >= 0 ? 0 : scoreMean - nd * scoreStdDev,
                scoreMax: scoreMean + nd * scoreStdDev,
            }
            : results;
    }
    if (autoscaleType === 'zscale') {
        return rpcManager.call(sessionId, 'WiggleGetGlobalStats', params);
    }
    throw new Error(`invalid autoscaleType '${autoscaleType}'`);
}
exports.getStats = getStats;
function statsAutorun(self) {
    (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.autorun)(async () => {
        try {
            const aborter = new AbortController();
            const view = (0, util_1.getContainingView)(self);
            self.setLoading(aborter);
            if (!view.initialized ||
                !self.estimatedStatsReady ||
                self.regionTooLarge) {
                return;
            }
            const statsRegion = JSON.stringify(view.dynamicBlocks);
            const wiggleStats = await getStats(self, {
                signal: aborter.signal,
                ...self.renderProps(),
            });
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                self.updateStats(wiggleStats, statsRegion);
            }
        }
        catch (e) {
            if (!(0, util_1.isAbortException)(e) && (0, mobx_state_tree_1.isAlive)(self)) {
                console.error(e);
                self.setError(e);
            }
        }
    }, { delay: 1000 }));
}
exports.statsAutorun = statsAutorun;
function toP(s = 0) {
    return +(+s).toPrecision(6);
}
exports.toP = toP;
function round(value) {
    return Math.round(value * 1e5) / 1e5;
}
exports.round = round;
//# sourceMappingURL=util.js.map