"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const trix_1 = __importDefault(require("@gmod/trix"));
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const BaseResults_1 = __importDefault(require("@jbrowse/core/TextSearch/BaseResults"));
const configuration_1 = require("@jbrowse/core/configuration");
function decodeURIComponentNoThrow(uri) {
    try {
        return decodeURIComponent(uri);
    }
    catch (e) {
        // avoid throwing exception on a failure to decode URI component
        return uri;
    }
}
function shorten(str, term, w = 15) {
    const tidx = str.toLowerCase().indexOf(term);
    return str.length < 40
        ? str
        : (Math.max(0, tidx - w) > 0 ? '...' : '') +
            str.slice(Math.max(0, tidx - w), tidx + term.length + w).trim() +
            (tidx + term.length < str.length ? '...' : '');
}
class TrixTextSearchAdapter extends BaseAdapter_1.BaseAdapter {
    constructor(config, getSubAdapter, pluginManager) {
        super(config, getSubAdapter, pluginManager);
        const ixFilePath = (0, configuration_1.readConfObject)(config, 'ixFilePath');
        const ixxFilePath = (0, configuration_1.readConfObject)(config, 'ixxFilePath');
        if (!ixFilePath) {
            throw new Error('must provide out.ix');
        }
        if (!ixxFilePath) {
            throw new Error('must provide out.ixx');
        }
        this.trixJs = new trix_1.default((0, io_1.openLocation)(ixxFilePath), (0, io_1.openLocation)(ixFilePath), 1500);
    }
    /**
     * Returns list of results
     * @param args - search options/arguments include: search query
     * limit of results to return, searchType...prefix | full | exact", etc.
     */
    async searchIndex(args) {
        const query = args.queryString.toLowerCase();
        const strs = query.split(' ');
        const results = await this.trixJs.search(query);
        const formatted = results
            // if multi-word search try to filter out relevant items
            .filter(([, data]) => strs.every(r => decodeURIComponentNoThrow(data).toLowerCase().includes(r)))
            .map(([term, data]) => {
            const result = JSON.parse(data.replace(/\|/g, ','));
            const [loc, trackId, ...rest] = result.map(record => decodeURIComponentNoThrow(record));
            const labelFieldIdx = rest.findIndex(elt => !!elt);
            const contextIdx = rest
                .map(elt => elt.toLowerCase())
                .findIndex(f => f.indexOf(term.toLowerCase()) !== -1);
            const labelField = rest[labelFieldIdx];
            const contextField = rest[contextIdx];
            const context = contextIdx !== -1 ? shorten(contextField, term) : undefined;
            const label = shorten(labelField, term);
            const displayString = !context || label.toLowerCase() === context.toLowerCase()
                ? label
                : `${label} (${context})`;
            return new BaseResults_1.default({
                locString: loc,
                label: labelField,
                displayString,
                matchedObject: result.map(record => decodeURIComponent(record)),
                trackId,
            });
        });
        if (args.searchType === 'exact') {
            return formatted.filter(res => res.getLabel().toLowerCase() === args.queryString.toLowerCase());
        }
        return formatted;
    }
    freeResources() { }
}
exports.default = TrixTextSearchAdapter;
//# sourceMappingURL=TrixTextSearchAdapter.js.map