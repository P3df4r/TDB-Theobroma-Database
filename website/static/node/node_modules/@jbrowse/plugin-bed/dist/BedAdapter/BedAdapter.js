"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bed_1 = __importDefault(require("@gmod/bed"));
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const util_1 = require("../util");
const interval_tree_1 = __importDefault(require("@flatten-js/interval-tree"));
const bgzf_filehandle_1 = require("@gmod/bgzf-filehandle");
function isGzip(buf) {
    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
}
class BedAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    constructor() {
        super(...arguments);
        this.intervalTrees = {};
    }
    async loadDataP(opts = {}) {
        const pm = this.pluginManager;
        const bedLoc = this.getConf('bedLocation');
        const buf = await (0, io_1.openLocation)(bedLoc, pm).readFile(opts);
        const buffer = isGzip(buf) ? await (0, bgzf_filehandle_1.unzip)(buf) : buf;
        // 512MB  max chrome string length is 512MB
        if (buffer.length > 536870888) {
            throw new Error('Data exceeds maximum string length (512MB)');
        }
        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);
        const lines = data.split(/\n|\r\n|\r/).filter(f => !!f);
        const headerLines = [];
        let i = 0;
        for (; i < lines.length && lines[i].startsWith('#'); i++) {
            headerLines.push(lines[i]);
        }
        const header = headerLines.join('\n');
        const features = {};
        for (; i < lines.length; i++) {
            const line = lines[i];
            const tab = line.indexOf('\t');
            const refName = line.slice(0, tab);
            if (!features[refName]) {
                features[refName] = [];
            }
            features[refName].push(line);
        }
        const autoSql = this.getConf('autoSql');
        const parser = new bed_1.default({ autoSql });
        const columnNames = this.getConf('columnNames');
        const scoreColumn = this.getConf('scoreColumn');
        const colRef = this.getConf('colRef');
        const colStart = this.getConf('colStart');
        const colEnd = this.getConf('colEnd');
        return {
            header,
            features,
            parser,
            columnNames,
            scoreColumn,
            colRef,
            colStart,
            colEnd,
        };
    }
    async loadData(opts = {}) {
        if (!this.bedFeatures) {
            this.bedFeatures = this.loadDataP(opts).catch(e => {
                this.bedFeatures = undefined;
                throw e;
            });
        }
        return this.bedFeatures;
    }
    async getRefNames(opts = {}) {
        const { features } = await this.loadData(opts);
        return Object.keys(features);
    }
    async getHeader(opts = {}) {
        const { header } = await this.loadData(opts);
        return header;
    }
    async getNames() {
        const { header, columnNames } = await this.loadData();
        if (columnNames.length) {
            return columnNames;
        }
        const defs = header.split(/\n|\r\n|\r/).filter(f => !!f);
        const defline = defs[defs.length - 1];
        return (defline === null || defline === void 0 ? void 0 : defline.includes('\t'))
            ? defline
                .slice(1)
                .split('\t')
                .map(field => field.trim())
            : undefined;
    }
    async loadFeatureIntervalTreeHelper(refName) {
        const { colRef, colStart, colEnd, features, parser, scoreColumn } = await this.loadData();
        const lines = features[refName];
        if (!lines) {
            return undefined;
        }
        const names = await this.getNames();
        const intervalTree = new interval_tree_1.default();
        const ret = lines.map((f, i) => {
            const uniqueId = `${this.id}-${refName}-${i}`;
            return (0, util_1.featureData)(f, colRef, colStart, colEnd, scoreColumn, parser, uniqueId, names);
        });
        for (let i = 0; i < ret.length; i++) {
            const obj = ret[i];
            intervalTree.insert([obj.get('start'), obj.get('end')], obj);
        }
        return intervalTree;
    }
    async loadFeatureIntervalTree(refName) {
        if (!this.intervalTrees[refName]) {
            this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(refName).catch(e => {
                this.intervalTrees[refName] = undefined;
                throw e;
            });
        }
        return this.intervalTrees[refName];
    }
    getFeatures(query, opts = {}) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const { start, end, refName } = query;
            const intervalTree = await this.loadFeatureIntervalTree(refName);
            intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]).forEach(f => observer.next(f));
            observer.complete();
        }, opts.signal);
    }
    freeResources() { }
}
exports.default = BedAdapter;
BedAdapter.capabilities = ['getFeatures', 'getRefNames'];
//# sourceMappingURL=BedAdapter.js.map