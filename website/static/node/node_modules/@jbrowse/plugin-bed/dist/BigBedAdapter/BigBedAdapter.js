"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const bbi_1 = require("@gmod/bbi");
const bed_1 = __importDefault(require("@gmod/bed"));
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const simpleFeature_1 = __importDefault(require("@jbrowse/core/util/simpleFeature"));
const operators_1 = require("rxjs/operators");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("../util");
function isUCSC(f) {
    return f.get('thickStart') && f.get('blockCount') && f.get('strand') !== 0;
}
class BigBedAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    async configurePre(opts) {
        const bigbed = new bbi_1.BigBed({
            filehandle: (0, io_1.openLocation)((0, configuration_1.readConfObject)(this.config, 'bigBedLocation'), this.pluginManager),
        });
        const header = await bigbed.getHeader(opts);
        const parser = new bed_1.default({ autoSql: header.autoSql });
        return { bigbed, header, parser };
    }
    async configure(opts) {
        if (!this.cached) {
            this.cached = this.configurePre(opts).catch(e => {
                this.cached = undefined;
                throw e;
            });
        }
        return this.cached;
    }
    async getRefNames(opts) {
        const { header } = await this.configure(opts);
        return Object.keys(header.refsByName);
    }
    async getHeader(opts) {
        const { parser, header } = await this.configure(opts);
        const { version, fileType } = header;
        const { fields, ...rest } = parser.autoSql;
        return {
            version,
            fileType,
            autoSql: { ...rest },
            fields: Object.fromEntries(fields.map(({ name, comment }) => [name, comment])),
        };
    }
    getFeatures(region, opts = {}) {
        const { refName, start, end } = region;
        const { signal } = opts;
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            try {
                const { parser, bigbed } = await this.configure(opts);
                const ob = await bigbed.getFeatureStream(refName, start, end, {
                    signal,
                    basesPerSpan: end - start,
                });
                ob.pipe((0, operators_1.mergeAll)(), (0, operators_1.map)(r => {
                    const data = parser.parseLine(`${refName}\t${r.start}\t${r.end}\t${r.rest}`, {
                        uniqueId: r.uniqueId,
                    });
                    const { blockCount, blockSizes, blockStarts, chromStarts } = data;
                    if (blockCount) {
                        const starts = chromStarts || blockStarts || [];
                        const sizes = blockSizes;
                        const blocksOffset = r.start;
                        data.subfeatures = [];
                        for (let b = 0; b < blockCount; b += 1) {
                            const bmin = (starts[b] || 0) + blocksOffset;
                            const bmax = bmin + (sizes[b] || 0);
                            data.subfeatures.push({
                                uniqueId: `${r.uniqueId}-${b}`,
                                start: bmin,
                                end: bmax,
                                type: 'block',
                            });
                        }
                    }
                    if (r.uniqueId === undefined) {
                        throw new Error('invalid bbi feature');
                    }
                    const { chromStart, chromEnd, chrom, ...rest } = data;
                    const f = new simpleFeature_1.default({
                        id: `${this.id}-${r.uniqueId}`,
                        data: {
                            ...rest,
                            start: r.start,
                            end: r.end,
                            refName,
                        },
                    });
                    // collection of heuristics for suggesting that this feature
                    // should be converted to a gene, CNV bigbed has many gene like
                    // features including thickStart and blockCount but no strand
                    return isUCSC(f) ? (0, util_1.ucscProcessedTranscript)(f) : f;
                })).subscribe(observer);
            }
            catch (e) {
                observer.error(e);
            }
        }, opts.signal);
    }
    freeResources() { }
}
exports.default = BigBedAdapter;
//# sourceMappingURL=BigBedAdapter.js.map