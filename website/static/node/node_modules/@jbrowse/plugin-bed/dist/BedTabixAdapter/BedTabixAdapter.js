"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bed_1 = __importDefault(require("@gmod/bed"));
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const tabix_1 = require("@gmod/tabix");
const util_1 = require("../util");
class BedTabixAdapter extends BaseAdapter_1.BaseFeatureDataAdapter {
    constructor(config, getSubAdapter, pluginManager) {
        super(config, getSubAdapter, pluginManager);
        const bedGzLoc = this.getConf('bedGzLocation');
        const type = this.getConf(['index', 'indexType']);
        const loc = this.getConf(['index', 'location']);
        const autoSql = this.getConf('autoSql');
        const pm = this.pluginManager;
        this.bed = new tabix_1.TabixIndexedFile({
            filehandle: (0, io_1.openLocation)(bedGzLoc, pm),
            csiFilehandle: type === 'CSI' ? (0, io_1.openLocation)(loc, pm) : undefined,
            tbiFilehandle: type !== 'CSI' ? (0, io_1.openLocation)(loc, pm) : undefined,
            chunkCacheSize: 50 * 2 ** 20,
        });
        this.columnNames = this.getConf('columnNames');
        this.scoreColumn = this.getConf('scoreColumn');
        this.parser = new bed_1.default({ autoSql });
    }
    async getRefNames(opts = {}) {
        return this.bed.getReferenceSequenceNames(opts);
    }
    async getHeader() {
        return this.bed.getHeader();
    }
    async getNames() {
        if (this.columnNames.length) {
            return this.columnNames;
        }
        const header = await this.bed.getHeader();
        const defs = header.split(/\n|\r\n|\r/).filter(f => !!f);
        const defline = defs[defs.length - 1];
        return (defline === null || defline === void 0 ? void 0 : defline.includes('\t'))
            ? defline
                .slice(1)
                .split('\t')
                .map(f => f.trim())
            : undefined;
    }
    getFeatures(query, opts = {}) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const meta = await this.bed.getMetadata();
            const { columnNumbers } = meta;
            const colRef = columnNumbers.ref - 1;
            const colStart = columnNumbers.start - 1;
            const colEnd = columnNumbers.end - 1;
            // colSame handles special case for tabix where a single column is both
            // the start and end, this is assumed to be covering the base at this
            // position (e.g. tabix -s 1 -b 2 -e 2) begin and end are same
            const names = await this.getNames();
            await this.bed.getLines(query.refName, query.start, query.end, {
                lineCallback: (line, fileOffset) => {
                    observer.next((0, util_1.featureData)(line, colRef, colStart, colEnd, this.scoreColumn, this.parser, `${this.id}-${fileOffset}`, names));
                },
                signal: opts.signal,
            });
            observer.complete();
        }, opts.signal);
    }
    freeResources() { }
}
exports.default = BedTabixAdapter;
BedTabixAdapter.capabilities = ['getFeatures', 'getRefNames'];
//# sourceMappingURL=BedTabixAdapter.js.map