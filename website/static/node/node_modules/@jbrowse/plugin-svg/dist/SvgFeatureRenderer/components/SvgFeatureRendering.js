"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const layouts_1 = require("@jbrowse/core/util/layouts");
const FeatureGlyph_1 = __importDefault(require("./FeatureGlyph"));
const SvgOverlay_1 = __importDefault(require("./SvgOverlay"));
const util_2 = require("./util");
// used to make features have a little padding for their labels
const namePadding = 2;
const textPadding = 2;
// used so that user can click-away-from-feature below the laid out features
// (issue #1248)
const svgHeightPadding = 100;
function RenderedFeatureGlyph(props) {
    const { feature, detectRerender, bpPerPx, region, config, displayMode, layout, extraGlyphs, } = props;
    // used for unit testing, difficult to mock out so it is in actual source code
    detectRerender === null || detectRerender === void 0 ? void 0 : detectRerender();
    const { reversed } = region;
    const start = feature.get(reversed ? 'end' : 'start');
    const startPx = (0, util_1.bpToPx)(start, region, bpPerPx);
    const labelsAllowed = displayMode !== 'compact' && displayMode !== 'collapsed';
    const rootLayout = new layouts_1.SceneGraph('root', 0, 0, 0, 0);
    const GlyphComponent = (0, util_2.chooseGlyphComponent)(feature, extraGlyphs);
    const featureLayout = (GlyphComponent.layOut || util_2.layOut)({
        layout: rootLayout,
        feature,
        bpPerPx,
        reversed,
        config,
        extraGlyphs,
    });
    let shouldShowName = false;
    let shouldShowDescription = false;
    let name = '';
    let description = '';
    let fontHeight = 0;
    let expansion = 0;
    if (labelsAllowed) {
        const showLabels = (0, configuration_1.readConfObject)(config, 'showLabels');
        const showDescriptions = (0, configuration_1.readConfObject)(config, 'showDescriptions');
        fontHeight = (0, configuration_1.readConfObject)(config, ['labels', 'fontSize'], { feature });
        expansion = (0, configuration_1.readConfObject)(config, 'maxFeatureGlyphExpansion') || 0;
        name = String((0, configuration_1.readConfObject)(config, ['labels', 'name'], { feature }) || '');
        shouldShowName = /\S/.test(name) && showLabels;
        const getWidth = (text) => {
            const glyphWidth = rootLayout.width + expansion;
            const textWidth = (0, util_1.measureText)(text, fontHeight);
            return Math.round(Math.min(textWidth, glyphWidth)) + namePadding;
        };
        description = String((0, configuration_1.readConfObject)(config, ['labels', 'description'], { feature }) || '');
        shouldShowDescription =
            /\S/.test(description) && showLabels && showDescriptions;
        if (shouldShowName) {
            rootLayout.addChild('nameLabel', 0, featureLayout.bottom + textPadding, getWidth(name), fontHeight);
        }
        if (shouldShowDescription) {
            const aboveLayout = shouldShowName
                ? rootLayout.getSubRecord('nameLabel')
                : featureLayout;
            rootLayout.addChild('descriptionLabel', 0, aboveLayout.bottom + textPadding, getWidth(description), fontHeight);
        }
    }
    const topPx = layout.addRect(feature.id(), feature.get('start'), feature.get('start') + rootLayout.width * bpPerPx, rootLayout.height);
    if (topPx === null) {
        return null;
    }
    rootLayout.move(startPx, topPx);
    return (react_1.default.createElement(FeatureGlyph_1.default, { rootLayout: rootLayout, name: name, shouldShowName: shouldShowName, description: description, shouldShowDescription: shouldShowDescription, fontHeight: fontHeight, allowedWidthExpansion: expansion, reversed: region.reversed, topLevel: true, ...props }));
}
const RenderedFeatures = (0, mobx_react_1.observer)((props) => {
    const { features = new Map(), isFeatureDisplayed } = props;
    return (react_1.default.createElement(react_1.default.Fragment, null, [...features.values()]
        .filter(feature => isFeatureDisplayed ? isFeatureDisplayed(feature) : true)
        .map(feature => (react_1.default.createElement(RenderedFeatureGlyph, { key: feature.id(), feature: feature, ...props })))));
});
function SvgFeatureRendering(props) {
    const { layout, blockKey, regions, bpPerPx, config, displayModel = {}, exportSVG, featureDisplayHandler, onMouseOut, onMouseDown, onMouseLeave, onMouseEnter, onMouseOver, onMouseMove, onMouseUp, onClick, } = props;
    const [region] = regions || [];
    const width = (region.end - region.start) / bpPerPx;
    const displayMode = (0, configuration_1.readConfObject)(config, 'displayMode');
    const ref = (0, react_1.useRef)(null);
    const [mouseIsDown, setMouseIsDown] = (0, react_1.useState)(false);
    const [height, setHeight] = (0, react_1.useState)(0);
    const [movedDuringLastMouseDown, setMovedDuringLastMouseDown] = (0, react_1.useState)(false);
    const mouseDown = (0, react_1.useCallback)((event) => {
        setMouseIsDown(true);
        setMovedDuringLastMouseDown(false);
        return onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(event);
    }, [onMouseDown]);
    const mouseUp = (0, react_1.useCallback)((event) => {
        setMouseIsDown(false);
        return onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(event);
    }, [onMouseUp]);
    const mouseMove = (0, react_1.useCallback)((event) => {
        var _a;
        if (!ref.current) {
            return;
        }
        if (mouseIsDown) {
            setMovedDuringLastMouseDown(true);
        }
        const { left, top } = ref.current.getBoundingClientRect();
        const offsetX = event.clientX - left;
        const offsetY = event.clientY - top;
        const px = region.reversed ? width - offsetX : offsetX;
        const clientBp = region.start + bpPerPx * px;
        const featureIdCurrentlyUnderMouse = (_a = displayModel.getFeatureOverlapping) === null || _a === void 0 ? void 0 : _a.call(displayModel, blockKey, clientBp, offsetY);
        if (onMouseMove) {
            onMouseMove(event, featureIdCurrentlyUnderMouse);
        }
    }, [
        blockKey,
        bpPerPx,
        mouseIsDown,
        onMouseMove,
        region.reversed,
        region.start,
        displayModel,
        width,
    ]);
    const click = (0, react_1.useCallback)((event) => {
        // don't select a feature if we are clicking and dragging
        if (movedDuringLastMouseDown) {
            return;
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
    }, [movedDuringLastMouseDown, onClick]);
    (0, react_1.useEffect)(() => {
        setHeight(layout.getTotalHeight());
    }, [layout]);
    if (exportSVG) {
        return (react_1.default.createElement(RenderedFeatures, { displayMode: displayMode, isFeatureDisplayed: featureDisplayHandler, region: region, ...props }));
    }
    return (react_1.default.createElement("svg", { ref: ref, "data-testid": "svgfeatures", width: width, height: height + svgHeightPadding, onMouseDown: mouseDown, onMouseUp: mouseUp, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onMouseOver: onMouseOver, onMouseOut: onMouseOut, onMouseMove: mouseMove, onClick: click },
        react_1.default.createElement(RenderedFeatures, { displayMode: displayMode, region: region, movedDuringLastMouseDown: movedDuringLastMouseDown, isFeatureDisplayed: featureDisplayHandler, ...props }),
        react_1.default.createElement(SvgOverlay_1.default, { ...props, region: region, movedDuringLastMouseDown: movedDuringLastMouseDown })));
}
exports.default = (0, mobx_react_1.observer)(SvgFeatureRendering);
//# sourceMappingURL=SvgFeatureRendering.js.map