"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUTR = exports.layOutSubfeatures = exports.layOutFeature = exports.layOut = exports.chooseGlyphComponent = void 0;
const configuration_1 = require("@jbrowse/core/configuration");
const Box_1 = __importDefault(require("./Box"));
const ProcessedTranscript_1 = __importDefault(require("./ProcessedTranscript"));
const Segments_1 = __importDefault(require("./Segments"));
const Subfeatures_1 = __importDefault(require("./Subfeatures"));
function chooseGlyphComponent(feature, extraGlyphs) {
    var _a;
    const type = feature.get('type');
    const subfeatures = feature.get('subfeatures');
    if (subfeatures && type !== 'CDS') {
        const hasSubSub = subfeatures.find(sub => !!sub.get('subfeatures'));
        if (['mRNA', 'transcript', 'primary_transcript'].includes(type) &&
            subfeatures.find(f => f.get('type') === 'CDS')) {
            return ProcessedTranscript_1.default;
        }
        else if (!feature.parent() && hasSubSub) {
            // only do sub-sub on parent level features like gene
            return Subfeatures_1.default;
        }
        else {
            return Segments_1.default;
        }
    }
    return ((_a = extraGlyphs === null || extraGlyphs === void 0 ? void 0 : extraGlyphs.find(f => f.validator(feature))) === null || _a === void 0 ? void 0 : _a.glyph) || Box_1.default;
}
exports.chooseGlyphComponent = chooseGlyphComponent;
function layOut({ layout, feature, bpPerPx, reversed, config, extraGlyphs, }) {
    const displayMode = (0, configuration_1.readConfObject)(config, 'displayMode');
    const subLayout = layOutFeature({
        layout,
        feature,
        bpPerPx,
        reversed,
        config,
        extraGlyphs,
    });
    if (displayMode !== 'reducedRepresentation') {
        layOutSubfeatures({
            layout: subLayout,
            subfeatures: feature.get('subfeatures') || [],
            bpPerPx,
            reversed,
            config,
            extraGlyphs,
        });
    }
    return subLayout;
}
exports.layOut = layOut;
function layOutFeature(args) {
    const { layout, feature, bpPerPx, reversed, config, extraGlyphs } = args;
    const displayMode = (0, configuration_1.readConfObject)(config, 'displayMode');
    const GlyphComponent = displayMode === 'reducedRepresentation'
        ? Box_1.default
        : chooseGlyphComponent(feature, extraGlyphs);
    const parentFeature = feature.parent();
    let x = 0;
    if (parentFeature) {
        x =
            (reversed
                ? parentFeature.get('end') - feature.get('end')
                : feature.get('start') - parentFeature.get('start')) / bpPerPx;
    }
    const height = (0, configuration_1.readConfObject)(config, 'height', { feature });
    const width = (feature.get('end') - feature.get('start')) / bpPerPx;
    const layoutParent = layout.parent;
    const top = layoutParent ? layoutParent.top : 0;
    const subLayout = layout.addChild(String(feature.id()), x, displayMode === 'collapse' ? 0 : top, Math.max(width, 1), // has to be at least one to register in the layout
    displayMode === 'compact' ? height / 2 : height, { GlyphComponent });
    return subLayout;
}
exports.layOutFeature = layOutFeature;
function layOutSubfeatures(args) {
    const { layout, subfeatures, bpPerPx, reversed, config, extraGlyphs } = args;
    subfeatures.forEach(feature => {
        ;
        (chooseGlyphComponent(feature, extraGlyphs).layOut || layOut)({
            layout,
            feature,
            bpPerPx,
            reversed,
            config,
            extraGlyphs,
        });
    });
}
exports.layOutSubfeatures = layOutSubfeatures;
function isUTR(feature) {
    return /(\bUTR|_UTR|untranslated[_\s]region)\b/.test(feature.get('type') || '');
}
exports.isUTR = isUTR;
//# sourceMappingURL=util.js.map