"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const react_1 = __importDefault(require("react"));
const color_1 = require("@jbrowse/core/util/color");
const ui_1 = require("@jbrowse/core/ui");
const mobx_react_1 = require("mobx-react");
const util_1 = require("@jbrowse/core/util");
function Translation(props) {
    const { codonTable, seq, frame, bpPerPx, region, height, y, reverse = false, theme, } = props;
    const scale = bpPerPx;
    // the tilt variable normalizes the frame to where we are starting from,
    // which increases consistency across blocks
    const tilt = 3 - (region.start % 3);
    // the effectiveFrame incorporates tilt and the frame to say what the
    // effective frame that is plotted. The +3 is for when frame is -2 and this
    // can otherwise result in effectiveFrame -1
    const effectiveFrame = (frame + tilt + 3) % 3;
    const seqSliced = seq.slice(effectiveFrame);
    const translated = [];
    for (let i = 0; i < seqSliced.length; i += 3) {
        const codon = seqSliced.slice(i, i + 3);
        const normalizedCodon = reverse ? (0, util_1.revcom)(codon) : codon;
        const aminoAcid = codonTable[normalizedCodon] || '';
        translated.push({ letter: aminoAcid, codon: normalizedCodon.toUpperCase() });
    }
    const w = (1 / scale) * 3;
    const drop = region.start === 0 ? 0 : w;
    const render = 1 / bpPerPx >= 12;
    const width = (region.end - region.start) / bpPerPx;
    const map = ['#d8d8d8', '#adadad', '#8f8f8f'].reverse();
    return (react_1.default.createElement(react_1.default.Fragment, null, translated.map((element, index) => {
        const x = region.reversed
            ? width - (w * (index + 1) + effectiveFrame / scale - drop)
            : w * index + effectiveFrame / scale - drop;
        const { letter, codon } = element;
        return (react_1.default.createElement(react_1.default.Fragment, { key: `${index}-${letter}` },
            react_1.default.createElement("rect", { x: x, y: y, width: render ? w : w + 0.7 /* small fudge factor when zoomed out*/, height: height, stroke: render ? '#555' : 'none', fill: util_1.defaultStarts.includes(codon)
                    ? theme.palette.startCodon
                    : util_1.defaultStops.includes(codon)
                        ? theme.palette.stopCodon
                        : map[Math.abs(frame)] }),
            render ? (react_1.default.createElement("text", { x: x + w / 2, y: y + height / 2, dominantBaseline: "middle", textAnchor: "middle" }, letter)) : null));
    })));
}
function DNA(props) {
    const { bpPerPx, region, feature, theme, height, seq, y } = props;
    const render = 1 / bpPerPx >= 12;
    const [leftPx, rightPx] = (0, util_1.bpSpanPx)(feature.get('start'), feature.get('end'), region, bpPerPx);
    const reverse = region.reversed;
    const len = feature.get('end') - feature.get('start');
    const w = Math.max((rightPx - leftPx) / len, 0.8);
    return (react_1.default.createElement(react_1.default.Fragment, null, seq.split('').map((letter, index) => {
        const color = theme.palette.bases[letter.toUpperCase()];
        const x = reverse ? rightPx - (index + 1) * w : leftPx + index * w;
        return (react_1.default.createElement(react_1.default.Fragment, { key: index },
            react_1.default.createElement("rect", { x: x, y: y, width: w, height: height, fill: color ? color.main : '#aaa', stroke: render ? '#555' : 'none' }),
            render ? (react_1.default.createElement("text", { x: x + w / 2, y: y + height / 2, dominantBaseline: "middle", textAnchor: "middle", fill: color ? (0, color_1.contrastingTextColor)(color.main) : 'black' }, letter)) : null));
    })));
}
const SequenceSVG = ({ regions, theme: configTheme, features = new Map(), showReverse, showForward, showTranslation, bpPerPx, }) => {
    const [region] = regions;
    const theme = (0, ui_1.createJBrowseTheme)(configTheme);
    const codonTable = (0, util_1.generateCodonTable)(util_1.defaultCodonTable);
    const height = 20;
    const [feature] = [...features.values()];
    if (!feature) {
        return null;
    }
    const seq = feature.get('seq');
    if (!seq) {
        return null;
    }
    // incrementer for the y-position of the current sequence being rendered
    // (applies to both translation rows and dna rows)
    let currY = -20;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        showTranslation && (region.reversed ? showReverse : showForward)
            ? [2, 1, 0].map(index => (react_1.default.createElement(Translation, { key: `translation-${index}`, seq: seq, y: (currY += 20), codonTable: codonTable, frame: index, bpPerPx: bpPerPx, region: region, theme: theme, height: height, reverse: region.reversed })))
            : null,
        showForward ? (react_1.default.createElement(DNA, { height: height, y: (currY += 20), feature: feature, region: region, seq: region.reversed ? (0, util_1.complement)(seq) : seq, bpPerPx: bpPerPx, theme: theme })) : null,
        showReverse ? (react_1.default.createElement(DNA, { height: height, y: (currY += 20), feature: feature, region: region, seq: region.reversed ? seq : (0, util_1.complement)(seq), bpPerPx: bpPerPx, theme: theme })) : null,
        showTranslation && (region.reversed ? showForward : showReverse)
            ? [0, -1, -2].map(index => (react_1.default.createElement(Translation, { key: `rev-translation-${index}`, seq: seq, y: (currY += 20), codonTable: codonTable, frame: index, bpPerPx: bpPerPx, region: region, theme: theme, height: height, reverse: !region.reversed })))
            : null));
};
const Wrapper = ({ exportSVG, width, totalHeight, children }) => {
    return exportSVG ? (react_1.default.createElement(react_1.default.Fragment, null, children)) : (react_1.default.createElement("svg", { "data-testid": "sequence_track", width: width, height: totalHeight, style: { width, height: totalHeight } }, children));
};
function Sequence(props) {
    const { regions, bpPerPx } = props;
    const [region] = regions;
    const width = (region.end - region.start) / bpPerPx;
    const totalHeight = 200;
    return (react_1.default.createElement(Wrapper, { ...props, totalHeight: totalHeight, width: width },
        react_1.default.createElement(SequenceSVG, { ...props })));
}
exports.default = (0, mobx_react_1.observer)(Sequence);
//# sourceMappingURL=DivSequenceRendering.js.map