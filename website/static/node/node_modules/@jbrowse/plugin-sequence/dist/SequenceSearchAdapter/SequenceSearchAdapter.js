"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const util_1 = require("@jbrowse/core/util");
const operators_1 = require("rxjs/operators");
class default_1 extends BaseAdapter_1.BaseFeatureDataAdapter {
    async configure() {
        var _a;
        const adapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, this.getConf('sequenceAdapter')));
        if (!adapter) {
            throw new Error('Error getting subadapter');
        }
        return adapter.dataAdapter;
    }
    async getRefNames() {
        const adapter = await this.configure();
        return adapter.getRefNames();
    }
    getFeatures(query, opts) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            var _a;
            const sequenceAdapter = await this.configure();
            const hw = 1000;
            let { start: queryStart, end: queryEnd } = query;
            queryStart = Math.max(0, queryStart - hw);
            queryEnd += hw;
            if (queryEnd < 0 || queryStart > queryEnd) {
                observer.complete();
                return;
            }
            const ret = sequenceAdapter.getFeatures({
                ...query,
                start: queryStart,
                end: queryEnd,
            }, opts);
            const feats = await ret.pipe((0, operators_1.toArray)()).toPromise();
            const residues = ((_a = feats[0]) === null || _a === void 0 ? void 0 : _a.get('seq')) || '';
            const search = this.getConf('search');
            const searchFoward = this.getConf('searchForward');
            const searchReverse = this.getConf('searchReverse');
            const caseInsensitive = this.getConf('caseInsensitive');
            const re = new RegExp(search, 'g' + (caseInsensitive ? 'i' : ''));
            if (search) {
                if (searchFoward) {
                    const matches = residues.matchAll(re);
                    for (const match of matches) {
                        const s = queryStart + (match.index || 0);
                        if ((0, util_1.doesIntersect2)(s, s + search.length, query.start, query.end)) {
                            observer.next(new util_1.SimpleFeature({
                                uniqueId: `${this.id}-match-${s}-p`,
                                refName: query.refName,
                                start: s,
                                end: s + match[0].length,
                                name: match[0],
                                strand: 1,
                            }));
                        }
                    }
                }
                if (searchReverse) {
                    const matches = (0, util_1.revcom)(residues).matchAll(re);
                    for (const match of matches) {
                        const s = queryEnd - (match.index || 0);
                        if ((0, util_1.doesIntersect2)(s, s + search.length, query.start, query.end)) {
                            observer.next(new util_1.SimpleFeature({
                                uniqueId: `${this.id}-match-${s}-n`,
                                refName: query.refName,
                                start: s - match[0].length,
                                name: match[0],
                                end: s,
                                strand: -1,
                            }));
                        }
                    }
                }
            }
            observer.complete();
        });
    }
    freeResources() { }
}
exports.default = default_1;
//# sourceMappingURL=SequenceSearchAdapter.js.map