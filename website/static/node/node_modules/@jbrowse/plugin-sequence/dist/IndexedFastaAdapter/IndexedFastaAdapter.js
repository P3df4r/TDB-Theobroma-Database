"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const indexedfasta_1 = require("@gmod/indexedfasta");
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const util_1 = require("@jbrowse/core/util");
const abortable_promise_cache_1 = __importDefault(require("abortable-promise-cache"));
const QuickLRU_1 = __importDefault(require("@jbrowse/core/util/QuickLRU"));
class default_1 extends BaseAdapter_1.BaseSequenceAdapter {
    constructor() {
        super(...arguments);
        this.seqCache = new abortable_promise_cache_1.default({
            cache: new QuickLRU_1.default({ maxSize: 200 }),
            fill: async (args, signal) => {
                const { refName, start, end, fasta } = args;
                return fasta.getSequence(refName, start, end, { ...args, signal });
            },
        });
    }
    async getRefNames(opts) {
        const { fasta } = await this.setup();
        return fasta.getSequenceNames(opts);
    }
    async getRegions(opts) {
        const { fasta } = await this.setup();
        const seqSizes = await fasta.getSequenceSizes(opts);
        return Object.keys(seqSizes).map(refName => ({
            refName,
            start: 0,
            end: seqSizes[refName],
        }));
    }
    async setupPre() {
        const fastaLocation = this.getConf('fastaLocation');
        const faiLocation = this.getConf('faiLocation');
        return {
            fasta: new indexedfasta_1.IndexedFasta({
                fasta: (0, io_1.openLocation)(fastaLocation, this.pluginManager),
                fai: (0, io_1.openLocation)(faiLocation, this.pluginManager),
            }),
        };
    }
    async getHeader() {
        const loc = this.getConf('metadataLocation');
        return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'
            ? null
            : (0, io_1.openLocation)(loc).readFile('utf8');
    }
    async setup() {
        if (!this.setupP) {
            this.setupP = this.setupPre().catch(e => {
                this.setupP = undefined;
                throw e;
            });
        }
        return this.setupP;
    }
    getFeatures(region, opts) {
        const { refName, start, end } = region;
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const { fasta } = await this.setup();
            const size = await fasta.getSequenceSize(refName, opts);
            const regionEnd = size !== undefined ? Math.min(size, end) : end;
            const chunks = [];
            const chunkSize = 128000;
            const s = start - (start % chunkSize);
            const e = end + (chunkSize - (end % chunkSize));
            for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {
                const r = {
                    refName,
                    start: chunkStart,
                    end: chunkStart + chunkSize,
                };
                chunks.push(this.seqCache.get(JSON.stringify(r), { ...r, fasta }, opts === null || opts === void 0 ? void 0 : opts.signal));
            }
            const seq = (await Promise.all(chunks))
                .join('')
                .slice(start - s)
                .slice(0, end - start);
            if (seq) {
                observer.next(new util_1.SimpleFeature({
                    id: `${refName} ${start}-${regionEnd}`,
                    data: { refName, start, end: regionEnd, seq },
                }));
            }
            observer.complete();
        });
    }
    /**
     * called to provide a hint that data tied to a certain region
     * will not be needed for the forseeable future and can be purged
     * from caches, etc
     */
    freeResources( /* { region } */) { }
}
exports.default = default_1;
//# sourceMappingURL=IndexedFastaAdapter.js.map