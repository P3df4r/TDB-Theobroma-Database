"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreGetFeatureDetails = exports.CoreRender = exports.CoreEstimateRegionStats = exports.CoreFreeResources = exports.CoreGetFeatures = exports.CoreGetMetadata = exports.CoreGetFileInfo = exports.CoreGetRefNames = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const operators_1 = require("rxjs/operators");
const dataAdapterCache_1 = require("../data_adapters/dataAdapterCache");
const RpcMethodType_1 = __importDefault(require("../pluggableElementTypes/RpcMethodType"));
const ServerSideRendererType_1 = __importDefault(require("../pluggableElementTypes/renderers/ServerSideRendererType"));
const BaseAdapter_1 = require("../data_adapters/BaseAdapter");
const util_1 = require("../util");
const simpleFeature_1 = __importDefault(require("../util/simpleFeature"));
class CoreGetRefNames extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreGetRefNames';
    }
    async execute(args, rpcDriver) {
        const pm = this.pluginManager;
        const deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        const { sessionId, adapterConfig } = deserializedArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        if ((0, BaseAdapter_1.isFeatureAdapter)(dataAdapter)) {
            return dataAdapter.getRefNames(deserializedArgs);
        }
        return [];
    }
}
exports.CoreGetRefNames = CoreGetRefNames;
class CoreGetFileInfo extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreGetInfo';
    }
    async execute(args, rpcDriver) {
        const pm = this.pluginManager;
        const deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        const { sessionId, adapterConfig } = deserializedArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        return (0, BaseAdapter_1.isFeatureAdapter)(dataAdapter)
            ? dataAdapter.getHeader(deserializedArgs)
            : null;
    }
}
exports.CoreGetFileInfo = CoreGetFileInfo;
class CoreGetMetadata extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreGetMetadata';
    }
    async execute(args, rpcDriver) {
        const pm = this.pluginManager;
        const deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        const { sessionId, adapterConfig } = deserializedArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        return (0, BaseAdapter_1.isFeatureAdapter)(dataAdapter)
            ? dataAdapter.getMetadata(deserializedArgs)
            : null;
    }
}
exports.CoreGetMetadata = CoreGetMetadata;
class CoreGetFeatures extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreGetFeatures';
    }
    async deserializeReturn(feats, args, rpcDriver) {
        const superDeserialized = (await super.deserializeReturn(feats, args, rpcDriver));
        return superDeserialized.map(feat => new simpleFeature_1.default(feat));
    }
    async serializeArguments(args, rpcDriver) {
        const { rootModel } = this.pluginManager;
        const assemblyManager = rootModel.session.assemblyManager;
        const renamedArgs = await (0, util_1.renameRegionsIfNeeded)(assemblyManager, args);
        return super.serializeArguments(renamedArgs, rpcDriver);
    }
    async execute(args, rpcDriver) {
        const pm = this.pluginManager;
        const deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        const { signal, sessionId, adapterConfig, regions, opts } = deserializedArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        if (!(0, BaseAdapter_1.isFeatureAdapter)(dataAdapter)) {
            throw new Error('Adapter does not support retrieving features');
        }
        const ret = dataAdapter.getFeaturesInMultipleRegions(regions, {
            ...opts,
            signal,
        });
        const r = await ret.pipe((0, operators_1.toArray)()).toPromise();
        return r.map(f => f.toJSON());
    }
}
exports.CoreGetFeatures = CoreGetFeatures;
/**
 * free up any resources (e.g. cached adapter objects)
 * that are only associated with the given track ID.
 *
 * returns number of objects deleted
 */
class CoreFreeResources extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreFreeResources';
    }
    async execute(specification) {
        let deleteCount = 0;
        deleteCount += (0, dataAdapterCache_1.freeAdapterResources)(specification);
        // pass the freeResources hint along to all the renderers as well
        this.pluginManager.getRendererTypes().forEach(renderer => {
            const count = renderer.freeResources( /* specification */);
            if (count) {
                deleteCount += count;
            }
        });
        return deleteCount;
    }
    async serializeArguments(args, _rpcDriver) {
        return args;
    }
}
exports.CoreFreeResources = CoreFreeResources;
class CoreEstimateRegionStats extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreEstimateRegionStats';
    }
    async serializeArguments(args, rpcDriver) {
        var _a;
        const { rootModel } = this.pluginManager;
        const assemblyManager = rootModel.session.assemblyManager;
        const renamedArgs = await (0, util_1.renameRegionsIfNeeded)(assemblyManager, {
            ...args,
            filters: (_a = args.filters) === null || _a === void 0 ? void 0 : _a.toJSON().filters,
        });
        return super.serializeArguments(renamedArgs, rpcDriver);
    }
    async execute(args, rpcDriver) {
        const pm = this.pluginManager;
        const deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        const { adapterConfig, sessionId, regions } = deserializedArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        if (!(0, BaseAdapter_1.isFeatureAdapter)(dataAdapter)) {
            throw new Error('Adapter does not support retrieving features');
        }
        return dataAdapter.estimateRegionsStats(regions, deserializedArgs);
    }
}
exports.CoreEstimateRegionStats = CoreEstimateRegionStats;
/**
 * fetches features from an adapter and call a renderer with them
 */
class CoreRender extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreRender';
    }
    async serializeArguments(args, rpcDriver) {
        const { rootModel } = this.pluginManager;
        const assemblyManager = rootModel.session.assemblyManager;
        const renamedArgs = await (0, util_1.renameRegionsIfNeeded)(assemblyManager, args);
        const superArgs = (await super.serializeArguments(renamedArgs, rpcDriver));
        if (rpcDriver === 'MainThreadRpcDriver') {
            return superArgs;
        }
        const { rendererType } = args;
        const RendererType = validateRendererType(rendererType, this.pluginManager.getRendererType(rendererType));
        return RendererType.serializeArgsInClient(superArgs);
    }
    async execute(args, rpcDriver) {
        let deserializedArgs = args;
        if (rpcDriver !== 'MainThreadRpcDriver') {
            deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        }
        const { sessionId, rendererType, signal } = deserializedArgs;
        if (!sessionId) {
            throw new Error('must pass a unique session id');
        }
        (0, util_1.checkAbortSignal)(signal);
        const RendererType = validateRendererType(rendererType, this.pluginManager.getRendererType(rendererType));
        const result = rpcDriver === 'MainThreadRpcDriver'
            ? await RendererType.render(deserializedArgs)
            : await RendererType.renderInWorker(deserializedArgs);
        (0, util_1.checkAbortSignal)(signal);
        return result;
    }
    async deserializeReturn(serializedReturn, args, rpcDriver) {
        const des = await super.deserializeReturn(serializedReturn, args, rpcDriver);
        if (rpcDriver === 'MainThreadRpcDriver') {
            return des;
        }
        const { rendererType } = args;
        const RendererType = validateRendererType(rendererType, this.pluginManager.getRendererType(rendererType));
        return RendererType.deserializeResultsInClient(des, args);
    }
}
exports.CoreRender = CoreRender;
/**
 * fetches features from an adapter and call a renderer with them
 */
class CoreGetFeatureDetails extends RpcMethodType_1.default {
    constructor() {
        super(...arguments);
        this.name = 'CoreGetFeatureDetails';
    }
    async serializeArguments(args, rpcDriver) {
        const { rootModel } = this.pluginManager;
        const assemblyManager = rootModel.session.assemblyManager;
        const renamedArgs = await (0, util_1.renameRegionsIfNeeded)(assemblyManager, args);
        const superArgs = (await super.serializeArguments(renamedArgs, rpcDriver));
        if (rpcDriver === 'MainThreadRpcDriver') {
            return superArgs;
        }
        const { rendererType } = args;
        const RendererType = validateRendererType(rendererType, this.pluginManager.getRendererType(rendererType));
        return RendererType.serializeArgsInClient(superArgs);
    }
    async execute(args, rpcDriver) {
        let deserializedArgs = args;
        if (rpcDriver !== 'MainThreadRpcDriver') {
            deserializedArgs = await this.deserializeArguments(args, rpcDriver);
        }
        const { rendererType, featureId } = deserializedArgs;
        const RendererType = validateRendererType(rendererType, this.pluginManager.getRendererType(rendererType));
        // @ts-ignore
        const sess = RendererType.sessions[(0, util_1.getLayoutId)(args)];
        const { layout } = sess.cachedLayout;
        const xref = layout.getDataByID(featureId);
        return { feature: xref.toJSON() };
    }
}
exports.CoreGetFeatureDetails = CoreGetFeatureDetails;
function validateRendererType(rendererType, RendererType) {
    if (!RendererType) {
        throw new Error(`renderer "${rendererType}" not found`);
    }
    // @ts-ignore
    if (!RendererType.ReactComponent) {
        throw new Error(`renderer ${rendererType} has no ReactComponent, it may not be completely implemented yet`);
    }
    if (!(RendererType instanceof ServerSideRendererType_1.default)) {
        throw new Error('CoreRender requires a renderer that is a subclass of ServerSideRendererType');
    }
    return RendererType;
}
