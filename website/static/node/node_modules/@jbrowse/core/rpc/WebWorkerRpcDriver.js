"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const librpc_web_mod_1 = __importDefault(require("librpc-web-mod"));
const shortid_1 = __importDefault(require("shortid"));
const serialize_error_1 = require("serialize-error");
// locals
const BaseRpcDriver_1 = __importDefault(require("./BaseRpcDriver"));
class WebWorkerHandle extends librpc_web_mod_1.default.Client {
    destroy() {
        this.workers[0].terminate();
    }
    async call(funcName, args, opts) {
        const { statusCallback, rpcDriverClassName } = opts;
        const channel = `message-${shortid_1.default.generate()}`;
        const listener = (message) => {
            statusCallback === null || statusCallback === void 0 ? void 0 : statusCallback(message);
        };
        this.on(channel, listener);
        const result = await super.call(funcName, { ...args, channel, rpcDriverClassName }, opts);
        this.off(channel, listener);
        return result;
    }
}
class WebWorkerRpcDriver extends BaseRpcDriver_1.default {
    constructor(args, workerBootConfiguration) {
        super(args);
        this.workerBootConfiguration = workerBootConfiguration;
        this.name = 'WebWorkerRpcDriver';
        this.makeWorkerInstance = args.makeWorkerInstance;
    }
    async makeWorker() {
        // note that we are making a Rpc.Client connection with a worker pool of
        // one for each worker, because we want to do our own state-group-aware
        // load balancing rather than using librpc's builtin round-robin
        const instance = this.makeWorkerInstance();
        const worker = new WebWorkerHandle({ workers: [instance] });
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (isSafari) {
            // xref https://github.com/GMOD/jbrowse-components/issues/3245
            // eslint-disable-next-line no-console
            console.log('console logging the webworker handle avoids the track going into an infinite loading state, this is a hacky workaround for safari', instance);
        }
        // send the worker its boot configuration using info from the pluginManager
        return new Promise((resolve, reject) => {
            const listener = (e) => {
                if (e.data.message === 'ready') {
                    resolve(worker);
                    worker.workers[0].removeEventListener('message', listener);
                }
                else if (e.data.message === 'readyForConfig') {
                    worker.workers[0].postMessage({
                        message: 'config',
                        config: this.workerBootConfiguration,
                    });
                }
                else if (e.data.message === 'error') {
                    reject((0, serialize_error_1.deserializeError)(e.data.error));
                }
            };
            worker.workers[0].addEventListener('message', listener);
        });
    }
}
exports.default = WebWorkerRpcDriver;
