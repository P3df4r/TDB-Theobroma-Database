"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWindowPath = exports.isCJSPluginDefinition = exports.isESMPluginDefinition = exports.isUMDPluginDefinition = void 0;
const load_script2_1 = __importDefault(require("load-script2"));
const ReExports_1 = __importDefault(require("./ReExports"));
const util_1 = require("./util");
function isUMDPluginDefinition(def) {
    return ((def.umdUrl !== undefined ||
        def.url !== undefined ||
        def.umdLoc !== undefined) &&
        def.name !== undefined);
}
exports.isUMDPluginDefinition = isUMDPluginDefinition;
function isESMPluginDefinition(def) {
    return (def.esmUrl !== undefined ||
        def.esmLoc !== undefined);
}
exports.isESMPluginDefinition = isESMPluginDefinition;
function isCJSPluginDefinition(def) {
    return def.cjsUrl !== undefined;
}
exports.isCJSPluginDefinition = isCJSPluginDefinition;
function getWindowPath(windowHref) {
    return window.location.href + windowHref;
}
exports.getWindowPath = getWindowPath;
function getGlobalObject() {
    // Based on window-or-global
    // https://github.com/purposeindustries/window-or-global/blob/322abc71de0010c9e5d9d0729df40959e1ef8775/lib/index.js
    return (
    // eslint-disable-next-line no-restricted-globals
    (typeof self === 'object' && self.self === self && self) ||
        (typeof global === 'object' && global.global === global && global) ||
        // @ts-ignore
        this);
}
function isInWebWorker(globalObject) {
    return Boolean('WorkerGlobalScope' in globalObject);
}
class PluginLoader {
    constructor(defs = [], args) {
        this.definitions = [];
        this.fetchESM = args === null || args === void 0 ? void 0 : args.fetchESM;
        this.fetchCJS = args === null || args === void 0 ? void 0 : args.fetchCJS;
        this.definitions = JSON.parse(JSON.stringify(defs));
    }
    async loadScript(scriptUrl) {
        const globalObject = getGlobalObject();
        if (!isInWebWorker(globalObject)) {
            return (0, load_script2_1.default)(scriptUrl);
        }
        // @ts-ignore
        if (globalObject === null || globalObject === void 0 ? void 0 : globalObject.importScripts) {
            // @ts-ignore
            await globalObject.importScripts(scriptUrl);
            return;
        }
        throw new Error('cannot figure out how to load external JS scripts in this environment');
    }
    async loadCJSPlugin(def, windowHref) {
        const parsedUrl = new URL(def.cjsUrl, windowHref);
        if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
            throw new Error(`Cannot load plugins using protocol "${parsedUrl.protocol}"`);
        }
        if (!this.fetchCJS) {
            throw new Error('No fetchCJS callback provided');
        }
        return this.fetchCJS(parsedUrl.href);
    }
    async loadESMPlugin(def, windowHref) {
        var _a;
        const parsedUrl = 'esmUrl' in def
            ? new URL(def.esmUrl, windowHref)
            : new URL(def.esmLoc.uri, def.esmLoc.baseUri);
        if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
            throw new Error(`cannot load plugins using protocol "${parsedUrl.protocol}"`);
        }
        const plugin = (await ((_a = this.fetchESM) === null || _a === void 0 ? void 0 : _a.call(this, parsedUrl.href)));
        if (!plugin) {
            throw new Error(`Could not load ESM plugin: ${parsedUrl}`);
        }
        return plugin;
    }
    async loadUMDPlugin(def, windowHref) {
        const parsedUrl = 'url' in def
            ? new URL(def.url, windowHref)
            : 'umdUrl' in def
                ? new URL(def.umdUrl, windowHref)
                : new URL(def.umdLoc.uri, def.umdLoc.baseUri);
        if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
            throw new Error(`cannot load plugins using protocol "${parsedUrl.protocol}"`);
        }
        await this.loadScript(parsedUrl.href);
        const moduleName = def.name;
        const umdName = `JBrowsePlugin${moduleName}`;
        const globalObject = getGlobalObject();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const plugin = globalObject[umdName];
        if (!plugin) {
            throw new Error(`Failed to load UMD bundle for ${moduleName}, ${globalObject.constructor.name}.${umdName} is undefined`);
        }
        return plugin;
    }
    async loadPlugin(def, windowHref) {
        let plugin;
        if (util_1.isElectron && isCJSPluginDefinition(def)) {
            plugin = await this.loadCJSPlugin(def, windowHref);
        }
        else if (isESMPluginDefinition(def)) {
            plugin = await this.loadESMPlugin(def, windowHref);
        }
        else if (isUMDPluginDefinition(def)) {
            plugin = await this.loadUMDPlugin(def, windowHref);
        }
        else if (!util_1.isElectron && isCJSPluginDefinition(def)) {
            throw new Error(`CommonJS plugin found, but not in a NodeJS environment: ${JSON.stringify(def)}`);
        }
        else {
            throw new Error(`Could not determine plugin type: ${JSON.stringify(def)}`);
        }
        return plugin.default;
    }
    installGlobalReExports(target) {
        // @ts-ignore
        target.JBrowseExports = Object.fromEntries(Object.entries(ReExports_1.default).map(([moduleName, module]) => {
            return [moduleName, module];
        }));
    }
    async load(windowHref = '') {
        return Promise.all(this.definitions.map(async (definition) => ({
            plugin: await this.loadPlugin(definition, windowHref),
            definition,
        })));
    }
}
exports.default = PluginLoader;
