"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const material_1 = require("@mui/material");
const mui_1 = require("tss-react/mui");
const copy_to_clipboard_1 = __importDefault(require("copy-to-clipboard"));
// locals
const SequenceFeatureSettingsDialog_1 = __importDefault(require("./SequenceFeatureSettingsDialog"));
const SequenceHelpDialog_1 = __importDefault(require("./SequenceHelpDialog"));
const SequencePanel_1 = __importDefault(require("./SequencePanel"));
const util_1 = require("../util");
const configuration_1 = require("../configuration");
const ui_1 = require("../ui");
// icons
const Settings_1 = __importDefault(require("@mui/icons-material/Settings"));
const Help_1 = __importDefault(require("@mui/icons-material/Help"));
const useStyles = (0, mui_1.makeStyles)()(theme => ({
    button: {
        margin: theme.spacing(1),
    },
    formControl: {
        margin: 0,
    },
    container: {
        margin: theme.spacing(1),
    },
    container2: {
        marginTop: theme.spacing(1),
    },
}));
const BPLIMIT = 500000;
// display the stitched-together sequence of a gene's CDS, cDNA, or protein
// sequence. this is a best effort and weird genomic phenomena could lead these
// to not be 100% accurate
function SequenceFeatureDetails({ model, feature }) {
    var _a;
    const { classes } = useStyles();
    const parentFeature = feature;
    const hasCDS = !!((_a = parentFeature.subfeatures) === null || _a === void 0 ? void 0 : _a.find(sub => sub.type === 'CDS'));
    const isGene = feature.type === 'gene';
    const seqPanelRef = (0, react_1.useRef)(null);
    const [settingsDlgOpen, setSettingsDlgOpen] = (0, react_1.useState)(false);
    const [shown, setShown] = (0, react_1.useState)(false);
    const [helpShown, setHelpShown] = (0, react_1.useState)(false);
    const [sequence, setSequence] = (0, react_1.useState)();
    const [error, setError] = (0, react_1.useState)();
    const [copied, setCopied] = (0, react_1.useState)(false);
    const [copiedHtml, setCopiedHtml] = (0, react_1.useState)(false);
    const [intronBp, setIntronBp] = (0, util_1.useLocalStorage)('intronBp', 10);
    const [upDownBp, setUpDownBp] = (0, util_1.useLocalStorage)('upDownBp', 500);
    const [forceLoad, setForceLoad] = (0, react_1.useState)({
        id: feature.uniqueId,
        force: false,
    });
    (0, react_1.useEffect)(() => {
        setForceLoad({ id: feature.uniqueId, force: false });
    }, [feature]);
    (0, react_1.useEffect)(() => {
        var _a;
        let finished = false;
        if (!model || !shown) {
            return () => { };
        }
        const { assemblyManager, rpcManager } = (0, util_1.getSession)(model);
        const [assemblyName] = ((_a = model.view) === null || _a === void 0 ? void 0 : _a.assemblyNames) || [];
        async function fetchSeq(start, end, refName) {
            const assembly = await assemblyManager.waitForAssembly(assemblyName);
            if (!assembly) {
                throw new Error('assembly not found');
            }
            const sessionId = 'getSequence';
            const feats = await rpcManager.call(sessionId, 'CoreGetFeatures', {
                adapterConfig: (0, configuration_1.getConf)(assembly, ['sequence', 'adapter']),
                sessionId,
                regions: [
                    {
                        start,
                        end,
                        refName: assembly.getCanonicalRefName(refName),
                    },
                ],
            });
            const [feat] = feats;
            return (feat === null || feat === void 0 ? void 0 : feat.get('seq')) || '';
        }
        ;
        (async () => {
            try {
                setError(undefined);
                const { start, end, refName } = feature;
                if (!forceLoad.force && end - start > BPLIMIT) {
                    setSequence({
                        error: `Genomic sequence larger than ${BPLIMIT}bp, use "force load" button to display`,
                    });
                }
                else {
                    const seq = await fetchSeq(start, end, refName);
                    const up = await fetchSeq(Math.max(0, start - upDownBp), start, refName);
                    const down = await fetchSeq(end, end + upDownBp, refName);
                    if (!finished) {
                        setSequence({ seq, upstream: up, downstream: down });
                    }
                }
            }
            catch (e) {
                console.error(e);
                setError(e);
            }
        })();
        return () => {
            finished = true;
        };
    }, [feature, shown, model, upDownBp, forceLoad]);
    const loading = !sequence;
    const session = (0, util_1.getSession)(model);
    const defaultSeqTypes = ['mRNA', 'transcript', 'gene'];
    const sequenceTypes = (0, configuration_1.getConf)(session, ['featureDetails', 'sequenceTypes']) || defaultSeqTypes;
    // only attempt fetching gene type sequence on a bare CDS if it has no parent
    const attemptGeneType = feature.type === 'CDS'
        ? sequenceTypes.includes('CDS') && !feature.parentId
        : sequenceTypes.includes(feature.type);
    const val = attemptGeneType ? (hasCDS ? 'cds' : 'cdna') : 'genomic';
    // this useEffect is needed to reset the mode/setMode useState because the contents of the select box can completely change depending on whether we click on a gene feature or non-gene feature, so the current value in the select box must change accordingly
    (0, react_1.useEffect)(() => {
        setMode(val);
    }, [attemptGeneType, val]);
    const [mode, setMode] = (0, react_1.useState)(attemptGeneType ? (hasCDS ? 'cds' : 'cdna') : 'genomic');
    const rest = {
        gene: 'Gene w/ introns',
        gene_collapsed_intron: `Gene w/ ${intronBp}bp of intron`,
        gene_updownstream: `Gene w/ ${upDownBp}bp up+down stream`,
        gene_updownstream_collapsed_intron: `Gene w/ ${upDownBp}bp up+down stream w/ ${intronBp}bp intron`,
        cdna: 'cDNA',
    };
    const arg = attemptGeneType
        ? hasCDS
            ? {
                cds: 'CDS',
                protein: 'Protein',
                ...rest,
            }
            : rest
        : {
            genomic: 'Genomic seq',
            genomic_sequence_updown: `Genomic seq w/ ${upDownBp}bp up+down stream`,
        };
    return (isGene && !hasCDS) || !model ? null : (react_1.default.createElement("div", { className: classes.container2 },
        react_1.default.createElement(material_1.Button, { variant: "contained", onClick: () => setShown(!shown) }, shown ? 'Hide feature sequence' : 'Show feature sequence'),
        react_1.default.createElement(material_1.FormControl, { className: classes.formControl },
            react_1.default.createElement(material_1.IconButton, { onClick: () => setHelpShown(true) },
                react_1.default.createElement(Help_1.default, null))),
        react_1.default.createElement("br", null),
        shown ? (react_1.default.createElement("div", { className: classes.container2 },
            react_1.default.createElement(material_1.FormControl, { className: classes.formControl },
                react_1.default.createElement(material_1.Select, { value: mode, onChange: event => setMode(event.target.value) }, Object.entries(arg).map(([key, val]) => (react_1.default.createElement(material_1.MenuItem, { key: key, value: key }, val))))),
            react_1.default.createElement(material_1.FormControl, { className: classes.formControl },
                react_1.default.createElement(material_1.Button, { className: classes.button, variant: "contained", color: "inherit", onClick: () => {
                        const ref = seqPanelRef.current;
                        if (ref) {
                            (0, copy_to_clipboard_1.default)(ref.textContent || '', { format: 'text/plain' });
                            setCopied(true);
                            setTimeout(() => setCopied(false), 1000);
                        }
                    } }, copied ? 'Copied to clipboard!' : 'Copy plaintext')),
            react_1.default.createElement(material_1.FormControl, { className: classes.formControl },
                react_1.default.createElement(material_1.Tooltip, { title: "The 'Copy HTML' function retains the colors from the sequence panel but cannot be pasted into some programs like notepad that only expect plain text" },
                    react_1.default.createElement(material_1.Button, { className: classes.button, variant: "contained", color: "inherit", onClick: () => {
                            const ref = seqPanelRef.current;
                            if (ref) {
                                (0, copy_to_clipboard_1.default)(ref.innerHTML, { format: 'text/html' });
                                setCopiedHtml(true);
                                setTimeout(() => setCopiedHtml(false), 1000);
                            }
                        } }, copiedHtml ? 'Copied to clipboard!' : 'Copy HTML'))),
            react_1.default.createElement(material_1.FormControl, { className: classes.formControl },
                react_1.default.createElement(material_1.IconButton, { onClick: () => setSettingsDlgOpen(true) },
                    react_1.default.createElement(Settings_1.default, null))),
            react_1.default.createElement("br", null),
            react_1.default.createElement(react_1.default.Fragment, null, error ? (react_1.default.createElement(material_1.Typography, { color: "error" }, `${error}`)) : loading ? (react_1.default.createElement(ui_1.LoadingEllipses, null)) : sequence ? ('error' in sequence ? (react_1.default.createElement(react_1.default.Fragment, null,
                react_1.default.createElement(material_1.Typography, { color: "error" }, sequence.error),
                react_1.default.createElement(material_1.Button, { variant: "contained", color: "inherit", onClick: () => setForceLoad({ ...forceLoad, force: true }) }, "Force load"))) : (react_1.default.createElement(SequencePanel_1.default, { ref: seqPanelRef, feature: parentFeature, mode: mode, sequence: sequence, intronBp: intronBp }))) : (react_1.default.createElement(material_1.Typography, null, "No sequence found"))))) : null,
        settingsDlgOpen ? (react_1.default.createElement(SequenceFeatureSettingsDialog_1.default, { handleClose: arg => {
                if (arg) {
                    const { upDownBp, intronBp } = arg;
                    setIntronBp(intronBp);
                    setUpDownBp(upDownBp);
                }
                setSettingsDlgOpen(false);
            }, upDownBp: upDownBp, intronBp: intronBp })) : null,
        helpShown ? react_1.default.createElement(SequenceHelpDialog_1.default, { handleClose: () => setHelpShown(false) }) : null));
}
exports.default = SequenceFeatureDetails;
