"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteFileWithRangeCache = exports.clearCache = void 0;
const http_range_fetcher_1 = require("http-range-fetcher");
const buffer_1 = require("buffer");
const generic_filehandle_1 = require("generic-filehandle");
const fetchers = {};
function binaryRangeFetch(url, start, end, options = {}) {
    const fetcher = fetchers[url];
    if (!fetcher) {
        throw new Error(`fetch not registered for ${url}`);
    }
    return fetcher(url, start, end, options);
}
const globalRangeCache = new http_range_fetcher_1.HttpRangeFetcher({
    fetch: binaryRangeFetch,
    size: 500 * 1024 ** 2,
    chunkSize: 128 * 124,
    maxFetchSize: 100 * 1024 ** 2,
    minimumTTL: 24 * 60 * 60 * 1000, // 1 day
});
function clearCache() {
    globalRangeCache.reset();
}
exports.clearCache = clearCache;
class RemoteFileWithRangeCache extends generic_filehandle_1.RemoteFile {
    async fetch(url, init) {
        if (!fetchers[String(url)]) {
            fetchers[String(url)] = this.fetchBinaryRange.bind(this);
        }
        // if it is a range request, route it through the range cache
        const requestHeaders = init && init.headers;
        let range;
        if (requestHeaders) {
            if (requestHeaders instanceof Headers) {
                range = requestHeaders.get('range');
            }
            else if (Array.isArray(requestHeaders)) {
                ;
                [, range] = requestHeaders.find(([key]) => key === 'range') || [
                    undefined,
                    undefined,
                ];
            }
            else {
                range = requestHeaders.range;
            }
        }
        if (range) {
            const rangeParse = /bytes=(\d+)-(\d+)/.exec(range);
            if (rangeParse) {
                const [, start, end] = rangeParse;
                const s = parseInt(start, 10);
                const e = parseInt(end, 10);
                const response = (await globalRangeCache.getRange(url, s, e - s + 1, {
                    signal: init && init.signal,
                }));
                const { headers } = response;
                return new Response(response.buffer, { status: 206, headers });
            }
        }
        return super.fetch(url, init);
    }
    async fetchBinaryRange(url, start, end, options = {}) {
        const requestDate = new Date();
        const requestHeaders = {
            ...options.headers,
            range: `bytes=${start}-${end}`,
        };
        const res = await super.fetch(url, {
            ...options,
            headers: requestHeaders,
        });
        const responseDate = new Date();
        if (res.status !== 206) {
            const errorMessage = `HTTP ${res.status} (${res.statusText}) when fetching ${url} bytes ${start}-${end}`;
            const hint = ' (should be 206 for range requests)';
            throw new Error(`${errorMessage}${res.status === 200 ? hint : ''}`);
        }
        // translate the Headers object into a regular key -> value object.
        // will miss duplicate headers of course
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const headers = {};
        for (const [k, v] of res.headers.entries()) {
            headers[k] = v;
        }
        // return the response headers, and the data buffer
        const arrayBuffer = await res.arrayBuffer();
        return {
            headers,
            requestDate,
            responseDate,
            buffer: buffer_1.Buffer.from(arrayBuffer),
        };
    }
}
exports.RemoteFileWithRangeCache = RemoteFileWithRangeCache;
