import PluginManager from '../PluginManager';
import { IAnyStateTreeNode, IStateTreeNode } from 'mobx-state-tree';
import { IReactionPublic, IReactionOptions } from 'mobx';
import SimpleFeature, { Feature, isFeature } from './simpleFeature';
import { AssemblyManager, Region, TypeTestedByPredicate } from './types';
import { BaseBlock } from './blockTypes';
export type { Feature };
export * from './types';
export * from './aborting';
export * from './when';
export * from './range';
export { SimpleFeature, isFeature };
export * from './offscreenCanvasPonyfill';
export * from './offscreenCanvasUtils';
export declare const inDevelopment: boolean;
export declare const inProduction: boolean;
export declare function useDebounce<T>(value: T, delay: number): T;
export declare function useDebouncedCallback<A extends any[]>(callback: (...args: A) => void, wait?: number): (...args: A) => void;
/** find the first node in the hierarchy that matches the given predicate */
export declare function findParentThat(node: IAnyStateTreeNode, predicate: (thing: IAnyStateTreeNode) => boolean): IAnyStateTreeNode;
export declare function springAnimate(fromValue: number, toValue: number, setValue: (value: number) => void, onFinish?: () => void, precision?: number, tension?: number, friction?: number): (() => void)[];
/** find the first node in the hierarchy that matches the given 'is' typescript type guard predicate */
export declare function findParentThatIs<PREDICATE extends (thing: IAnyStateTreeNode) => boolean>(node: IAnyStateTreeNode, predicate: PREDICATE): TypeTestedByPredicate<PREDICATE> & IAnyStateTreeNode;
/** get the current JBrowse session model, starting at any node in the state tree */
export declare function getSession(node: IAnyStateTreeNode): import("./types").AbstractSessionModel & IAnyStateTreeNode;
/** get the state model of the view in the state tree that contains the given node */
export declare function getContainingView(node: IAnyStateTreeNode): import("./types").AbstractViewModel & IAnyStateTreeNode;
/** get the state model of the view in the state tree that contains the given node */
export declare function getContainingTrack(node: IAnyStateTreeNode): import("./types").AbstractTrackModel & IAnyStateTreeNode;
export declare function getContainingDisplay(node: IAnyStateTreeNode): import("./types").AbstractDisplayModel & IAnyStateTreeNode;
/**
 * Assemble a 1-based "locString" from an interbase genomic location
 * @param region - Region
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 })
 * // ↳ '{hg19}chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1' })
 * // ↳ 'chr1'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0 })
 * // ↳ 'chr1:1..'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 1 })
 * // ↳ 'chr1:1'
 * ```
 */
export declare function assembleLocString(region: ParsedLocString): string;
export declare function assembleLocStringFast(region: ParsedLocString, cb?: (n: number) => string | number): string;
export interface ParsedLocString {
    assemblyName?: string;
    refName: string;
    start?: number;
    end?: number;
    reversed?: boolean;
}
export declare function parseLocStringOneBased(locString: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): ParsedLocString;
/**
 * Parse a 1-based location string into an interbase genomic location
 * @param locString - Location string
 * @param isValidRefName - Function that checks if a refName exists in the set
 * of all known refNames, or in the set of refNames for an assembly if
 * assemblyName is given
 * @example
 * ```ts
 * parseLocString('chr1:1..100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1-100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString(`{hg19}chr1:1..100`, isValidRefName)
 * // ↳ { assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1', isValidRefName)
 * // ↳ { refName: 'chr1' }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 1 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1..', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0}
 * ```
 */
export declare function parseLocString(locString: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): ParsedLocString;
export declare function compareLocs(locA: ParsedLocString, locB: ParsedLocString): number;
export declare function compareLocStrings(a: string, b: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): number;
/**
 * Ensure that a number is at least min and at most max.
 *
 * @param num -
 * @param min -
 * @param  max -
 */
export declare function clamp(num: number, min: number, max: number): number;
/**
 * @param bp -
 * @param region -
 * @param bpPerPx -
 */
export declare function bpToPx(bp: number, { reversed, end, start, }: {
    start?: number;
    end?: number;
    reversed?: boolean;
}, bpPerPx: number): number;
export declare function radToDeg(radians: number): number;
export declare function degToRad(degrees: number): number;
/**
 * @returns [x, y]
 */
export declare function polarToCartesian(rho: number, theta: number): [number, number];
/**
 * @param x - the x
 * @param y - the y
 * @returns [rho, theta]
 */
export declare function cartesianToPolar(x: number, y: number): [number, number];
export declare function featureSpanPx(feature: Feature, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): [number, number];
export declare function bpSpanPx(leftBp: number, rightBp: number, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): [number, number];
export declare function iterMap<T, U>(iterable: Iterable<T>, func: (item: T) => U, sizeHint?: number): U[];
/**
 * Returns the index of the last element in the array where predicate is true,
 * and -1 otherwise.
 * @param array - The source array to search in
 * @param predicate - find calls predicate once for each element of the array, in
 * descending order, until it finds one where predicate returns true. If such an
 * element is found, findLastIndex immediately returns that element index.
 * Otherwise, findLastIndex returns -1.
 */
export declare function findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number;
/**
 * makes a mobx reaction with the given functions, that calls actions on the
 * model for each stage of execution, and to abort the reaction function when
 * the model is destroyed.
 *
 * Will call startedFunction(signal), successFunction(result), and
 * errorFunction(error) when the async reaction function starts, completes, and
 * errors respectively.
 *
 * @param self -
 * @param dataFunction -
 * @param asyncReactionFunction -
 * @param reactionOptions -
 * @param startedFunction -
 * @param successFunction -
 * @param errorFunction -
 */
export declare function makeAbortableReaction<T, U, V>(self: T, dataFunction: (arg: T) => U, asyncReactionFunction: (arg: U | undefined, signal: AbortSignal, model: T, handle: IReactionPublic) => Promise<V>, reactionOptions: IReactionOptions, startedFunction: (aborter: AbortController) => void, successFunction: (arg: V) => void, errorFunction: (err: unknown) => void): void;
export declare function renameRegionIfNeeded(refNameMap: Record<string, string>, region: Region): Region & {
    originalRefName?: string;
};
export declare function renameRegionsIfNeeded<ARGTYPE extends {
    assemblyName?: string;
    regions?: Region[];
    signal?: AbortSignal;
    adapterConfig: unknown;
    sessionId: string;
    statusCallback?: (arg: string) => void;
}>(assemblyManager: AssemblyManager, args: ARGTYPE): Promise<ARGTYPE & {
    regions: (Region & {
        originalRefName?: string | undefined;
    })[];
}>;
export declare function minmax(a: number, b: number): number[];
export declare function shorten(name: string, max?: number, short?: number): string;
export declare function stringify({ refName, coord, oob, }: {
    coord: number;
    refName?: string;
    oob?: boolean;
}): string;
export declare const isElectron: boolean;
export declare function revcom(seqString: string): string;
export declare function reverse(seqString: string): string;
export declare const complement: (seqString: string) => string;
export declare function blobToDataURL(blob: Blob): Promise<string>;
export declare const rIC: (((callback: IdleRequestCallback, options?: IdleRequestOptions | undefined) => number) & typeof requestIdleCallback) | ((cb: Function) => any);
export declare function measureText(str: unknown, fontSize?: number): number;
export declare const defaultStarts: string[];
export declare const defaultStops: string[];
export declare const defaultCodonTable: {
    TCA: string;
    TCC: string;
    TCG: string;
    TCT: string;
    TTC: string;
    TTT: string;
    TTA: string;
    TTG: string;
    TAC: string;
    TAT: string;
    TAA: string;
    TAG: string;
    TGC: string;
    TGT: string;
    TGA: string;
    TGG: string;
    CTA: string;
    CTC: string;
    CTG: string;
    CTT: string;
    CCA: string;
    CCC: string;
    CCG: string;
    CCT: string;
    CAC: string;
    CAT: string;
    CAA: string;
    CAG: string;
    CGA: string;
    CGC: string;
    CGG: string;
    CGT: string;
    ATA: string;
    ATC: string;
    ATT: string;
    ATG: string;
    ACA: string;
    ACC: string;
    ACG: string;
    ACT: string;
    AAC: string;
    AAT: string;
    AAA: string;
    AAG: string;
    AGC: string;
    AGT: string;
    AGA: string;
    AGG: string;
    GTA: string;
    GTC: string;
    GTG: string;
    GTT: string;
    GCA: string;
    GCC: string;
    GCG: string;
    GCT: string;
    GAC: string;
    GAT: string;
    GAA: string;
    GAG: string;
    GGA: string;
    GGC: string;
    GGG: string;
    GGT: string;
};
/**
 *  take CodonTable above and generate larger codon table that includes
 *  all permutations of upper and lower case nucleotides
 */
export declare function generateCodonTable(table: any): {
    [key: string]: string;
};
export declare function updateStatus<U>(msg: string, cb: (arg: string) => void, fn: () => U): Promise<U>;
export declare function hashCode(str: string): number;
export declare function objectHash(obj: Record<string, any>): string;
interface VirtualOffset {
    blockPosition: number;
}
interface Block {
    minv: VirtualOffset;
    maxv: VirtualOffset;
}
export declare function bytesForRegions(regions: Region[], index: {
    blocksForRange: (ref: string, start: number, end: number) => Promise<Block[]>;
}): Promise<number>;
export type ViewSnap = {
    bpPerPx: number;
    interRegionPaddingWidth: number;
    minimumBlockWidth: number;
    width: number;
    offsetPx: number;
    staticBlocks: {
        contentBlocks: BaseBlock[];
        blocks: BaseBlock[];
    };
    displayedRegions: (IStateTreeNode & {
        start: number;
        end: number;
        refName: string;
        reversed: boolean;
        assemblyName: string;
    })[];
};
export declare function supportedIndexingAdapters(type: string): boolean;
export declare function getBpDisplayStr(totalBp: number): string;
export declare function toLocale(n: number): string;
export declare function getTickDisplayStr(totalBp: number, bpPerPx: number): string;
export declare function getViewParams(model: IAnyStateTreeNode, exportSVG?: boolean): {
    offsetPx: number;
    offsetPx1: number;
    start: any;
    end: any;
};
export declare function getLayoutId({ sessionId, layoutId, }: {
    sessionId: string;
    layoutId: string;
}): string;
export declare function useLocalStorage<T>(key: string, initialValue: T): readonly [T, (value: T | ((val: T) => T)) => void];
export declare function getUriLink(value: {
    uri: string;
    baseUri?: string;
}): string;
export declare function getStr(obj: unknown): string;
export declare function measureGridWidth(elements: string[]): number;
export declare function getEnv(obj: any): {
    pluginManager: PluginManager;
};
