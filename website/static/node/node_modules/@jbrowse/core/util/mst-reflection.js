"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveLateType = exports.getEnumerationValues = exports.getDefaultValue = exports.getPropertyType = exports.getUnionSubTypes = exports.getSubType = void 0;
/* eslint-disable no-underscore-dangle */
const mobx_state_tree_1 = require("mobx-state-tree");
/**
 * get the inner type of an MST optional, array, or late type object
 *
 * @param {IModelType} type
 * @returns {IModelType}
 */
function getSubType(type) {
    let t;
    if ((0, mobx_state_tree_1.isOptionalType)(type)) {
        t = type._subtype || type.type;
    }
    else if ((0, mobx_state_tree_1.isArrayType)(type) || (0, mobx_state_tree_1.isMapType)(type)) {
        t = type._subtype || type._subType || type.subType;
    }
    else if (typeof type.getSubType === 'function') {
        return type.getSubType();
    }
    else {
        throw new TypeError('unsupported mst type');
    }
    if (!t) {
        // debugger
        throw new Error('failed to get subtype');
    }
    return t;
}
exports.getSubType = getSubType;
/**
 * get the array of
 * @param {MST Union Type obj} unionType
 * @returns {Array<IModelType>}
 */
function getUnionSubTypes(unionType) {
    if (!(0, mobx_state_tree_1.isUnionType)(unionType)) {
        throw new TypeError('not an MST union type');
    }
    const t = unionType._types ||
        unionType.types ||
        getSubType(unionType)._types ||
        getSubType(unionType).types;
    if (!t) {
        // debugger
        throw new Error('failed to extract subtypes from mst union');
    }
    return t;
}
exports.getUnionSubTypes = getUnionSubTypes;
/**
 * get the type of one of the properties of the given MST model type
 *
 * @param {IModelType} type
 * @param {string} propertyName
 * @returns {IModelType}
 */
function getPropertyType(type, propertyName) {
    const propertyType = type.properties[propertyName];
    return propertyType;
}
exports.getPropertyType = getPropertyType;
/**
 * get the base type from inside an MST optional type
 * @param {*} type
 */
function getDefaultValue(type) {
    if (!(0, mobx_state_tree_1.isOptionalType)(type)) {
        throw new TypeError('type must be an optional type');
    }
    return type._defaultValue || type.defaultValue;
}
exports.getDefaultValue = getDefaultValue;
/** get the string values of an MST enumeration type */
function getEnumerationValues(type) {
    const subtypes = getUnionSubTypes(type);
    // the subtypes should all be literals with a value member
    return subtypes.map(t => t.value);
}
exports.getEnumerationValues = getEnumerationValues;
function resolveLateType(maybeLate) {
    if (!(0, mobx_state_tree_1.isUnionType)(maybeLate) &&
        !(0, mobx_state_tree_1.isArrayType)(maybeLate) &&
        (0, mobx_state_tree_1.isLateType)(maybeLate)) {
        return maybeLate.getSubType();
    }
    return maybeLate;
}
exports.resolveLateType = resolveLateType;
