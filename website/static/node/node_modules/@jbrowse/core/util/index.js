"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesForRegions = exports.objectHash = exports.hashCode = exports.updateStatus = exports.generateCodonTable = exports.defaultCodonTable = exports.defaultStops = exports.defaultStarts = exports.measureText = exports.rIC = exports.blobToDataURL = exports.complement = exports.reverse = exports.revcom = exports.isElectron = exports.stringify = exports.shorten = exports.minmax = exports.renameRegionsIfNeeded = exports.renameRegionIfNeeded = exports.makeAbortableReaction = exports.findLastIndex = exports.iterMap = exports.bpSpanPx = exports.featureSpanPx = exports.cartesianToPolar = exports.polarToCartesian = exports.degToRad = exports.radToDeg = exports.bpToPx = exports.clamp = exports.compareLocStrings = exports.compareLocs = exports.parseLocString = exports.parseLocStringOneBased = exports.assembleLocStringFast = exports.assembleLocString = exports.getContainingDisplay = exports.getContainingTrack = exports.getContainingView = exports.getSession = exports.findParentThatIs = exports.springAnimate = exports.findParentThat = exports.useDebouncedCallback = exports.useDebounce = exports.inProduction = exports.inDevelopment = exports.isFeature = exports.SimpleFeature = void 0;
exports.getEnv = exports.measureGridWidth = exports.getStr = exports.getUriLink = exports.useLocalStorage = exports.getLayoutId = exports.getViewParams = exports.getTickDisplayStr = exports.toLocale = exports.getBpDisplayStr = exports.supportedIndexingAdapters = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const react_1 = require("react");
const is_object_1 = __importDefault(require("is-object"));
const mobx_state_tree_1 = require("mobx-state-tree");
const mobx_1 = require("mobx");
const simpleFeature_1 = __importStar(require("./simpleFeature"));
exports.SimpleFeature = simpleFeature_1.default;
Object.defineProperty(exports, "isFeature", { enumerable: true, get: function () { return simpleFeature_1.isFeature; } });
const types_1 = require("./types");
const aborting_1 = require("./aborting");
const types_2 = require("./types");
__exportStar(require("./types"), exports);
__exportStar(require("./aborting"), exports);
__exportStar(require("./when"), exports);
__exportStar(require("./range"), exports);
__exportStar(require("./offscreenCanvasPonyfill"), exports);
__exportStar(require("./offscreenCanvasUtils"), exports);
exports.inDevelopment = typeof process === 'object' &&
    process.env &&
    process.env.NODE_ENV === 'development';
exports.inProduction = !exports.inDevelopment;
function useDebounce(value, delay) {
    const [debouncedValue, setDebouncedValue] = (0, react_1.useState)(value);
    (0, react_1.useEffect)(() => {
        const handle = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        return () => {
            clearTimeout(handle);
        };
    }, [value, delay]);
    return debouncedValue;
}
exports.useDebounce = useDebounce;
// https://stackoverflow.com/questions/56283920/how-to-debounce-a-callback-in-functional-component-using-hooks
function useDebouncedCallback(callback, wait = 400) {
    // track args & timeout handle between calls
    const argsRef = (0, react_1.useRef)();
    const timeout = (0, react_1.useRef)();
    function cleanup() {
        if (timeout.current) {
            clearTimeout(timeout.current);
        }
    }
    // make sure our timeout gets cleared if our consuming component gets unmounted
    (0, react_1.useEffect)(() => cleanup, []);
    return function debouncedCallback(...args) {
        // capture latest args
        argsRef.current = args;
        // clear debounce timer
        cleanup();
        // start waiting again
        timeout.current = setTimeout(() => {
            if (argsRef.current) {
                callback(...argsRef.current);
            }
        }, wait);
    };
}
exports.useDebouncedCallback = useDebouncedCallback;
/** find the first node in the hierarchy that matches the given predicate */
function findParentThat(node, predicate) {
    if (!(0, mobx_state_tree_1.hasParent)(node)) {
        throw new Error('node does not have parent');
    }
    let currentNode = (0, mobx_state_tree_1.getParent)(node);
    while (currentNode && (0, mobx_state_tree_1.isAlive)(currentNode)) {
        if (predicate(currentNode)) {
            return currentNode;
        }
        if ((0, mobx_state_tree_1.hasParent)(currentNode)) {
            currentNode = (0, mobx_state_tree_1.getParent)(currentNode);
        }
        else {
            break;
        }
    }
    throw new Error('no matching node found');
}
exports.findParentThat = findParentThat;
// based on https://github.com/react-spring/react-spring/blob/cd5548a987383b8023efd620f3726a981f9e18ea/src/animated/FrameLoop.ts
function springAnimate(fromValue, toValue, setValue, onFinish = () => { }, precision = 0, tension = 170, friction = 26) {
    const mass = 1;
    if (!precision) {
        precision = Math.abs(toValue - fromValue) / 1000;
    }
    let animationFrameId;
    function update(animation) {
        const time = Date.now();
        let position = animation.lastPosition;
        let lastTime = animation.lastTime || time;
        let velocity = animation.lastVelocity || 0;
        // If we lost a lot of frames just jump to the end.
        if (time > lastTime + 64) {
            lastTime = time;
        }
        // http://gafferongames.com/game-physics/fix-your-timestep/
        const numSteps = Math.floor(time - lastTime);
        for (let i = 0; i < numSteps; ++i) {
            const force = -tension * (position - toValue);
            const damping = -friction * velocity;
            const acceleration = (force + damping) / mass;
            velocity += (acceleration * 1) / 1000;
            position += (velocity * 1) / 1000;
        }
        const isVelocity = Math.abs(velocity) <= precision;
        const isDisplacement = tension !== 0 ? Math.abs(toValue - position) <= precision : true;
        const endOfAnimation = isVelocity && isDisplacement;
        if (endOfAnimation) {
            setValue(toValue);
            onFinish();
        }
        else {
            setValue(position);
            animationFrameId = requestAnimationFrame(() => update({
                lastPosition: position,
                lastTime: time,
                lastVelocity: velocity,
            }));
        }
    }
    return [
        () => update({ lastPosition: fromValue }),
        () => cancelAnimationFrame(animationFrameId),
    ];
}
exports.springAnimate = springAnimate;
/** find the first node in the hierarchy that matches the given 'is' typescript type guard predicate */
function findParentThatIs(node, predicate) {
    return findParentThat(node, predicate);
}
exports.findParentThatIs = findParentThatIs;
/** get the current JBrowse session model, starting at any node in the state tree */
function getSession(node) {
    try {
        return findParentThatIs(node, types_1.isSessionModel);
    }
    catch (e) {
        throw new Error('no session model found!');
    }
}
exports.getSession = getSession;
/** get the state model of the view in the state tree that contains the given node */
function getContainingView(node) {
    try {
        return findParentThatIs(node, types_1.isViewModel);
    }
    catch (e) {
        throw new Error('no containing view found');
    }
}
exports.getContainingView = getContainingView;
/** get the state model of the view in the state tree that contains the given node */
function getContainingTrack(node) {
    try {
        return findParentThatIs(node, types_1.isTrackModel);
    }
    catch (e) {
        throw new Error('no containing track found');
    }
}
exports.getContainingTrack = getContainingTrack;
function getContainingDisplay(node) {
    try {
        return findParentThatIs(node, types_1.isDisplayModel);
    }
    catch (e) {
        throw new Error('no containing display found');
    }
}
exports.getContainingDisplay = getContainingDisplay;
/**
 * Assemble a 1-based "locString" from an interbase genomic location
 * @param region - Region
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 })
 * // ↳ '{hg19}chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1' })
 * // ↳ 'chr1'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0 })
 * // ↳ 'chr1:1..'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 1 })
 * // ↳ 'chr1:1'
 * ```
 */
function assembleLocString(region) {
    return assembleLocStringFast(region, toLocale);
}
exports.assembleLocString = assembleLocString;
// same as assembleLocString above, but does not perform toLocaleString which
// can slow down the speed of block calculations which use assembleLocString
// for block.key
function assembleLocStringFast(region, cb = (n) => n) {
    const { assemblyName, refName, start, end, reversed } = region;
    const assemblyNameString = assemblyName ? `{${assemblyName}}` : '';
    let startString;
    if (start !== undefined) {
        startString = `:${cb(start + 1)}`;
    }
    else if (end !== undefined) {
        startString = ':1';
    }
    else {
        startString = '';
    }
    let endString;
    if (end !== undefined) {
        endString = start !== undefined && start + 1 === end ? '' : `..${cb(end)}`;
    }
    else {
        endString = start !== undefined ? '..' : '';
    }
    let rev = '';
    if (reversed) {
        rev = '[rev]';
    }
    return `${assemblyNameString}${refName}${startString}${endString}${rev}`;
}
exports.assembleLocStringFast = assembleLocStringFast;
function parseLocStringOneBased(locString, isValidRefName) {
    if (!locString) {
        throw new Error('no location string provided, could not parse');
    }
    let reversed = false;
    if (locString.endsWith('[rev]')) {
        reversed = true;
        locString = locString.replace(/\[rev\]$/, '');
    }
    // remove any whitespace
    locString = locString.replace(/\s/, '');
    // refNames can have colons, ref https://samtools.github.io/hts-specs/SAMv1.pdf Appendix A
    const assemblyMatch = locString.match(/(\{(.+)\})?(.+)/);
    if (!assemblyMatch) {
        throw new Error(`invalid location string: "${locString}"`);
    }
    const [, , assemblyName, location] = assemblyMatch;
    if (!assemblyName && location.startsWith('{}')) {
        throw new Error(`no assembly name was provided in location "${location}"`);
    }
    const lastColonIdx = location.lastIndexOf(':');
    if (lastColonIdx === -1) {
        if (isValidRefName(location, assemblyName)) {
            return { assemblyName, refName: location, reversed };
        }
        throw new Error(`Unknown reference sequence "${location}"`);
    }
    const prefix = location.slice(0, lastColonIdx);
    const suffix = location.slice(lastColonIdx + 1);
    if (isValidRefName(prefix, assemblyName) &&
        isValidRefName(location, assemblyName)) {
        throw new Error(`ambiguous location string: "${locString}"`);
    }
    else if (isValidRefName(prefix, assemblyName)) {
        if (suffix) {
            // see if it's a range
            const rangeMatch = suffix.match(/^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)(-?(\d+|\d{1,3}(,\d{3})*))$/);
            // see if it's a single point
            const singleMatch = suffix.match(/^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)?$/);
            if (rangeMatch) {
                const [, start, , , , end] = rangeMatch;
                if (start !== undefined && end !== undefined) {
                    return {
                        assemblyName,
                        refName: prefix,
                        start: +start.replace(/,/g, ''),
                        end: +end.replace(/,/g, ''),
                        reversed,
                    };
                }
            }
            else if (singleMatch) {
                const [, start, , , separator] = singleMatch;
                if (start !== undefined) {
                    if (separator) {
                        // indefinite end
                        return {
                            assemblyName,
                            refName: prefix,
                            start: +start.replace(/,/g, ''),
                            reversed,
                        };
                    }
                    return {
                        assemblyName,
                        refName: prefix,
                        start: +start.replace(/,/g, ''),
                        end: +start.replace(/,/g, ''),
                        reversed,
                    };
                }
            }
            else {
                throw new Error(`could not parse range "${suffix}" on location "${locString}"`);
            }
        }
        else {
            return { assemblyName, refName: prefix, reversed };
        }
    }
    else if (isValidRefName(location, assemblyName)) {
        return { assemblyName, refName: location, reversed };
    }
    throw new Error(`unknown reference sequence name in location "${locString}"`);
}
exports.parseLocStringOneBased = parseLocStringOneBased;
/**
 * Parse a 1-based location string into an interbase genomic location
 * @param locString - Location string
 * @param isValidRefName - Function that checks if a refName exists in the set
 * of all known refNames, or in the set of refNames for an assembly if
 * assemblyName is given
 * @example
 * ```ts
 * parseLocString('chr1:1..100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1-100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString(`{hg19}chr1:1..100`, isValidRefName)
 * // ↳ { assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1', isValidRefName)
 * // ↳ { refName: 'chr1' }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 1 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1..', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0}
 * ```
 */
function parseLocString(locString, isValidRefName) {
    const parsed = parseLocStringOneBased(locString, isValidRefName);
    if (typeof parsed.start === 'number') {
        parsed.start -= 1;
    }
    return parsed;
}
exports.parseLocString = parseLocString;
function compareLocs(locA, locB) {
    const assemblyComp = locA.assemblyName || locB.assemblyName
        ? (locA.assemblyName || '').localeCompare(locB.assemblyName || '')
        : 0;
    if (assemblyComp) {
        return assemblyComp;
    }
    const refComp = locA.refName || locB.refName
        ? (locA.refName || '').localeCompare(locB.refName || '')
        : 0;
    if (refComp) {
        return refComp;
    }
    if (locA.start !== undefined && locB.start !== undefined) {
        const startComp = locA.start - locB.start;
        if (startComp) {
            return startComp;
        }
    }
    if (locA.end !== undefined && locB.end !== undefined) {
        const endComp = locA.end - locB.end;
        if (endComp) {
            return endComp;
        }
    }
    return 0;
}
exports.compareLocs = compareLocs;
function compareLocStrings(a, b, isValidRefName) {
    const locA = parseLocString(a, isValidRefName);
    const locB = parseLocString(b, isValidRefName);
    return compareLocs(locA, locB);
}
exports.compareLocStrings = compareLocStrings;
/**
 * Ensure that a number is at least min and at most max.
 *
 * @param num -
 * @param min -
 * @param  max -
 */
function clamp(num, min, max) {
    if (num < min) {
        return min;
    }
    if (num > max) {
        return max;
    }
    return num;
}
exports.clamp = clamp;
function roundToNearestPointOne(num) {
    return Math.round(num * 10) / 10;
}
/**
 * @param bp -
 * @param region -
 * @param bpPerPx -
 */
function bpToPx(bp, { reversed, end = 0, start = 0, }, bpPerPx) {
    return roundToNearestPointOne((reversed ? end - bp : bp - start) / bpPerPx);
}
exports.bpToPx = bpToPx;
const oneEightyOverPi = 180.0 / Math.PI;
const piOverOneEighty = Math.PI / 180.0;
function radToDeg(radians) {
    return (radians * oneEightyOverPi) % 360;
}
exports.radToDeg = radToDeg;
function degToRad(degrees) {
    return (degrees * piOverOneEighty) % (2 * Math.PI);
}
exports.degToRad = degToRad;
/**
 * @returns [x, y]
 */
function polarToCartesian(rho, theta) {
    return [rho * Math.cos(theta), rho * Math.sin(theta)];
}
exports.polarToCartesian = polarToCartesian;
/**
 * @param x - the x
 * @param y - the y
 * @returns [rho, theta]
 */
function cartesianToPolar(x, y) {
    const rho = Math.sqrt(x * x + y * y);
    const theta = Math.atan(y / x);
    return [rho, theta];
}
exports.cartesianToPolar = cartesianToPolar;
function featureSpanPx(feature, region, bpPerPx) {
    return bpSpanPx(feature.get('start'), feature.get('end'), region, bpPerPx);
}
exports.featureSpanPx = featureSpanPx;
function bpSpanPx(leftBp, rightBp, region, bpPerPx) {
    const start = bpToPx(leftBp, region, bpPerPx);
    const end = bpToPx(rightBp, region, bpPerPx);
    return region.reversed ? [end, start] : [start, end];
}
exports.bpSpanPx = bpSpanPx;
// do an array map of an iterable
function iterMap(iterable, func, sizeHint) {
    const results = sizeHint ? new Array(sizeHint) : [];
    let counter = 0;
    for (const item of iterable) {
        results[counter] = func(item);
        counter += 1;
    }
    return results;
}
exports.iterMap = iterMap;
// https://stackoverflow.com/a/53187807
/**
 * Returns the index of the last element in the array where predicate is true,
 * and -1 otherwise.
 * @param array - The source array to search in
 * @param predicate - find calls predicate once for each element of the array, in
 * descending order, until it finds one where predicate returns true. If such an
 * element is found, findLastIndex immediately returns that element index.
 * Otherwise, findLastIndex returns -1.
 */
function findLastIndex(array, predicate) {
    let l = array.length;
    while (l--) {
        if (predicate(array[l], l, array)) {
            return l;
        }
    }
    return -1;
}
exports.findLastIndex = findLastIndex;
/**
 * makes a mobx reaction with the given functions, that calls actions on the
 * model for each stage of execution, and to abort the reaction function when
 * the model is destroyed.
 *
 * Will call startedFunction(signal), successFunction(result), and
 * errorFunction(error) when the async reaction function starts, completes, and
 * errors respectively.
 *
 * @param self -
 * @param dataFunction -
 * @param asyncReactionFunction -
 * @param reactionOptions -
 * @param startedFunction -
 * @param successFunction -
 * @param errorFunction -
 */
function makeAbortableReaction(self, dataFunction, asyncReactionFunction, 
// @ts-ignore
reactionOptions, startedFunction, successFunction, errorFunction) {
    let inProgress;
    function handleError(error) {
        if (!(0, aborting_1.isAbortException)(error)) {
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                errorFunction(error);
            }
            else {
                console.error(error);
            }
        }
    }
    (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.reaction)(() => {
        try {
            return dataFunction(self);
        }
        catch (e) {
            handleError(e);
            return undefined;
        }
    }, async (data, mobxReactionHandle) => {
        if (inProgress && !inProgress.signal.aborted) {
            inProgress.abort();
        }
        if (!(0, mobx_state_tree_1.isAlive)(self)) {
            return;
        }
        inProgress = new AbortController();
        const thisInProgress = inProgress;
        startedFunction(thisInProgress);
        try {
            const result = await asyncReactionFunction(data, thisInProgress.signal, self, 
            // @ts-ignore
            mobxReactionHandle);
            (0, aborting_1.checkAbortSignal)(thisInProgress.signal);
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                successFunction(result);
            }
        }
        catch (e) {
            if (thisInProgress && !thisInProgress.signal.aborted) {
                thisInProgress.abort();
            }
            handleError(e);
        }
    }, reactionOptions));
    (0, mobx_state_tree_1.addDisposer)(self, () => {
        if (inProgress && !inProgress.signal.aborted) {
            inProgress.abort();
        }
    });
}
exports.makeAbortableReaction = makeAbortableReaction;
function renameRegionIfNeeded(refNameMap, region) {
    if ((0, mobx_state_tree_1.isStateTreeNode)(region) && !(0, mobx_state_tree_1.isAlive)(region)) {
        return region;
    }
    if (region && refNameMap && refNameMap[region.refName]) {
        // clone the region so we don't modify it
        if ((0, mobx_state_tree_1.isStateTreeNode)(region)) {
            // @ts-ignore
            region = { ...(0, mobx_state_tree_1.getSnapshot)(region) };
        }
        else {
            region = { ...region };
        }
        // modify it directly in the container
        const newRef = refNameMap[region.refName];
        if (newRef) {
            return { ...region, refName: newRef, originalRefName: region.refName };
        }
    }
    return region;
}
exports.renameRegionIfNeeded = renameRegionIfNeeded;
async function renameRegionsIfNeeded(assemblyManager, args) {
    const { regions = [], adapterConfig } = args;
    if (!args.sessionId) {
        throw new Error('sessionId is required');
    }
    const assemblyNames = regions.map(region => region.assemblyName);
    const assemblyMaps = Object.fromEntries(await Promise.all(assemblyNames.map(async (assemblyName) => {
        return [
            assemblyName,
            await assemblyManager.getRefNameMapForAdapter(adapterConfig, assemblyName, args),
        ];
    })));
    return {
        ...args,
        regions: regions.map((region, i) => 
        // note: uses assemblyNames defined above since region could be dead now
        renameRegionIfNeeded(assemblyMaps[assemblyNames[i]], region)),
    };
}
exports.renameRegionsIfNeeded = renameRegionsIfNeeded;
function minmax(a, b) {
    return [Math.min(a, b), Math.max(a, b)];
}
exports.minmax = minmax;
function shorten(name, max = 70, short = 30) {
    return name.length > max
        ? name.slice(0, short) + '...' + name.slice(-short)
        : name;
}
exports.shorten = shorten;
function stringify({ refName, coord, oob, }) {
    return refName
        ? `${shorten(refName)}:${toLocale(coord)}${oob ? ' (out of bounds)' : ''}`
        : '';
}
exports.stringify = stringify;
// this is recommended in a later comment in https://github.com/electron/electron/issues/2288
// for detecting electron in a renderer process, which is the one that has node enabled for us
// const isElectron = process.versions.electron
// const i2 = process.versions.hasOwnProperty('electron')
exports.isElectron = /electron/i.test(typeof navigator !== 'undefined' ? navigator.userAgent : '');
function revcom(seqString) {
    return reverse((0, exports.complement)(seqString));
}
exports.revcom = revcom;
function reverse(seqString) {
    return seqString.split('').reverse().join('');
}
exports.reverse = reverse;
exports.complement = (() => {
    const complementRegex = /[ACGT]/gi;
    // from bioperl: tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/
    // generated with:
    // perl -MJSON -E '@l = split "","acgtrymkswhbvdnxACGTRYMKSWHBVDNX"; print to_json({ map { my $in = $_; tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/; $in => $_ } @l})'
    const complementTable = {
        S: 'S',
        w: 'w',
        T: 'A',
        r: 'y',
        a: 't',
        N: 'N',
        K: 'M',
        x: 'x',
        d: 'h',
        Y: 'R',
        V: 'B',
        y: 'r',
        M: 'K',
        h: 'd',
        k: 'm',
        C: 'G',
        g: 'c',
        t: 'a',
        A: 'T',
        n: 'n',
        W: 'W',
        X: 'X',
        m: 'k',
        v: 'b',
        B: 'V',
        s: 's',
        H: 'D',
        c: 'g',
        D: 'H',
        b: 'v',
        R: 'Y',
        G: 'C',
    };
    return (seqString) => {
        return seqString.replace(complementRegex, m => complementTable[m] || '');
    };
})();
function blobToDataURL(blob) {
    const a = new FileReader();
    return new Promise((resolve, reject) => {
        a.onload = e => {
            if (e.target) {
                resolve(e.target.result);
            }
            else {
                reject(new Error('unknown result reading blob from canvas'));
            }
        };
        a.readAsDataURL(blob);
    });
}
exports.blobToDataURL = blobToDataURL;
// requires immediate execution in jest environment, because (hypothesis) it
// otherwise listens for prerendered_canvas but reads empty pixels, and doesn't
// get the contents of the canvas
exports.rIC = typeof jest === 'undefined'
    ? // @ts-ignore
        typeof window !== 'undefined' && window.requestIdleCallback
            ? // @ts-ignore
                window.requestIdleCallback
            : (cb) => setTimeout(() => cb(), 1)
    : (cb) => cb();
// prettier-ignore
const widths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2796875, 0.2765625, 0.3546875, 0.5546875, 0.5546875, 0.8890625, 0.665625, 0.190625, 0.3328125, 0.3328125, 0.3890625, 0.5828125, 0.2765625, 0.3328125, 0.2765625, 0.3015625, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.2765625, 0.2765625, 0.584375, 0.5828125, 0.584375, 0.5546875, 1.0140625, 0.665625, 0.665625, 0.721875, 0.721875, 0.665625, 0.609375, 0.7765625, 0.721875, 0.2765625, 0.5, 0.665625, 0.5546875, 0.8328125, 0.721875, 0.7765625, 0.665625, 0.7765625, 0.721875, 0.665625, 0.609375, 0.721875, 0.665625, 0.94375, 0.665625, 0.665625, 0.609375, 0.2765625, 0.3546875, 0.2765625, 0.4765625, 0.5546875, 0.3328125, 0.5546875, 0.5546875, 0.5, 0.5546875, 0.5546875, 0.2765625, 0.5546875, 0.5546875, 0.221875, 0.240625, 0.5, 0.221875, 0.8328125, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.3328125, 0.5, 0.2765625, 0.5546875, 0.5, 0.721875, 0.5, 0.5, 0.5, 0.3546875, 0.259375, 0.353125, 0.5890625];
// xref https://gist.github.com/tophtucker/62f93a4658387bb61e4510c37e2e97cf
function measureText(str, fontSize = 10) {
    var _a;
    const avg = 0.5279276315789471;
    const s = String(str);
    let total = 0;
    for (let i = 0; i < s.length; i++) {
        const code = s.charCodeAt(i);
        total += (_a = widths[code]) !== null && _a !== void 0 ? _a : avg;
    }
    return total * fontSize;
}
exports.measureText = measureText;
exports.defaultStarts = ['ATG'];
exports.defaultStops = ['TAA', 'TAG', 'TGA'];
exports.defaultCodonTable = {
    TCA: 'S',
    TCC: 'S',
    TCG: 'S',
    TCT: 'S',
    TTC: 'F',
    TTT: 'F',
    TTA: 'L',
    TTG: 'L',
    TAC: 'Y',
    TAT: 'Y',
    TAA: '*',
    TAG: '*',
    TGC: 'C',
    TGT: 'C',
    TGA: '*',
    TGG: 'W',
    CTA: 'L',
    CTC: 'L',
    CTG: 'L',
    CTT: 'L',
    CCA: 'P',
    CCC: 'P',
    CCG: 'P',
    CCT: 'P',
    CAC: 'H',
    CAT: 'H',
    CAA: 'Q',
    CAG: 'Q',
    CGA: 'R',
    CGC: 'R',
    CGG: 'R',
    CGT: 'R',
    ATA: 'I',
    ATC: 'I',
    ATT: 'I',
    ATG: 'M',
    ACA: 'T',
    ACC: 'T',
    ACG: 'T',
    ACT: 'T',
    AAC: 'N',
    AAT: 'N',
    AAA: 'K',
    AAG: 'K',
    AGC: 'S',
    AGT: 'S',
    AGA: 'R',
    AGG: 'R',
    GTA: 'V',
    GTC: 'V',
    GTG: 'V',
    GTT: 'V',
    GCA: 'A',
    GCC: 'A',
    GCG: 'A',
    GCT: 'A',
    GAC: 'D',
    GAT: 'D',
    GAA: 'E',
    GAG: 'E',
    GGA: 'G',
    GGC: 'G',
    GGG: 'G',
    GGT: 'G',
};
/**
 *  take CodonTable above and generate larger codon table that includes
 *  all permutations of upper and lower case nucleotides
 */
function generateCodonTable(table) {
    const tempCodonTable = {};
    Object.keys(table).forEach(codon => {
        const aa = table[codon];
        const nucs = [];
        for (let i = 0; i < 3; i++) {
            const nuc = codon.charAt(i);
            nucs[i] = [];
            nucs[i][0] = nuc.toUpperCase();
            nucs[i][1] = nuc.toLowerCase();
        }
        for (let i = 0; i < 2; i++) {
            const n0 = nucs[0][i];
            for (let j = 0; j < 2; j++) {
                const n1 = nucs[1][j];
                for (let k = 0; k < 2; k++) {
                    const n2 = nucs[2][k];
                    const triplet = n0 + n1 + n2;
                    tempCodonTable[triplet] = aa;
                }
            }
        }
    });
    return tempCodonTable;
}
exports.generateCodonTable = generateCodonTable;
// call statusCallback with current status and clear when finished
async function updateStatus(msg, cb, fn) {
    cb(msg);
    const res = await fn();
    cb('');
    return res;
}
exports.updateStatus = updateStatus;
function hashCode(str) {
    let hash = 0;
    if (str.length === 0) {
        return hash;
    }
    for (let i = 0; i < str.length; i++) {
        const chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}
exports.hashCode = hashCode;
function objectHash(obj) {
    return `${hashCode(JSON.stringify(obj))}`;
}
exports.objectHash = objectHash;
async function bytesForRegions(regions, index) {
    const blockResults = await Promise.all(regions.map(r => index.blocksForRange(r.refName, r.start, r.end)));
    return blockResults
        .flat()
        .map(block => ({
        start: block.minv.blockPosition,
        end: block.maxv.blockPosition + 65535,
    }))
        .reduce((a, b) => a + b.end - b.start, 0);
}
exports.bytesForRegions = bytesForRegions;
// supported adapter types by text indexer
//  ensure that this matches the method found in @jbrowse/text-indexing/util
function supportedIndexingAdapters(type) {
    return [
        'Gff3TabixAdapter',
        'VcfTabixAdapter',
        'Gff3Adapter',
        'VcfAdapter',
    ].includes(type);
}
exports.supportedIndexingAdapters = supportedIndexingAdapters;
function getBpDisplayStr(totalBp) {
    let str;
    if (Math.floor(totalBp / 1000000) > 0) {
        str = `${parseFloat((totalBp / 1000000).toPrecision(3))}Mbp`;
    }
    else if (Math.floor(totalBp / 1000) > 0) {
        str = `${parseFloat((totalBp / 1000).toPrecision(3))}Kbp`;
    }
    else {
        str = `${toLocale(Math.floor(totalBp))}bp`;
    }
    return str;
}
exports.getBpDisplayStr = getBpDisplayStr;
function toLocale(n) {
    return n.toLocaleString('en-US');
}
exports.toLocale = toLocale;
function getTickDisplayStr(totalBp, bpPerPx) {
    let str;
    if (Math.floor(bpPerPx / 1000) > 0) {
        str = `${toLocale(parseFloat((totalBp / 1000000).toFixed(2)))}M`;
    }
    else {
        str = `${toLocale(Math.floor(totalBp))}`;
    }
    return str;
}
exports.getTickDisplayStr = getTickDisplayStr;
function getViewParams(model, exportSVG) {
    // @ts-ignore
    const { dynamicBlocks, staticBlocks, offsetPx } = getContainingView(model);
    const b = (dynamicBlocks === null || dynamicBlocks === void 0 ? void 0 : dynamicBlocks.contentBlocks[0]) || {};
    const staticblock = (staticBlocks === null || staticBlocks === void 0 ? void 0 : staticBlocks.contentBlocks[0]) || {};
    const staticblock1 = (staticBlocks === null || staticBlocks === void 0 ? void 0 : staticBlocks.contentBlocks[1]) || {};
    return {
        offsetPx: exportSVG ? 0 : offsetPx - staticblock.offsetPx,
        offsetPx1: exportSVG ? 0 : offsetPx - staticblock1.offsetPx,
        start: b.start,
        end: b.end,
    };
}
exports.getViewParams = getViewParams;
function getLayoutId({ sessionId, layoutId, }) {
    return sessionId + '-' + layoutId;
}
exports.getLayoutId = getLayoutId;
// Hook from https://usehooks.com/useLocalStorage/
function useLocalStorage(key, initialValue) {
    const [storedValue, setStoredValue] = (0, react_1.useState)(() => {
        if (typeof window === 'undefined') {
            return initialValue;
        }
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        }
        catch (error) {
            console.error(error);
            return initialValue;
        }
    });
    const setValue = (value) => {
        try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            if (typeof window !== 'undefined') {
                window.localStorage.setItem(key, JSON.stringify(valueToStore));
            }
        }
        catch (error) {
            console.error(error);
        }
    };
    return [storedValue, setValue];
}
exports.useLocalStorage = useLocalStorage;
function getUriLink(value) {
    const { uri, baseUri = '' } = value;
    let href;
    try {
        href = new URL(uri, baseUri).href;
    }
    catch (e) {
        href = uri;
    }
    return href;
}
exports.getUriLink = getUriLink;
function getStr(obj) {
    return (0, is_object_1.default)(obj)
        ? (0, types_2.isUriLocation)(obj)
            ? getUriLink(obj)
            : JSON.stringify(obj)
        : String(obj);
}
exports.getStr = getStr;
// heuristic measurement for a column of a @mui/x-data-grid, pass in values from a column
function measureGridWidth(elements) {
    return Math.max(...elements.map(element => Math.min(Math.max(measureText(getStr(element), 14) + 50, 80), 1000)));
}
exports.measureGridWidth = measureGridWidth;
function getEnv(obj) {
    return (0, mobx_state_tree_1.getEnv)(obj);
}
exports.getEnv = getEnv;
