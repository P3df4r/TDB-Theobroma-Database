"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTextSearchAdapter = exports.isRefNameAliasAdapter = exports.isFeatureAdapter = exports.isRegionsAdapter = exports.isSequenceAdapter = exports.BaseSequenceAdapter = exports.BaseFeatureDataAdapter = exports.BaseAdapter = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const mobx_state_tree_1 = require("mobx-state-tree");
const rxjs_2 = require("../util/rxjs");
const util_1 = require("../util");
const configuration_1 = require("../configuration");
const stats_1 = require("../util/stats");
const idMaker_1 = __importDefault(require("../util/idMaker"));
const EmptyConfig = (0, configuration_1.ConfigurationSchema)('empty', {});
class BaseAdapter {
    constructor(config = EmptyConfig.create(), getSubAdapter, pluginManager) {
        this.config = config;
        this.getSubAdapter = getSubAdapter;
        this.pluginManager = pluginManager;
        // note: we use switch on jest here for more simple feature IDs
        // in test environment
        if (typeof jest === 'undefined') {
            const data = (0, mobx_state_tree_1.isStateTreeNode)(config) ? (0, mobx_state_tree_1.getSnapshot)(config) : config;
            this.id = `${(0, idMaker_1.default)(data)}`;
        }
        else {
            this.id = 'test';
        }
    }
    getConf(arg) {
        return (0, configuration_1.readConfObject)(this.config, arg);
    }
}
exports.BaseAdapter = BaseAdapter;
BaseAdapter.capabilities = [];
/**
 * Base class for feature adapters to extend. Defines some methods that
 * subclasses must implement.
 */
class BaseFeatureDataAdapter extends BaseAdapter {
    // public abstract getFeatures(
    //   region: Region,
    //   opts: BaseOptions,
    // ): Observable<Feature> {
    //   return ObservableCreate(observer => {
    //     const records = getRecords(assembly, refName, start, end)
    //     records.forEach(record => {
    //       observer.next(this.recordToFeature(record))
    //     })
    //     observer.complete()
    //   })
    // }
    /**
     * Return "header info" that is fetched from the data file, or other info
     * that would not simply be in the config of the file. The return value can
     * be `{tag:string, data: any}[]` e.g. list of tags with their values which
     * is how VCF,BAM,CRAM return values for getInfo or it can be a nested JSON
     * object
     */
    async getHeader(_opts) {
        return null;
    }
    /**
     * Return info that is primarily used for interpreting the data that is there,
     * primarily in reference to being used for augmenting feature details panels
     */
    async getMetadata(_opts) {
        return null;
    }
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     */
    getFeaturesInRegion(region, opts = {}) {
        return (0, rxjs_2.ObservableCreate)(async (observer) => {
            const hasData = await this.hasDataForRefName(region.refName, opts);
            (0, util_1.checkAbortSignal)(opts.signal);
            if (!hasData) {
                observer.complete();
            }
            else {
                this.getFeatures(region, opts).subscribe(observer);
            }
        });
    }
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters
     * that are frequently called on multiple regions simultaneously may
     * want to implement a more efficient custom version of this method.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */
    getFeaturesInMultipleRegions(regions, opts = {}) {
        return (0, rxjs_1.merge)(...regions.map(region => {
            return this.getFeaturesInRegion(region, opts);
        }));
    }
    /**
     * Check if the store has data for the given reference name.
     * @param refName - Name of the reference sequence
     * @returns Whether data source has data for the given reference name
     */
    async hasDataForRefName(refName, opts = {}) {
        const refNames = await this.getRefNames(opts);
        return refNames.includes(refName);
    }
    async getRegionStats(region, opts) {
        const feats = this.getFeatures(region, opts);
        return (0, stats_1.scoresToStats)(region, feats);
    }
    async getMultiRegionStats(regions = [], opts) {
        if (!regions.length) {
            return (0, stats_1.blankStats)();
        }
        const feats = await Promise.all(regions.map(region => this.getRegionStats(region, opts)));
        const scoreMax = feats.map(a => a.scoreMax).reduce((a, b) => Math.max(a, b));
        const scoreMin = feats.map(a => a.scoreMin).reduce((a, b) => Math.min(a, b));
        const scoreSum = feats.reduce((a, b) => a + b.scoreSum, 0);
        const scoreSumSquares = feats.reduce((a, b) => a + b.scoreSumSquares, 0);
        const featureCount = feats.reduce((a, b) => a + b.featureCount, 0);
        const basesCovered = feats.reduce((a, b) => a + b.basesCovered, 0);
        return (0, stats_1.rectifyStats)({
            scoreMin,
            scoreMax,
            featureCount,
            basesCovered,
            scoreSumSquares,
            scoreSum,
        });
    }
    async estimateRegionsStats(regions, opts) {
        if (!regions.length) {
            throw new Error('No regions to estimate stats for');
        }
        const region = regions[0];
        let lastTime = +Date.now();
        const statsFromInterval = async (length, expansionTime) => {
            const { start, end } = region;
            const sampleCenter = start * 0.75 + end * 0.25;
            const query = {
                ...region,
                start: Math.max(0, Math.round(sampleCenter - length / 2)),
                end: Math.min(Math.round(sampleCenter + length / 2), end),
            };
            const features = await this.getFeatures(query, opts)
                .pipe((0, operators_1.toArray)())
                .toPromise();
            return maybeRecordStats(length, { featureDensity: features.length / length }, features.length, expansionTime);
        };
        const maybeRecordStats = async (interval, stats, statsSampleFeatures, expansionTime) => {
            const refLen = region.end - region.start;
            if (statsSampleFeatures >= 70 || interval * 2 > refLen) {
                return stats;
            }
            else if (expansionTime <= 5000) {
                const currTime = +Date.now();
                expansionTime += currTime - lastTime;
                lastTime = currTime;
                return statsFromInterval(interval * 2, expansionTime);
            }
            else {
                console.warn("Stats estimation reached timeout, or didn't get enough features");
                return { featureDensity: Infinity };
            }
        };
        return statsFromInterval(1000, 0);
    }
}
exports.BaseFeatureDataAdapter = BaseFeatureDataAdapter;
class BaseSequenceAdapter extends BaseFeatureDataAdapter {
    async estimateRegionsStats() {
        return { featureDensity: 0 };
    }
}
exports.BaseSequenceAdapter = BaseSequenceAdapter;
function isSequenceAdapter(thing) {
    return 'getRegions' in thing && 'getFeatures' in thing;
}
exports.isSequenceAdapter = isSequenceAdapter;
function isRegionsAdapter(thing) {
    return 'getRegions' in thing;
}
exports.isRegionsAdapter = isRegionsAdapter;
function isFeatureAdapter(thing) {
    return 'getFeatures' in thing;
}
exports.isFeatureAdapter = isFeatureAdapter;
function isRefNameAliasAdapter(thing) {
    return 'getRefNameAliases' in thing;
}
exports.isRefNameAliasAdapter = isRefNameAliasAdapter;
function isTextSearchAdapter(thing) {
    return 'searchIndex' in thing;
}
exports.isTextSearchAdapter = isTextSearchAdapter;
