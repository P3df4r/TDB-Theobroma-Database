"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const styles_1 = require("@mui/material/styles");
const canvas_sequencer_1 = require("canvas-sequencer");
const server_1 = require("react-dom/server");
const mobx_state_tree_1 = require("mobx-state-tree");
const util_1 = require("../../util");
const RendererType_1 = __importDefault(require("./RendererType"));
const serializableFilterChain_1 = __importDefault(require("./util/serializableFilterChain"));
const ui_1 = require("../../ui");
const ServerSideRenderedContent_1 = __importDefault(require("./ServerSideRenderedContent"));
function isSvgExport(elt) {
    return 'canvasRecordedData' in elt;
}
class ServerSideRenderer extends RendererType_1.default {
    /**
     * directly modifies the render arguments to prepare them to be serialized and
     * sent to the worker.
     *
     * @param args - the arguments passed to render
     * @returns the same object
     */
    serializeArgsInClient(args) {
        return {
            ...args,
            config: (0, mobx_state_tree_1.isStateTreeNode)(args.config)
                ? (0, mobx_state_tree_1.getSnapshot)(args.config)
                : args.config,
            filters: args.filters && args.filters.toJSON().filters,
        };
    }
    /**
     * Deserialize the render results from the worker in the client. Includes
     * hydrating of the React HTML string, and not hydrating the result if SVG is
     * being rendered
     *
     * @param results - the results of the render
     * @param args - the arguments passed to render
     */
    deserializeResultsInClient(results, args) {
        const { html, ...rest } = results;
        // if we are rendering svg, we skip hydration
        if (args.exportSVG) {
            // only return the results if the renderer explicitly has
            // this.supportsSVG support to avoid garbage being rendered in SVG
            // document
            return {
                ...results,
                html: this.supportsSVG
                    ? results.html
                    : '<text y="12" fill="black">SVG export not supported for this track</text>',
            };
        }
        // hydrate results using ServerSideRenderedContent
        return {
            ...rest,
            reactElement: (react_1.default.createElement(ServerSideRenderedContent_1.default, { ...args, ...results, RenderingComponent: this.ReactComponent })),
        };
    }
    /**
     * modifies the passed arguments object to inflate arguments as necessary.
     * called in the worker process.
     *
     * @param args - the converted arguments to modify
     */
    deserializeArgsInWorker(args) {
        const deserialized = { ...args };
        deserialized.config = this.configSchema.create(args.config || {}, {
            pluginManager: this.pluginManager,
        });
        deserialized.filters = new serializableFilterChain_1.default({
            filters: args.filters,
        });
        return deserialized;
    }
    /**
     * Serialize results of the render to send them to the client. Includes
     * rendering React to an HTML string.
     *
     * @param results - object containing the results of calling the `render`
     * method
     * @param args - deserialized render args
     */
    serializeResultsInWorker(results, args) {
        const html = (0, server_1.renderToString)(react_1.default.createElement(styles_1.ThemeProvider, { theme: (0, ui_1.createJBrowseTheme)(args.theme) }, results.reactElement));
        delete results.reactElement;
        return { ...results, html };
    }
    /**
     * Render method called on the client. Serializes args, then calls
     * "CoreRender" with the RPC manager.
     *
     * @param rpcManager - RPC mananger
     * @param args - render args
     */
    async renderInClient(rpcManager, args) {
        const results = (await rpcManager.call(args.sessionId, 'CoreRender', args));
        if (isSvgExport(results)) {
            const { width, height, canvasRecordedData } = results;
            const C2S = await Promise.resolve().then(() => __importStar(require('canvas2svg')));
            const ctx = new C2S.default(width, height);
            const seq = new canvas_sequencer_1.CanvasSequence(canvasRecordedData);
            seq.execute(ctx);
            const str = ctx.getSvg();
            // innerHTML strips the outer <svg> element from returned data, we add
            // our own <svg> element in the view's SVG export
            results.html = str.innerHTML;
            delete results.reactElement;
        }
        return results;
    }
    /**
     * Render method called on the worker. `render` is called here in server-side
     * rendering
     *
     * @param args - serialized render args
     */
    async renderInWorker(args) {
        const { signal, statusCallback = () => { } } = args;
        const deserializedArgs = this.deserializeArgsInWorker(args);
        const results = await (0, util_1.updateStatus)('Rendering plot', statusCallback, () => this.render(deserializedArgs));
        (0, util_1.checkAbortSignal)(signal);
        // serialize the results for passing back to the main thread.
        // these will be transmitted to the main process, and will come out
        // as the result of renderRegionWithWorker.
        return (0, util_1.updateStatus)('Serializing results', statusCallback, () => this.serializeResultsInWorker(results, deserializedArgs));
    }
    async freeResourcesInClient(rpcManager, args) {
        const serializedArgs = this.serializeArgsInClient(args);
        const freed = this.freeResources();
        const freedRpc = (await rpcManager.call(args.sessionId, 'CoreFreeResources', serializedArgs));
        return freed + freedRpc;
    }
}
exports.default = ServerSideRenderer;
