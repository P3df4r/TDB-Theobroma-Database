"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PluggableElementBase_1 = __importDefault(require("./PluggableElementBase"));
const tracks_1 = require("../util/tracks");
const mobx_state_tree_1 = require("mobx-state-tree");
const types_1 = require("../util/types");
const remoteAbortSignals_1 = require("../rpc/remoteAbortSignals");
class RpcMethodType extends PluggableElementBase_1.default {
    constructor(pluginManager) {
        super({ name: '' });
        this.pluginManager = pluginManager;
        this.name = 'UNKNOWN';
    }
    async serializeArguments(args, _rpcDriverClassName) {
        const blobMap = (0, tracks_1.getBlobMap)();
        await this.augmentLocationObjects(args);
        return { ...args, blobMap };
    }
    async serializeNewAuthArguments(loc) {
        const rootModel = this.pluginManager.rootModel;
        // args dont need auth or already have auth
        if (!(0, types_1.isAppRootModel)(rootModel) || loc.internetAccountPreAuthorization) {
            return loc;
        }
        const account = rootModel === null || rootModel === void 0 ? void 0 : rootModel.findAppropriateInternetAccount(loc);
        if (account) {
            loc.internetAccountPreAuthorization =
                await account.getPreAuthorizationInformation(loc);
        }
        return loc;
    }
    async deserializeArguments(serializedArgs, _rpcDriverClassName) {
        if (serializedArgs.blobMap) {
            (0, tracks_1.setBlobMap)(serializedArgs.blobMap);
        }
        const { signal } = serializedArgs;
        if (signal && (0, remoteAbortSignals_1.isRemoteAbortSignal)(signal)) {
            return { ...serializedArgs, signal: (0, remoteAbortSignals_1.deserializeAbortSignal)(signal) };
        }
        return { ...serializedArgs, signal: undefined };
    }
    async serializeReturn(originalReturn, _args, _rpcDriverClassName) {
        return originalReturn;
    }
    async deserializeReturn(serializedReturn, _args, _rpcDriverClassName) {
        let r;
        const { rootModel } = this.pluginManager;
        try {
            r = await serializedReturn;
        }
        catch (error) {
            if ((0, types_1.isAuthNeededException)(error)) {
                // @ts-ignore
                const retryAccount = rootModel === null || rootModel === void 0 ? void 0 : rootModel.createEphemeralInternetAccount(`HTTPBasicInternetAccount-${new URL(error.url).origin}`, {}, error.url);
                throw new types_1.RetryError('Retrying with created internet account', retryAccount.internetAccountId);
            }
            throw error;
        }
        return r;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async augmentLocationObjects(thing) {
        if ((0, mobx_state_tree_1.isStateTreeNode)(thing) && !(0, mobx_state_tree_1.isAlive)(thing)) {
            return thing;
        }
        if ((0, types_1.isUriLocation)(thing)) {
            await this.serializeNewAuthArguments(thing);
        }
        if (Array.isArray(thing)) {
            for (const val of thing) {
                await this.augmentLocationObjects(val);
            }
        }
        if (typeof thing === 'object' && thing !== null) {
            for (const value of Object.values(thing)) {
                if (Array.isArray(value)) {
                    for (const val of value) {
                        await this.augmentLocationObjects(val);
                    }
                }
                else if (typeof value === 'object' && value !== null) {
                    await this.augmentLocationObjects(value);
                }
            }
        }
    }
}
exports.default = RpcMethodType;
