"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBaseTrackModel = void 0;
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const configuration_1 = require("../../configuration");
const util_1 = require("../../util");
const types_1 = require("../../util/types");
const mst_1 = require("../../util/types/mst");
/**
 * #stateModel BaseTrackModel
 * these MST models only exist for tracks that are *shown*.
 * they should contain only UI state for the track, and have
 * a reference to a track configuration (stored under
 * session.configuration.assemblies.get(assemblyName).tracks).
 * note that multiple displayed tracks could use the same
 * configuration.
 */
function createBaseTrackModel(pm, trackType, baseTrackConfig) {
    return mobx_state_tree_1.types
        .model(trackType, {
        /**
         * #property
         */
        id: mst_1.ElementId,
        /**
         * #property
         */
        type: mobx_state_tree_1.types.literal(trackType),
        /**
         * #property
         */
        configuration: (0, configuration_1.ConfigurationReference)(baseTrackConfig),
        /**
         * #property
         */
        minimized: false,
        /**
         * #property
         */
        displays: mobx_state_tree_1.types.array(pm.pluggableMstType('display', 'stateModel')),
    })
        .views(self => ({
        /**
         * #getter
         * determines which webworker to send the track to, currently based on trackId
         */
        get rpcSessionId() {
            return self.configuration.trackId;
        },
        /**
         * #getter
         */
        get name() {
            return (0, configuration_1.getConf)(self, 'name');
        },
        /**
         * #getter
         */
        get textSearchAdapter() {
            return (0, configuration_1.getConf)(self, 'textSearchAdapter');
        },
        /**
         * #getter
         */
        get adapterType() {
            const adapterConfig = (0, configuration_1.getConf)(self, 'adapter');
            if (!adapterConfig) {
                throw new Error(`no adapter configuration provided for ${self.type}`);
            }
            const adapterType = pm.getAdapterType(adapterConfig.type);
            if (!adapterType) {
                throw new Error(`unknown adapter type ${adapterConfig.type}`);
            }
            return adapterType;
        },
        /**
         * #getter
         */
        get viewMenuActions() {
            return self.displays.map(d => d.viewMenuActions).flat();
        },
        /**
         * #getter
         */
        get canConfigure() {
            const session = (0, util_1.getSession)(self);
            return ((0, types_1.isSessionModelWithConfigEditing)(session) &&
                // @ts-ignore
                (session.adminMode ||
                    // @ts-ignore
                    session.sessionTracks.find(track => {
                        return track.trackId === self.configuration.trackId;
                    })));
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setMinimized(flag) {
            self.minimized = flag;
        },
        /**
         * #action
         */
        activateConfigurationUI() {
            const session = (0, util_1.getSession)(self);
            const view = (0, util_1.getContainingView)(self);
            if ((0, types_1.isSessionModelWithConfigEditing)(session)) {
                // @ts-ignore
                const trackConf = session.editTrackConfiguration(self.configuration);
                if (trackConf && trackConf !== self.configuration) {
                    // @ts-ignore
                    view.hideTrack(self.configuration);
                    // @ts-ignore
                    view.showTrack(trackConf);
                }
            }
        },
        /**
         * #action
         */
        showDisplay(displayId, initialSnapshot = {}) {
            const schema = pm.pluggableConfigSchemaType('display');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), displayId);
            const displayType = pm.getDisplayType(conf.type);
            if (!displayType) {
                throw new Error(`unknown display type ${conf.type}`);
            }
            const display = displayType.stateModel.create({
                ...initialSnapshot,
                type: conf.type,
                configuration: conf,
            });
            self.displays.push(display);
        },
        /**
         * #action
         */
        hideDisplay(displayId) {
            const schema = pm.pluggableConfigSchemaType('display');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), displayId);
            const t = self.displays.filter(d => d.configuration === conf);
            (0, mobx_1.transaction)(() => t.forEach(d => self.displays.remove(d)));
            return t.length;
        },
        /**
         * #action
         */
        replaceDisplay(oldId, newId, initialSnapshot = {}) {
            const idx = self.displays.findIndex(d => d.configuration.displayId === oldId);
            if (idx === -1) {
                throw new Error(`could not find display id ${oldId} to replace`);
            }
            const schema = pm.pluggableConfigSchemaType('display');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), newId);
            const displayType = pm.getDisplayType(conf.type);
            if (!displayType) {
                throw new Error(`unknown display type ${conf.type}`);
            }
            self.displays.splice(idx, 1, {
                ...initialSnapshot,
                type: conf.type,
                configuration: conf,
            });
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        trackMenuItems() {
            const menuItems = self.displays
                .map(d => d.trackMenuItems())
                .flat();
            const displayChoices = [];
            const view = (0, util_1.getContainingView)(self);
            const viewType = pm.getViewType(view.type);
            const compatibleDisplayTypes = viewType.displayTypes.map(d => d.name);
            const compatibleDisplays = self.configuration.displays.filter((d) => compatibleDisplayTypes.includes(d.type));
            const shownId = self.displays[0].configuration.displayId;
            if (compatibleDisplays.length > 1) {
                displayChoices.push({ type: 'divider' }, { type: 'subHeader', label: 'Display types' });
                compatibleDisplays.forEach((displayConf) => {
                    displayChoices.push({
                        type: 'radio',
                        label: displayConf.type,
                        checked: displayConf.displayId === shownId,
                        onClick: () => self.replaceDisplay(shownId, displayConf.displayId),
                    });
                });
            }
            return [...menuItems, ...displayChoices];
        },
    }));
}
exports.createBaseTrackModel = createBaseTrackModel;
