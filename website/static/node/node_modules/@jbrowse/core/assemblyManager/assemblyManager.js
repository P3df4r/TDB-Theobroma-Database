"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_state_tree_1 = require("mobx-state-tree");
const util_1 = require("../util");
const mobx_1 = require("mobx");
const configuration_1 = require("../configuration");
const assembly_1 = __importDefault(require("./assembly"));
function assemblyManagerFactory(conf, pm) {
    return mobx_state_tree_1.types
        .model({
        assemblies: mobx_state_tree_1.types.array((0, assembly_1.default)(conf, pm)),
    })
        .views(self => ({
        get(asmName) {
            return self.assemblies.find(asm => asm.hasName(asmName));
        },
        get assemblyNamesList() {
            return this.assemblyList.map(asm => asm.name);
        },
        get assemblyList() {
            // name is the explicit identifier and can be accessed without getConf,
            // hence the union with {name:string}
            const { jbrowse: { assemblies }, session: { sessionAssemblies = [], temporaryAssemblies = [] } = {},
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
             } = (0, mobx_state_tree_1.getParent)(self);
            return [
                ...assemblies,
                ...sessionAssemblies,
                ...temporaryAssemblies,
            ];
        },
        get rpcManager() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return (0, mobx_state_tree_1.getParent)(self).rpcManager;
        },
    }))
        .views(self => ({
        // use this method instead of assemblyManager.get(assemblyName)
        // get an assembly with regions loaded
        async waitForAssembly(assemblyName) {
            if (!assemblyName) {
                throw new Error('no assembly name supplied to waitForAssembly');
            }
            let assembly = self.get(assemblyName);
            if (!assembly) {
                try {
                    await (0, util_1.when)(() => Boolean(self.get(assemblyName)), { timeout: 1000 });
                    assembly = self.get(assemblyName);
                }
                catch (e) {
                    // ignore
                }
            }
            if (!assembly) {
                return undefined;
            }
            await assembly.load();
            await (0, util_1.when)(() => Boolean((assembly === null || assembly === void 0 ? void 0 : assembly.regions) && assembly.refNameAliases) ||
                !!(assembly === null || assembly === void 0 ? void 0 : assembly.error));
            if (assembly.error) {
                throw assembly.error;
            }
            return assembly;
        },
        async getRefNameMapForAdapter(adapterConf, assemblyName, opts) {
            if (assemblyName) {
                const asm = await this.waitForAssembly(assemblyName);
                return asm === null || asm === void 0 ? void 0 : asm.getRefNameMapForAdapter(adapterConf, opts);
            }
            return {};
        },
        async getReverseRefNameMapForAdapter(adapterConf, assemblyName, opts) {
            if (assemblyName) {
                const asm = await this.waitForAssembly(assemblyName);
                return asm === null || asm === void 0 ? void 0 : asm.getReverseRefNameMapForAdapter(adapterConf, opts);
            }
            return {};
        },
        isValidRefName(refName, assemblyName) {
            const assembly = self.get(assemblyName);
            if (assembly) {
                return assembly.isValidRefName(refName);
            }
            throw new Error(`isValidRefName for ${assemblyName} failed, assembly does not exist`);
        },
    }))
        .actions(self => ({
        afterAttach() {
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.reaction)(
            // have to slice it to be properly reacted to
            () => self.assemblyList, assemblyConfigs => {
                self.assemblies.forEach(asm => {
                    if (!asm.configuration) {
                        this.removeAssembly(asm);
                    }
                });
                assemblyConfigs.forEach(assemblyConfig => {
                    const existingAssemblyIdx = self.assemblies.findIndex(assembly => assembly.name === (0, configuration_1.readConfObject)(assemblyConfig, 'name'));
                    if (existingAssemblyIdx === -1) {
                        this.addAssembly(assemblyConfig);
                    }
                });
            }, { fireImmediately: true, name: 'assemblyManagerAfterAttach' }));
        },
        removeAssembly(asm) {
            self.assemblies.remove(asm);
        },
        // this can take an active instance of an assembly, in which case it is
        // referred to, or it can take an identifier e.g. assembly name, which is
        // used as a reference. snapshots cannot be used
        addAssembly(configuration) {
            self.assemblies.push({ configuration });
        },
        replaceAssembly(idx, configuration) {
            self.assemblies[idx] = (0, mobx_state_tree_1.cast)({ configuration });
        },
    }));
}
exports.default = assemblyManagerFactory;
