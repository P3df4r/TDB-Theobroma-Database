"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const io_1 = require("@jbrowse/core/util/io");
const util_1 = require("@jbrowse/core/util");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const tabix_1 = require("@gmod/tabix");
const vcf_1 = __importDefault(require("@gmod/vcf"));
const configuration_1 = require("@jbrowse/core/configuration");
const VcfFeature_1 = __importDefault(require("./VcfFeature"));
class default_1 extends BaseAdapter_1.BaseFeatureDataAdapter {
    async configurePre() {
        const vcfGzLocation = (0, configuration_1.readConfObject)(this.config, 'vcfGzLocation');
        const location = (0, configuration_1.readConfObject)(this.config, ['index', 'location']);
        const indexType = (0, configuration_1.readConfObject)(this.config, ['index', 'indexType']);
        const filehandle = (0, io_1.openLocation)(vcfGzLocation, this.pluginManager);
        const isCSI = indexType === 'CSI';
        const vcf = new tabix_1.TabixIndexedFile({
            filehandle,
            csiFilehandle: isCSI
                ? (0, io_1.openLocation)(location, this.pluginManager)
                : undefined,
            tbiFilehandle: !isCSI
                ? (0, io_1.openLocation)(location, this.pluginManager)
                : undefined,
            chunkCacheSize: 50 * 2 ** 20,
            chunkSizeLimit: 1000000000,
        });
        const header = await vcf.getHeader();
        return {
            filehandle,
            vcf,
            parser: new vcf_1.default({ header }),
        };
    }
    async configure() {
        if (!this.configured) {
            this.configured = this.configurePre().catch(e => {
                this.configured = undefined;
                throw e;
            });
        }
        return this.configured;
    }
    async getRefNames(opts = {}) {
        const { vcf } = await this.configure();
        return vcf.getReferenceSequenceNames(opts);
    }
    async getHeader() {
        const { vcf } = await this.configure();
        return vcf.getHeader();
    }
    async getMetadata() {
        const { parser } = await this.configure();
        return parser.getMetadata();
    }
    getFeatures(query, opts = {}) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const { refName, start, end } = query;
            const { vcf, parser } = await this.configure();
            await vcf.getLines(refName, start, end, {
                lineCallback: (line, fileOffset) => {
                    observer.next(new VcfFeature_1.default({
                        variant: parser.parseLine(line),
                        parser,
                        id: `${this.id}-vcf-${fileOffset}`,
                    }));
                },
                ...opts,
            });
            observer.complete();
        }, opts.signal);
    }
    /**
     * Checks if the data source has data for the given reference sequence,
     * and then gets the features in the region if it does
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     *
     * Also includes a bit of extra logging to warn when fetching a large portion
     * of a VCF
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */
    getFeaturesInMultipleRegions(regions, opts = {}) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            const { vcf } = await this.configure();
            // @ts-ignore
            const bytes = await (0, util_1.bytesForRegions)(regions, vcf.index);
            const { filehandle } = await this.configure();
            const stat = await filehandle.stat();
            let pct = Math.round((bytes / stat.size) * 100);
            if (pct > 100) {
                // this is just a bad estimate, make 100% if it goes over
                pct = 100;
            }
            if (pct > 60) {
                console.warn(`getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`);
            }
            super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer);
        });
    }
    freeResources( /* { region } */) { }
}
exports.default = default_1;
//# sourceMappingURL=VcfTabixAdapter.js.map