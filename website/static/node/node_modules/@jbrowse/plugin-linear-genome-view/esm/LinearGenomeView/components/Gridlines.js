import React from 'react';
import { ContentBlock, ElidedBlock, InterRegionPaddingBlock, } from '@jbrowse/core/util/blockTypes';
import { makeStyles } from 'tss-react/mui';
import { observer } from 'mobx-react';
import { ContentBlock as ContentBlockComponent, ElidedBlock as ElidedBlockComponent, InterRegionPaddingBlock as InterRegionPaddingBlockComponent, } from '../../BaseLinearDisplay/components/Block';
import { makeTicks } from '../util';
const useStyles = makeStyles()(theme => ({
    verticalGuidesZoomContainer: {
        position: 'absolute',
        height: '100%',
        width: '100%',
        zIndex: 1,
        pointerEvents: 'none',
    },
    verticalGuidesContainer: {
        position: 'absolute',
        height: '100%',
        zIndex: 1,
        pointerEvents: 'none',
        display: 'flex',
    },
    tick: {
        position: 'absolute',
        height: '100%',
        width: 1,
    },
    majorTick: {
        background: theme.palette.text.secondary,
    },
    minorTick: {
        background: theme.palette.divider,
    },
}));
const RenderedVerticalGuides = observer(({ model }) => {
    const { classes, cx } = useStyles();
    return (React.createElement(React.Fragment, null, model.staticBlocks.map((block, index) => {
        if (block instanceof ContentBlock) {
            const ticks = makeTicks(block.start, block.end, model.bpPerPx);
            return (React.createElement(ContentBlockComponent, { key: `${block.key}-${index}`, block: block }, ticks.map(tick => {
                const x = (block.reversed
                    ? block.end - tick.base
                    : tick.base - block.start) / model.bpPerPx;
                return (React.createElement("div", { key: tick.base, className: cx(classes.tick, tick.type === 'major' || tick.type === 'labeledMajor'
                        ? classes.majorTick
                        : classes.minorTick), style: { left: x } }));
            })));
        }
        if (block instanceof ElidedBlock) {
            return React.createElement(ElidedBlockComponent, { key: block.key, width: block.widthPx });
        }
        if (block instanceof InterRegionPaddingBlock) {
            return (React.createElement(InterRegionPaddingBlockComponent, { key: block.key, width: block.widthPx, boundary: block.variant === 'boundary' }));
        }
        return null;
    })));
});
function VerticalGuides({ model }) {
    const { classes } = useStyles();
    // find the block that needs pinning to the left side for context
    const offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
    return (React.createElement("div", { className: classes.verticalGuidesZoomContainer, style: {
            transform: model.scaleFactor !== 1 ? `scaleX(${model.scaleFactor})` : undefined,
        } },
        React.createElement("div", { className: classes.verticalGuidesContainer, style: {
                left: offsetLeft,
                width: model.staticBlocks.totalWidthPx,
            } },
            React.createElement(RenderedVerticalGuides, { model: model }))));
}
export default observer(VerticalGuides);
//# sourceMappingURL=Gridlines.js.map