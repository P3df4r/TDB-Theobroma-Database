import { Paper, Typography } from '@mui/material';
import { makeStyles } from 'tss-react/mui';
import { ContentBlock, ElidedBlock, InterRegionPaddingBlock, } from '@jbrowse/core/util/blockTypes';
import { observer } from 'mobx-react';
import React from 'react';
import { ContentBlock as ContentBlockComponent, ElidedBlock as ElidedBlockComponent, InterRegionPaddingBlock as InterRegionPaddingBlockComponent, } from '../../BaseLinearDisplay/components/Block';
import { makeTicks } from '../util';
import { getTickDisplayStr } from '@jbrowse/core/util';
const useStyles = makeStyles()(theme => ({
    scaleBarContainer: {
        overflow: 'hidden',
        position: 'relative',
    },
    scaleBarZoomContainer: {
        position: 'relative',
        zIndex: 1,
    },
    scaleBar: {
        position: 'absolute',
        display: 'flex',
        pointerEvents: 'none',
    },
    majorTickLabel: {
        fontSize: '11px',
        zIndex: 1,
        background: theme.palette.background.paper,
        lineHeight: 'normal',
        pointerEvents: 'none',
    },
    tick: {
        position: 'absolute',
        width: 0,
        display: 'flex',
        justifyContent: 'center',
        pointerEvents: 'none',
    },
    refLabel: {
        fontSize: '11px',
        position: 'absolute',
        left: '2px',
        top: '-1px',
        fontWeight: 'bold',
        lineHeight: 'normal',
        zIndex: 1,
        pointerEvents: 'none',
        background: theme.palette.background.paper,
    },
}));
const RenderedRefNameLabels = observer(({ model }) => {
    const { classes } = useStyles();
    // find the block that needs pinning to the left side for context
    let lastLeftBlock = 0;
    model.staticBlocks.forEach((block, i) => {
        if (block.offsetPx - model.offsetPx < 0) {
            lastLeftBlock = i;
        }
    });
    return (React.createElement(React.Fragment, null, model.staticBlocks.map((block, index) => {
        return block instanceof ContentBlock &&
            (block.isLeftEndOfDisplayedRegion || index === lastLeftBlock) ? (React.createElement(Typography, { key: `refLabel-${block.key}-${index}`, style: {
                left: index === lastLeftBlock
                    ? Math.max(0, -model.offsetPx)
                    : block.offsetPx - model.offsetPx - 1,
                paddingLeft: index === lastLeftBlock ? 0 : 1,
            }, className: classes.refLabel, "data-testid": `refLabel-${block.refName}` }, block.refName)) : null;
    })));
});
const RenderedScaleBarLabels = observer(({ model }) => {
    const { classes } = useStyles();
    const { bpPerPx, staticBlocks } = model;
    return (React.createElement(React.Fragment, null, staticBlocks.map((block, index) => {
        const { reversed, start, end, key, widthPx } = block;
        if (block instanceof ContentBlock) {
            const ticks = makeTicks(start, end, bpPerPx, true, false);
            return (React.createElement(ContentBlockComponent, { key: `${key}-${index}`, block: block }, ticks.map(tick => {
                if (tick.type === 'major') {
                    const x = (reversed ? end - tick.base : tick.base - start) / bpPerPx;
                    const baseNumber = tick.base + 1;
                    return (React.createElement("div", { key: tick.base, className: classes.tick, style: { left: x } }, baseNumber ? (React.createElement(Typography, { className: classes.majorTickLabel }, getTickDisplayStr(baseNumber, bpPerPx))) : null));
                }
                return null;
            })));
        }
        if (block instanceof ElidedBlock) {
            return React.createElement(ElidedBlockComponent, { key: key, width: widthPx });
        }
        if (block instanceof InterRegionPaddingBlock) {
            return (React.createElement(InterRegionPaddingBlockComponent, { key: key, width: widthPx, style: { background: 'none' }, boundary: block.variant === 'boundary' }));
        }
        return null;
    })));
});
const ScaleBar = React.forwardRef(({ model, style, className, ...other }, ref) => {
    const { classes, cx } = useStyles();
    const offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
    return (React.createElement(Paper, { "data-resizer": "true" // used to avoid click-and-drag scrolls on trackscontainer
        , className: cx(classes.scaleBarContainer, className), variant: "outlined", ref: ref, style: style, ...other },
        React.createElement("div", { className: classes.scaleBarZoomContainer, style: {
                transform: model.scaleFactor !== 1
                    ? `scaleX(${model.scaleFactor})`
                    : undefined,
            } },
            React.createElement("div", { className: classes.scaleBar, style: {
                    left: offsetLeft - 1,
                    width: model.staticBlocks.totalWidthPx,
                    ...style,
                } },
                React.createElement(RenderedScaleBarLabels, { model: model }))),
        React.createElement(RenderedRefNameLabels, { model: model })));
});
export default observer(ScaleBar);
//# sourceMappingURL=ScaleBar.js.map