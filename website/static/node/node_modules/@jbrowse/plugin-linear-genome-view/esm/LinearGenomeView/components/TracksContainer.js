import React, { useEffect, useRef, useState } from 'react';
import { makeStyles } from 'tss-react/mui';
import { observer } from 'mobx-react';
import normalizeWheel from 'normalize-wheel';
// locals
import { SCALE_BAR_HEIGHT } from '..';
import RubberBand from './RubberBand';
import ScaleBar from './ScaleBar';
import Gridlines from './Gridlines';
import CenterLine from './CenterLine';
const useStyles = makeStyles()({
    tracksContainer: {
        position: 'relative',
        overflow: 'hidden',
    },
    spacer: {
        position: 'relative',
        height: 3,
    },
});
function TracksContainer({ children, model, }) {
    const { classes } = useStyles();
    // refs are to store these variables to avoid repeated rerenders associated
    // with useState/setState
    const delta = useRef(0);
    const scheduled = useRef(false);
    const timeout = useRef();
    const ref = useRef(null);
    const prevX = useRef(0);
    const [mouseDragging, setMouseDragging] = useState(false);
    useEffect(() => {
        let cleanup = () => { };
        function globalMouseMove(event) {
            event.preventDefault();
            const currX = event.clientX;
            const distance = currX - prevX.current;
            if (distance) {
                // use rAF to make it so multiple event handlers aren't fired per-frame
                // see https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/
                if (!scheduled.current) {
                    scheduled.current = true;
                    window.requestAnimationFrame(() => {
                        model.horizontalScroll(-distance);
                        scheduled.current = false;
                        prevX.current = event.clientX;
                    });
                }
            }
        }
        function globalMouseUp() {
            prevX.current = 0;
            if (mouseDragging) {
                setMouseDragging(false);
            }
        }
        if (mouseDragging) {
            window.addEventListener('mousemove', globalMouseMove, true);
            window.addEventListener('mouseup', globalMouseUp, true);
            cleanup = () => {
                window.removeEventListener('mousemove', globalMouseMove, true);
                window.removeEventListener('mouseup', globalMouseUp, true);
            };
        }
        return cleanup;
    }, [model, mouseDragging, prevX]);
    function mouseDown(event) {
        // check if clicking a draggable element or a resize handle
        const target = event.target;
        if (target.draggable || target.dataset.resizer) {
            return;
        }
        // otherwise do click and drag scroll
        if (event.button === 0) {
            prevX.current = event.clientX;
            setMouseDragging(true);
        }
    }
    // this local mouseup is used in addition to the global because sometimes
    // the global add/remove are not called in time, resulting in issue #533
    function mouseUp(event) {
        event.preventDefault();
        setMouseDragging(false);
    }
    function mouseLeave(event) {
        event.preventDefault();
    }
    useEffect(() => {
        const curr = ref.current;
        // if ctrl is held down, zoom in with y-scroll
        // else scroll horizontally with x-scroll
        function onWheel(origEvent) {
            const event = normalizeWheel(origEvent);
            if (origEvent.ctrlKey === true) {
                origEvent.preventDefault();
                delta.current += event.pixelY / 500;
                model.setScaleFactor(delta.current < 0 ? 1 - delta.current : 1 / (1 + delta.current));
                if (timeout.current) {
                    clearTimeout(timeout.current);
                }
                timeout.current = setTimeout(() => {
                    model.setScaleFactor(1);
                    model.zoomTo(delta.current > 0
                        ? model.bpPerPx * (1 + delta.current)
                        : model.bpPerPx / (1 - delta.current));
                    delta.current = 0;
                }, 300);
            }
            else {
                // this is needed to stop the event from triggering "back button
                // action" on MacOSX etc.  but is a heuristic to avoid preventing the
                // inner-track scroll behavior
                if (Math.abs(event.pixelX) > Math.abs(2 * event.pixelY)) {
                    origEvent.preventDefault();
                }
                delta.current += event.pixelX;
                if (!scheduled.current) {
                    // use rAF to make it so multiple event handlers aren't fired per-frame
                    // see https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/
                    scheduled.current = true;
                    window.requestAnimationFrame(() => {
                        model.horizontalScroll(delta.current);
                        delta.current = 0;
                        scheduled.current = false;
                    });
                }
            }
        }
        if (curr) {
            curr.addEventListener('wheel', onWheel);
            return () => {
                curr.removeEventListener('wheel', onWheel);
            };
        }
        return () => { };
    }, [model]);
    return (React.createElement("div", { ref: ref, "data-testid": "trackContainer", className: classes.tracksContainer, onMouseDown: mouseDown, onMouseUp: mouseUp, onMouseLeave: mouseLeave },
        model.showGridlines ? React.createElement(Gridlines, { model: model }) : null,
        model.showCenterLine ? React.createElement(CenterLine, { model: model }) : null,
        React.createElement(RubberBand, { model: model, ControlComponent: React.createElement(ScaleBar, { model: model, style: { height: SCALE_BAR_HEIGHT, boxSizing: 'border-box' } }) }),
        children));
}
export default observer(TracksContainer);
//# sourceMappingURL=TracksContainer.js.map