import React, { useEffect, useRef } from 'react';
import { Paper } from '@mui/material';
import { makeStyles } from 'tss-react/mui';
import { observer } from 'mobx-react';
import { isAlive } from 'mobx-state-tree';
import { getConf } from '@jbrowse/core/configuration';
import { ResizeHandle, ErrorMessage } from '@jbrowse/core/ui';
import { ErrorBoundary } from 'react-error-boundary';
import { useDebouncedCallback } from '@jbrowse/core/util';
import TrackLabel from './TrackLabel';
const useStyles = makeStyles()({
    root: {
        marginTop: 2,
    },
    resizeHandle: {
        height: 3,
        boxSizing: 'border-box',
        position: 'relative',
        zIndex: 2,
    },
    overlay: {
        pointerEvents: 'none',
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        zIndex: 3,
    },
    trackLabel: {
        zIndex: 3,
    },
    // aligns with block bounderies. check for example the breakpoint split view
    // demo to see if features align if wanting to change things
    renderingComponentContainer: {
        position: 'absolute',
        // -1 offset because of the 1px border of the Paper
        left: -1,
        height: '100%',
        width: '100%',
    },
    trackLabelOffset: {
        position: 'relative',
        display: 'inline-block',
    },
    trackLabelOverlap: {
        position: 'absolute',
    },
    trackRenderingContainer: {
        overflowY: 'auto',
        overflowX: 'hidden',
        whiteSpace: 'nowrap',
        position: 'relative',
        background: 'none',
        zIndex: 2,
    },
});
const TrackContainerLabel = observer(({ model, view }) => {
    const { classes, cx } = useStyles();
    const display = model.displays[0];
    const { trackLabel, trackLabelOverlap, trackLabelOffset } = classes;
    const labelStyle = view.trackLabels !== 'overlapping' || display.prefersOffset
        ? trackLabelOffset
        : trackLabelOverlap;
    return view.trackLabels !== 'hidden' ? (React.createElement(TrackLabel, { track: model, className: cx(trackLabel, labelStyle) })) : null;
});
function TrackContainer({ model, track, }) {
    const { classes } = useStyles();
    const display = track.displays[0];
    const { horizontalScroll, draggingTrackId, moveTrack } = model;
    const { height, RenderingComponent, DisplayBlurb } = display;
    const trackId = getConf(track, 'trackId');
    const ref = useRef(null);
    const dimmed = draggingTrackId !== undefined && draggingTrackId !== display.id;
    const minimized = track.minimized;
    const debouncedOnDragEnter = useDebouncedCallback(() => {
        if (isAlive(display) && dimmed) {
            moveTrack(draggingTrackId, track.id);
        }
    }, 100);
    useEffect(() => {
        if (ref.current) {
            model.trackRefs[trackId] = ref.current;
        }
        return () => {
            delete model.trackRefs[trackId];
        };
    }, [model.trackRefs, trackId]);
    return (React.createElement(Paper, { className: classes.root, variant: "outlined" },
        React.createElement(TrackContainerLabel, { model: track, view: model }),
        React.createElement(ErrorBoundary, { key: track.id, FallbackComponent: ({ error }) => React.createElement(ErrorMessage, { error: error }) },
            React.createElement("div", { className: classes.trackRenderingContainer, style: { height: minimized ? 20 : height }, onScroll: evt => display.setScrollTop(evt.currentTarget.scrollTop), onDragEnter: debouncedOnDragEnter, "data-testid": `trackRenderingContainer-${model.id}-${trackId}` }, !minimized ? (React.createElement(React.Fragment, null,
                React.createElement("div", { ref: ref, className: classes.renderingComponentContainer, style: { transform: `scaleX(${model.scaleFactor})` } },
                    React.createElement(RenderingComponent, { model: display, onHorizontalScroll: horizontalScroll })),
                DisplayBlurb ? (React.createElement("div", { style: {
                        position: 'absolute',
                        left: 0,
                        top: display.height - 20,
                    } },
                    React.createElement(DisplayBlurb, { model: display }))) : null)) : null)),
        React.createElement("div", { className: classes.overlay, style: {
                height: display.height,
                background: dimmed ? 'rgba(0, 0, 0, 0.4)' : undefined,
            }, onDragEnter: debouncedOnDragEnter }),
        React.createElement(ResizeHandle, { onDrag: display.resizeHeight, className: classes.resizeHandle })));
}
export default observer(TrackContainer);
//# sourceMappingURL=TrackContainer.js.map