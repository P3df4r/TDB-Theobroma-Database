import React from 'react';
import { MenuItem } from '@jbrowse/core/ui';
import { Stats } from '@jbrowse/core/data_adapters/BaseAdapter';
import { BaseBlock } from '@jbrowse/core/util/blockTypes';
import { Region } from '@jbrowse/core/util/types';
import CompositeMap from '@jbrowse/core/util/compositeMap';
import { Feature } from '@jbrowse/core/util/simpleFeature';
import { Instance } from 'mobx-state-tree';
import { ExportSvgOptions } from '../../LinearGenomeView';
export interface Layout {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    name: string;
}
type LayoutRecord = [number, number, number, number];
export declare const BaseLinearDisplay: import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").ISimpleType<string>;
    rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
} & {
    /**
     * #property
     */
    height: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
    /**
     * #property
     * updated via autorun
     */
    blockState: import("mobx-state-tree").IMapType<import("mobx-state-tree").IModelType<{
        key: import("mobx-state-tree").ISimpleType<string>;
        region: import("mobx-state-tree").IModelType<{
            refName: import("mobx-state-tree").ISimpleType<string>;
            start: import("mobx-state-tree").ISimpleType<number>;
            end: import("mobx-state-tree").ISimpleType<number>;
            reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
        } & {
            assemblyName: import("mobx-state-tree").ISimpleType<string>;
        }, {
            setRefName(newRefName: string): void;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        reloadFlag: import("mobx-state-tree").IType<number | undefined, number, number>;
        isLeftEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
        isRightEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    }, {
        renderInProgress: AbortController | undefined;
        filled: boolean;
        reactElement: React.ReactElement<any, string | React.JSXElementConstructor<any>> | undefined;
        features: Map<string, Feature> | undefined;
        layout: any;
        status: string;
        error: unknown;
        message: string | undefined;
        maxHeightReached: boolean;
        ReactComponent: ({ model, }: {
            model: any;
        }) => any;
        renderProps: any;
    } & {
        doReload(): void;
        afterAttach(): void;
        setStatus(message: string): void;
        /**
         * #property
         */
        setLoading(abortController: AbortController): void;
        setMessage(messageText: string): void;
        setRendered(props: {
            reactElement: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
            features: Map<string, Feature>;
            layout: any;
            maxHeightReached: boolean;
            renderProps: any;
        } | undefined): void;
        setError(error: unknown): void;
        reload(): void;
        /**
         * #getter
         */
        beforeDestroy(): void;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    /**
     * #property
     */
    userBpPerPxLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    /**
     * #property
     */
    userByteSizeLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
}, {
    rendererTypeName: string;
    error: unknown;
} & {
    readonly RenderingComponent: React.FC<{
        model: {
            id: string;
            type: string;
            rpcDriverName: string | undefined;
        } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
            rendererTypeName: string;
            error: unknown;
        } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
            rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
        }, {
            rendererTypeName: string;
            error: unknown;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
        onHorizontalScroll?: Function | undefined;
        blockState?: Record<string, any> | undefined;
    }>;
    readonly DisplayBlurb: React.FC<{
        model: {
            id: string;
            type: string;
            rpcDriverName: string | undefined;
        } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
            rendererTypeName: string;
            error: unknown;
        } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
            rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
        }, {
            rendererTypeName: string;
            error: unknown;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    }> | null;
    readonly adapterConfig: any;
    readonly parentTrack: any;
    renderProps(): any;
    readonly rendererType: import("@jbrowse/core/pluggableElementTypes").RendererType;
    readonly DisplayMessageComponent: React.FC<any> | undefined;
    trackMenuItems(): MenuItem[];
    readonly viewMenuActions: MenuItem[];
    regionCannotBeRendered(): undefined;
} & {
    setError(error?: unknown): void; /**
     * #getter
     * returns a string feature ID if the globally-selected object
     * is probably a feature
     */
    setRpcDriverName(rpcDriverName: string): void;
    reload(): void;
} & {
    currBpPerPx: number;
    message: string;
    featureIdUnderMouse: string | undefined;
    contextMenuFeature: Feature | undefined;
    scrollTop: number;
    estimatedRegionStatsP: Promise<Stats> | undefined;
    estimatedRegionStats: Stats | undefined;
} & {
    /**
     * #getter
     */
    readonly blockType: "dynamicBlocks" | "staticBlocks";
    /**
     * #getter
     */
    readonly blockDefinitions: import("@jbrowse/core/util/blockTypes").BlockSet;
} & {
    /**
     * #getter
     * how many milliseconds to wait for the display to
     * "settle" before re-rendering a block
     */
    readonly renderDelay: number;
    /**
     * #getter
     */
    readonly TooltipComponent: React.FC<any>;
    /**
     * #getter
     * returns a string feature ID if the globally-selected object
     * is probably a feature
     */
    readonly selectedFeatureId: string | undefined;
    /**
     * #getter
     * if a display-level message should be displayed instead of the blocks,
     * make this return a react component
     */
    readonly DisplayMessageComponent: React.FC<any> | undefined;
} & {
    /**
     * #getter
     * a CompositeMap of `featureId -> feature obj` that
     * just looks in all the block data for that feature
     */
    readonly features: CompositeMap<string, Feature>;
    /**
     * #getter
     */
    readonly featureUnderMouse: Feature | undefined;
    /**
     * #getter
     */
    getFeatureOverlapping(blockKey: string, x: number, y: number): any;
    /**
     * #getter
     */
    getFeatureByID(blockKey: string, id: string): LayoutRecord | undefined;
    /**
     * #getter
     */
    searchFeatureByID(id: string): LayoutRecord | undefined;
    /**
     * #getter
     */
    readonly currentBytesRequested: number;
    /**
     * #getter
     */
    readonly currentFeatureScreenDensity: number;
    /**
     * #getter
     */
    readonly maxFeatureScreenDensity: any;
    /**
     * #getter
     */
    readonly estimatedStatsReady: boolean;
    /**
     * #getter
     */
    readonly maxAllowableBytes: number;
} & {
    /**
     * #action
     */
    setMessage(message: string): void;
    afterAttach(): void;
    /**
     * #action
     */
    estimateRegionsStats(regions: Region[], opts: {
        headers?: Record<string, string>;
        signal?: AbortSignal;
        filters?: string[];
    }): Promise<{}>;
    /**
     * #action
     */
    setRegionStatsP(p?: Promise<Stats>): void;
    /**
     * #action
     */
    setRegionStats(estimatedRegionStats?: Stats): void;
    /**
     * #action
     */
    clearRegionStats(): void;
    /**
     * #action
     */
    setHeight(displayHeight: number): number;
    /**
     * #action
     */
    resizeHeight(distance: number): number;
    /**
     * #action
     */
    setScrollTop(scrollTop: number): void;
    /**
     * #action
     */
    updateStatsLimit(stats: Stats): void;
    /**
     * #action
     */
    addBlock(key: string, block: BaseBlock): void;
    /**
     * #action
     */
    setCurrBpPerPx(n: number): void;
    /**
     * #action
     */
    deleteBlock(key: string): void;
    /**
     * #action
     */
    selectFeature(feature: Feature): void;
    /**
     * #action
     */
    clearFeatureSelection(): void;
    /**
     * #action
     */
    setFeatureIdUnderMouse(feature: string | undefined): void;
    /**
     * #action
     */
    reload(): void;
    /**
     * #action
     */
    setContextMenuFeature(feature?: Feature): void;
} & {
    /**
     * #getter
     * region is too large if:
     * - stats are ready
     * - region is greater than 20kb (don't warn when zoomed in less than that)
     * - and bytes is greater than max allowed bytes or density greater than max density
     */
    readonly regionTooLarge: boolean;
    /**
     * #getter
     * only shows a message of bytes requested is defined, the feature density
     * based stats don't produce any helpful message besides to zoom in
     */
    readonly regionTooLargeReason: string;
} & {
    /**
     * #action
     */
    reload(): Promise<void>;
    afterAttach(): void;
} & {
    /**
     * #method
     */
    regionCannotBeRenderedText(_region: Region): "" | "Force load to see features";
    /**
     * #method
     * @param region -
     * @returns falsy if the region is fine to try rendering. Otherwise,
     *  return a react node + string of text.
     *  string of text describes why it cannot be rendered
     *  react node allows user to force load at current setting
     */
    regionCannotBeRendered(_region: Region): JSX.Element | null;
    /**
     * #method
     */
    trackMenuItems(): MenuItem[];
    /**
     * #method
     */
    contextMenuItems(): {
        label: string;
        icon: import("@mui/material/OverridableComponent").OverridableComponent<import("@mui/material").SvgIconTypeMap<{}, "svg">> & {
            muiName: string;
        };
        onClick: () => void;
    }[];
    /**
     * #method
     */
    renderProps(): any;
} & {
    /**
     * #method
     */
    renderSvg(opts: ExportSvgOptions & {
        overrideHeight: number;
    }): Promise<JSX.Element>;
}, import("mobx-state-tree")._NotCustomized, {
    type: string;
    height: number;
    id: string;
    rpcDriverName: string | undefined;
    userBpPerPxLimit: number | undefined;
    userByteSizeLimit: number | undefined;
}>;
export type BaseLinearDisplayStateModel = typeof BaseLinearDisplay;
export type BaseLinearDisplayModel = Instance<BaseLinearDisplayStateModel>;
export {};
