"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderToSvg = void 0;
const react_1 = __importDefault(require("react"));
const server_1 = require("react-dom/server");
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const Base1DViewModel_1 = __importDefault(require("@jbrowse/core/util/Base1DViewModel"));
// locals
const Ruler_1 = __importDefault(require("./Ruler"));
const __1 = require("..");
const OverviewScaleBar_1 = require("./OverviewScaleBar");
function ScaleBar({ model, fontSize }) {
    const { offsetPx, dynamicBlocks: { totalWidthPxWithoutBorders: totalWidthPx, totalBp }, } = model;
    const displayBp = (0, util_1.getBpDisplayStr)(totalBp);
    const x0 = Math.max(-offsetPx, 0);
    const x1 = x0 + totalWidthPx;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("line", { x1: x0, x2: x1, y1: 10, y2: 10, stroke: "black" }),
        react_1.default.createElement("line", { x1: x0, x2: x0, y1: 5, y2: 15, stroke: "black" }),
        react_1.default.createElement("line", { x1: x1, x2: x1, y1: 5, y2: 15, stroke: "black" }),
        react_1.default.createElement("text", { x: x0 + (x1 - x0) / 2, y: fontSize * 2, textAnchor: "middle", fontSize: fontSize }, displayBp)));
}
function SVGRuler({ model, fontSize, width, }) {
    const { dynamicBlocks: { contentBlocks }, offsetPx: viewOffsetPx, bpPerPx, } = model;
    const renderRuler = contentBlocks.length < 5;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("defs", null,
            react_1.default.createElement("clipPath", { id: "clip-ruler" },
                react_1.default.createElement("rect", { x: 0, y: 0, width: width, height: 20 }))),
        contentBlocks.map(block => {
            const { key, start, end, reversed, offsetPx, refName } = block;
            const offsetLeft = offsetPx - viewOffsetPx;
            return (react_1.default.createElement("g", { key: `${key}`, transform: `translate(${offsetLeft} 0)` },
                react_1.default.createElement("text", { x: offsetLeft / bpPerPx, y: fontSize, fontSize: fontSize }, refName),
                renderRuler ? (react_1.default.createElement("g", { transform: "translate(0 20)", clipPath: "url(#clip-ruler)" },
                    react_1.default.createElement(Ruler_1.default, { start: start, end: end, bpPerPx: bpPerPx, reversed: reversed }))) : (react_1.default.createElement("line", { strokeWidth: 1, stroke: "black", x1: start / bpPerPx, x2: end / bpPerPx, y1: 20, y2: 20 }))));
        })));
}
const fontSize = 15;
const rulerHeight = 50;
const textHeight = fontSize + 5;
const paddingHeight = 20;
const headerHeight = textHeight + 20;
const cytobandHeightIfExists = 100;
const totalHeight = (tracks) => {
    return tracks.reduce((accum, track) => {
        const display = track.displays[0];
        return accum + display.height + paddingHeight + textHeight;
    }, 0);
};
// SVG component, ruler and assembly name
const SVGHeader = ({ model }) => {
    const { width, assemblyNames, showCytobands, displayedRegions } = model;
    const { assemblyManager } = (0, util_1.getSession)(model);
    const assemblyName = assemblyNames.length > 1 ? '' : assemblyNames[0];
    const assembly = assemblyManager.get(assemblyName);
    const overview = Base1DViewModel_1.default.create({
        displayedRegions: JSON.parse(JSON.stringify(displayedRegions)),
        interRegionPaddingWidth: 0,
        minimumBlockWidth: model.minimumBlockWidth,
    });
    const visibleRegions = model.dynamicBlocks.contentBlocks;
    overview.setVolatileWidth(width);
    overview.showAllRegions();
    const block = overview.dynamicBlocks.contentBlocks[0];
    const first = visibleRegions[0];
    const firstOverviewPx = overview.bpToPx({
        ...first,
        coord: first.reversed ? first.end : first.start,
    }) || 0;
    const last = visibleRegions[visibleRegions.length - 1];
    const lastOverviewPx = overview.bpToPx({
        ...last,
        coord: last.reversed ? last.start : last.end,
    }) || 0;
    const cytobandHeight = showCytobands ? cytobandHeightIfExists : 0;
    return (react_1.default.createElement("g", { id: "header" },
        react_1.default.createElement("text", { x: 0, y: fontSize, fontSize: fontSize }, assemblyName),
        showCytobands ? (react_1.default.createElement("g", { transform: `translate(0 ${rulerHeight})` },
            react_1.default.createElement(OverviewScaleBar_1.Cytobands, { overview: overview, assembly: assembly, block: block }),
            react_1.default.createElement("rect", { stroke: "red", fill: "rgb(255,0,0,0.1)", width: Math.max(lastOverviewPx - firstOverviewPx, 0.5), height: __1.HEADER_OVERVIEW_HEIGHT - 1, x: firstOverviewPx, y: 0.5 }),
            react_1.default.createElement("g", { transform: `translate(0,${__1.HEADER_OVERVIEW_HEIGHT})` },
                react_1.default.createElement(OverviewScaleBar_1.Polygon, { overview: overview, model: model, useOffset: false })))) : null,
        react_1.default.createElement("g", { transform: `translate(0 ${fontSize + cytobandHeight})` },
            react_1.default.createElement(ScaleBar, { model: model, fontSize: fontSize })),
        react_1.default.createElement("g", { transform: `translate(0 ${rulerHeight + cytobandHeight})` },
            react_1.default.createElement(SVGRuler, { model: model, fontSize: fontSize, width: width }))));
};
// SVG component, region separator
const SVGRegionSeparators = ({ model, height, }) => {
    const { dynamicBlocks, offsetPx, interRegionPaddingWidth } = model;
    return (react_1.default.createElement(react_1.default.Fragment, null, dynamicBlocks.contentBlocks.slice(1).map(block => (react_1.default.createElement("rect", { key: block.key, x: block.offsetPx - offsetPx - interRegionPaddingWidth, width: interRegionPaddingWidth, y: 0, height: height, stroke: "none", fill: "grey" })))));
};
// SVG component, tracks
function SVGTracks({ displayResults, model, offset, }) {
    return (react_1.default.createElement(react_1.default.Fragment, null, displayResults.map(({ track, result }) => {
        const current = offset;
        const trackName = (0, configuration_1.getConf)(track, 'name') ||
            `Reference sequence (${(0, configuration_1.readConfObject)((0, mobx_state_tree_1.getParent)(track.configuration), 'displayName') ||
                (0, configuration_1.readConfObject)((0, mobx_state_tree_1.getParent)(track.configuration), 'name')})`;
        const display = track.displays[0];
        offset += display.height + paddingHeight + textHeight;
        return (react_1.default.createElement("g", { key: track.configuration.trackId, transform: `translate(0 ${current})` },
            react_1.default.createElement("text", { fontSize: fontSize, x: Math.max(-model.offsetPx, 0) }, trackName),
            react_1.default.createElement("g", { transform: `translate(0 ${textHeight})` },
                result,
                react_1.default.createElement(SVGRegionSeparators, { model: model, height: display.height }))));
    })));
}
// render LGV to SVG
async function renderToSvg(model, opts) {
    await (0, mobx_1.when)(() => model.initialized);
    const { Wrapper = ({ children }) => react_1.default.createElement(react_1.default.Fragment, null, children) } = opts;
    const { width, tracks, showCytobands } = model;
    const shift = 50;
    const offset = headerHeight +
        rulerHeight +
        (showCytobands ? cytobandHeightIfExists : 0) +
        20;
    const height = totalHeight(tracks) + offset;
    const displayResults = await Promise.all(tracks.map(async (track) => {
        const display = track.displays[0];
        await (0, mobx_1.when)(() => (display.ready !== undefined ? display.ready : true));
        const result = await display.renderSvg(opts);
        return { track, result };
    }));
    // the xlink namespace is used for rendering <image> tag
    return (0, server_1.renderToStaticMarkup)(react_1.default.createElement(Wrapper, null,
        react_1.default.createElement("svg", { width: width, height: height, xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", viewBox: [0, 0, width + shift * 2, height].toString() },
            react_1.default.createElement("rect", { width: width + shift * 2, height: height, fill: "white" }),
            react_1.default.createElement("g", { stroke: "none", transform: `translate(${shift} ${fontSize})` },
                react_1.default.createElement(SVGHeader, { model: model }),
                react_1.default.createElement(SVGTracks, { model: model, displayResults: displayResults, offset: offset })))));
}
exports.renderToSvg = renderToSvg;
//# sourceMappingURL=LinearGenomeViewSvg.js.map