import React from 'react';
import { Region } from '@jbrowse/core/util/types';
import { MenuItem } from '@jbrowse/core/ui';
import BaseResult from '@jbrowse/core/TextSearch/BaseResults';
import { BlockSet, BaseBlock } from '@jbrowse/core/util/blockTypes';
import { Instance } from 'mobx-state-tree';
import PluginManager from '@jbrowse/core/PluginManager';
import { renderToSvg } from './components/LinearGenomeViewSvg';
import RefNameAutocomplete from './components/RefNameAutocomplete';
import SearchBox from './components/SearchBox';
import ZoomControls from './components/ZoomControls';
import LinearGenomeView from './components/LinearGenomeView';
export interface BpOffset {
    refName?: string;
    index: number;
    offset: number;
    start?: number;
    end?: number;
    coord?: number;
    reversed?: boolean;
    assemblyName?: string;
    oob?: boolean;
}
export interface ExportSvgOptions {
    rasterizeLayers?: boolean;
    filename?: string;
    Wrapper?: React.FC<any>;
}
export interface NavLocation {
    refName: string;
    start?: number;
    end?: number;
    assemblyName?: string;
}
export declare const HEADER_BAR_HEIGHT = 48;
export declare const HEADER_OVERVIEW_HEIGHT = 20;
export declare const SCALE_BAR_HEIGHT = 17;
export declare const RESIZE_HANDLE_HEIGHT = 3;
export declare const INTER_REGION_PADDING_WIDTH = 2;
export declare const SPACING = 7;
export declare const WIDGET_HEIGHT = 32;
/**
 * #stateModel LinearGenomeView
 */
export declare function stateModelFactory(pluginManager: PluginManager): import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    displayName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    minimized: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
} & {
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").IType<string | undefined, string, string>;
    offsetPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    bpPerPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    displayedRegions: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
        refName: import("mobx-state-tree").ISimpleType<string>;
        start: import("mobx-state-tree").ISimpleType<number>;
        end: import("mobx-state-tree").ISimpleType<number>;
        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    } & {
        assemblyName: import("mobx-state-tree").ISimpleType<string>;
    }, {
        setRefName(newRefName: string): void;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    tracks: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>;
    hideHeader: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideHeaderOverview: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideNoTracksActive: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    trackSelectorType: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    trackLabels: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    showCenterLine: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    showCytobandsSetting: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    showGridlines: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
}, {
    width: number;
} & {
    menuItems(): MenuItem[];
} & {
    setDisplayName(name: string): void;
    setWidth(newWidth: number): void;
    setMinimized(flag: boolean): void;
} & {
    volatileWidth: number | undefined;
    minimumBlockWidth: number;
    draggingTrackId: string | undefined;
    volatileError: Error | undefined;
    afterDisplayedRegionsSetCallbacks: Function[];
    scaleFactor: number;
    trackRefs: {
        [key: string]: any;
    };
    coarseDynamicBlocks: BaseBlock[];
    coarseTotalBp: number;
    leftOffset: BpOffset | undefined;
    rightOffset: BpOffset | undefined;
    searchResults: BaseResult[] | undefined;
    searchQuery: string | undefined;
    seqDialogDisplayed: boolean;
} & {
    /**
     * #getter
     */
    readonly width: number;
    /**
     * #getter
     */
    readonly interRegionPaddingWidth: number;
    /**
     * #getter
     */
    readonly assemblyNames: string[];
} & {
    /**
     * #method
     */
    MiniControlsComponent(): React.FC<any>;
    /**
     * #method
     */
    HeaderComponent(): React.FC<any>;
    /**
     * #getter
     */
    readonly assemblyErrors: string;
    /**
     * #getter
     */
    readonly assembliesInitialized: boolean;
    /**
     * #getter
     */
    readonly initialized: boolean;
    /**
     * #getter
     */
    readonly hasDisplayedRegions: boolean;
    /**
     * #getter
     */
    readonly isSearchDialogDisplayed: boolean;
    /**
     * #getter
     */
    readonly scaleBarHeight: number;
    /**
     * #getter
     */
    readonly headerHeight: number;
    /**
     * #getter
     */
    readonly trackHeights: any;
    /**
     * #getter
     */
    readonly trackHeightsWithResizeHandles: any;
    /**
     * #getter
     */
    readonly height: any;
    /**
     * #getter
     */
    readonly totalBp: number;
    /**
     * #getter
     */
    readonly maxBpPerPx: number;
    /**
     * #getter
     */
    readonly minBpPerPx: number;
    /**
     * #getter
     */
    readonly error: string | Error;
    /**
     * #getter
     */
    readonly maxOffset: number;
    /**
     * #getter
     */
    readonly minOffset: number;
    /**
     * #getter
     */
    readonly displayedRegionsTotalPx: number;
    /**
     * #method
     */
    renderProps(): any;
    /**
     * #method
     */
    searchScope(assemblyName: string): {
        assemblyName: string;
        includeAggregateIndexes: boolean;
        tracks: import("mobx-state-tree").IMSTArray<import("mobx-state-tree").IAnyType> & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>>;
    };
    /**
     * #method
     */
    getTrack(id: string): any;
    /**
     * #method
     */
    rankSearchResults(results: BaseResult[]): BaseResult[];
    /**
     * #method
     * modifies view menu action onClick to apply to all tracks of same type
     */
    rewriteOnClicks(trackType: string, viewMenuActions: MenuItem[]): void;
    /**
     * #getter
     */
    readonly trackTypeActions: Map<string, MenuItem[]>;
} & {
    /**
     * #action
     */
    setShowCytobands(flag: boolean): void;
    /**
     * #action
     */
    setWidth(newWidth: number): void;
    /**
     * #action
     */
    setError(error: Error | undefined): void;
    /**
     * #action
     */
    toggleHeader(): void;
    /**
     * #action
     */
    toggleHeaderOverview(): void;
    /**
     * #action
     */
    toggleNoTracksActive(): void;
    /**
     * #action
     */
    toggleShowGridlines(): void;
    /**
     * #action
     */
    scrollTo(offsetPx: number): number;
    /**
     * #action
     */
    zoomTo(bpPerPx: number): number;
    /**
     * #action
     * sets offsets used in the get sequence dialog
     */
    setOffsets(left?: BpOffset, right?: BpOffset): void;
    /**
     * #action
     */
    setSearchResults(results?: BaseResult[], query?: string): void;
    /**
     * #action
     */
    setGetSequenceDialogOpen(open: boolean): void;
    /**
     * #action
     */
    setNewView(bpPerPx: number, offsetPx: number): void;
    /**
     * #action
     */
    horizontallyFlip(): void;
    /**
     * #action
     */
    showTrack(trackId: string, initialSnapshot?: {}, displayInitialSnapshot?: {}): any;
    /**
     * #action
     */
    hideTrack(trackId: string): number;
} & {
    /**
     * #action
     */
    moveTrack(movingId: string, targetId: string): void;
    /**
     * #action
     */
    closeView(): void;
    /**
     * #action
     */
    toggleTrack(trackId: string): void;
    /**
     * #action
     */
    setTrackLabels(setting: 'overlapping' | 'offset' | 'hidden'): void;
    /**
     * #action
     */
    toggleCenterLine(): void;
    /**
     * #action
     */
    setDisplayedRegions(regions: Region[]): void;
    /**
     * #action
     */
    activateTrackSelector(): import("@jbrowse/core/util").Widget;
    /**
     * #method
     * Helper method for the fetchSequence.
     * Retrieves the corresponding regions that were selected by the rubberband
     *
     * @param leftOffset - `object as {start, end, index, offset}`, offset = start of user drag
     * @param rightOffset - `object as {start, end, index, offset}`, offset = end of user drag
     * @returns array of Region[]
     */
    getSelectedRegions(leftOffset?: BpOffset, rightOffset?: BpOffset): {
        start: number;
        end: number;
        regionNumber?: number | undefined;
        reversed?: boolean | undefined;
        refName: string;
        assemblyName: string;
        key: string;
        offsetPx: number;
        widthPx: number;
        variant?: string | undefined;
        isLeftEndOfDisplayedRegion?: boolean | undefined;
    }[];
    /**
     * #action
     * schedule something to be run after the next time displayedRegions is set
     */
    afterDisplayedRegionsSet(cb: Function): void;
    /**
     * #action
     */
    horizontalScroll(distance: number): number;
    /**
     * #action
     */
    center(): void;
    /**
     * #action
     */
    showAllRegions(): void;
    /**
     * #action
     */
    showAllRegionsInAssembly(assemblyName?: string): void;
    /**
     * #action
     */
    setDraggingTrackId(idx?: string): void;
    /**
     * #action
     */
    setScaleFactor(factor: number): void;
    /**
     * #action
     * this "clears the view" and makes the view return to the import form
     */
    clearView(): void;
    /**
     * #action
     * creates an svg export and save using FileSaver
     */
    exportSvg(opts?: ExportSvgOptions): Promise<void>;
} & {
    slide: (viewWidths: number) => void;
} & {
    zoom: (targetBpPerPx: number) => void;
} & {
    /**
     * #getter
     */
    readonly canShowCytobands: boolean;
    /**
     * #getter
     */
    readonly showCytobands: boolean;
    /**
     * #getter
     */
    readonly anyCytobandsExist: boolean;
    /**
     * #getter
     * the cytoband is displayed to the right of the chromosome name,
     * and that offset is calculated manually with this method
     */
    readonly cytobandOffset: number;
} & {
    /**
     * #method
     * return the view menu items
     */
    menuItems(): MenuItem[];
} & {
    /**
     * #getter
     * static blocks are an important concept jbrowse uses to avoid
     * re-rendering when you scroll to the side. when you horizontally
     * scroll to the right, old blocks to the left may be removed, and
     * new blocks may be instantiated on the right. tracks may use the
     * static blocks to render their data for the region represented by
     * the block
     */
    readonly staticBlocks: BlockSet;
    /**
     * #getter
     * dynamic blocks represent the exact coordinates of the currently
     * visible genome regions on the screen. they are similar to static
     * blocks, but statcic blocks can go offscreen while dynamic blocks
     * represent exactly what is on screen
     */
    readonly dynamicBlocks: BlockSet;
    /**
     * #getter
     * rounded dynamic blocks are dynamic blocks without fractions of bp
     */
    readonly roundedDynamicBlocks: BaseBlock[];
    /**
     * #getter
     * a single "combo-locstring" representing all the regions visible
     * on the screen
     */
    readonly visibleLocStrings: string;
    /**
     * #getter
     * same as visibleLocStrings, but only updated every 300ms
     */
    readonly coarseVisibleLocStrings: string;
} & {
    /**
     * #action
     */
    setCoarseDynamicBlocks(blocks: BlockSet): void;
    afterAttach(): void;
} & {
    /**
     * #action
     * offset is the base-pair-offset in the displayed region, index is the index of the
     * displayed region in the linear genome view
     *
     * @param start - object as `{start, end, offset, index}`
     * @param end - object as `{start, end, offset, index}`
     */
    moveTo(start?: BpOffset, end?: BpOffset): void;
    /**
     * #action
     * navigate to the given locstring
     *
     * @param locString - e.g. "chr1:1-100"
     * @param optAssemblyName - (optional) the assembly name to use when navigating to the locstring
     */
    navToLocString(locString: string, optAssemblyName?: string): Promise<void>;
    /**
     * #action
     * Navigate to a location based on its refName and optionally start, end,
     * and assemblyName. Can handle if there are multiple displayedRegions
     * from same refName. Only navigates to a location if it is entirely
     * within a displayedRegion. Navigates to the first matching location
     * encountered.
     *
     * Throws an error if navigation was unsuccessful
     *
     * @param query - a proposed location to navigate to
     */
    navTo(query: NavLocation): void;
    /**
     * #action
     */
    navToMultiple(locations: NavLocation[]): void;
} & {
    /**
     * #method
     */
    rubberBandMenuItems(): MenuItem[];
    /**
     * #method
     */
    bpToPx({ refName, coord, regionNumber, }: {
        refName: string;
        coord: number;
        regionNumber?: number | undefined;
    }): {
        index: number;
        offsetPx: number;
    } | undefined;
    /**
     * #method
     * scrolls the view to center on the given bp. if that is not in any
     * of the displayed regions, does nothing
     * @param coord - basepair at which you want to center the view
     * @param refName - refName of the displayedRegion you are centering at
     * @param regionNumber - index of the displayedRegion
     */
    centerAt(coord: number, refName: string, regionNumber: number): void;
    /**
     * #method
     */
    pxToBp(px: number): {
        coord: number;
        index: number;
        refName: string;
        oob: boolean;
        assemblyName: string;
        offset: number;
        start: number;
        end: number;
        reversed: boolean;
    };
    /**
     * #getter
     */
    readonly centerLineInfo: {
        coord: number;
        index: number;
        refName: string;
        oob: boolean;
        assemblyName: string;
        offset: number;
        start: number;
        end: number;
        reversed: boolean;
    } | undefined;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export { renderToSvg, RefNameAutocomplete, SearchBox, ZoomControls, LinearGenomeView, };
export type LinearGenomeViewStateModel = ReturnType<typeof stateModelFactory>;
export type LinearGenomeViewModel = Instance<LinearGenomeViewStateModel>;
export { default as ReactComponent } from './components/LinearGenomeView';
