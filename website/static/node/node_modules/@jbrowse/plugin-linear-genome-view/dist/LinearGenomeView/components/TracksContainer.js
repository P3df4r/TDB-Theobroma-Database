"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const mui_1 = require("tss-react/mui");
const mobx_react_1 = require("mobx-react");
const normalize_wheel_1 = __importDefault(require("normalize-wheel"));
// locals
const __1 = require("..");
const RubberBand_1 = __importDefault(require("./RubberBand"));
const ScaleBar_1 = __importDefault(require("./ScaleBar"));
const Gridlines_1 = __importDefault(require("./Gridlines"));
const CenterLine_1 = __importDefault(require("./CenterLine"));
const useStyles = (0, mui_1.makeStyles)()({
    tracksContainer: {
        position: 'relative',
        overflow: 'hidden',
    },
    spacer: {
        position: 'relative',
        height: 3,
    },
});
function TracksContainer({ children, model, }) {
    const { classes } = useStyles();
    // refs are to store these variables to avoid repeated rerenders associated
    // with useState/setState
    const delta = (0, react_1.useRef)(0);
    const scheduled = (0, react_1.useRef)(false);
    const timeout = (0, react_1.useRef)();
    const ref = (0, react_1.useRef)(null);
    const prevX = (0, react_1.useRef)(0);
    const [mouseDragging, setMouseDragging] = (0, react_1.useState)(false);
    (0, react_1.useEffect)(() => {
        let cleanup = () => { };
        function globalMouseMove(event) {
            event.preventDefault();
            const currX = event.clientX;
            const distance = currX - prevX.current;
            if (distance) {
                // use rAF to make it so multiple event handlers aren't fired per-frame
                // see https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/
                if (!scheduled.current) {
                    scheduled.current = true;
                    window.requestAnimationFrame(() => {
                        model.horizontalScroll(-distance);
                        scheduled.current = false;
                        prevX.current = event.clientX;
                    });
                }
            }
        }
        function globalMouseUp() {
            prevX.current = 0;
            if (mouseDragging) {
                setMouseDragging(false);
            }
        }
        if (mouseDragging) {
            window.addEventListener('mousemove', globalMouseMove, true);
            window.addEventListener('mouseup', globalMouseUp, true);
            cleanup = () => {
                window.removeEventListener('mousemove', globalMouseMove, true);
                window.removeEventListener('mouseup', globalMouseUp, true);
            };
        }
        return cleanup;
    }, [model, mouseDragging, prevX]);
    function mouseDown(event) {
        // check if clicking a draggable element or a resize handle
        const target = event.target;
        if (target.draggable || target.dataset.resizer) {
            return;
        }
        // otherwise do click and drag scroll
        if (event.button === 0) {
            prevX.current = event.clientX;
            setMouseDragging(true);
        }
    }
    // this local mouseup is used in addition to the global because sometimes
    // the global add/remove are not called in time, resulting in issue #533
    function mouseUp(event) {
        event.preventDefault();
        setMouseDragging(false);
    }
    function mouseLeave(event) {
        event.preventDefault();
    }
    (0, react_1.useEffect)(() => {
        const curr = ref.current;
        // if ctrl is held down, zoom in with y-scroll
        // else scroll horizontally with x-scroll
        function onWheel(origEvent) {
            const event = (0, normalize_wheel_1.default)(origEvent);
            if (origEvent.ctrlKey === true) {
                origEvent.preventDefault();
                delta.current += event.pixelY / 500;
                model.setScaleFactor(delta.current < 0 ? 1 - delta.current : 1 / (1 + delta.current));
                if (timeout.current) {
                    clearTimeout(timeout.current);
                }
                timeout.current = setTimeout(() => {
                    model.setScaleFactor(1);
                    model.zoomTo(delta.current > 0
                        ? model.bpPerPx * (1 + delta.current)
                        : model.bpPerPx / (1 - delta.current));
                    delta.current = 0;
                }, 300);
            }
            else {
                // this is needed to stop the event from triggering "back button
                // action" on MacOSX etc.  but is a heuristic to avoid preventing the
                // inner-track scroll behavior
                if (Math.abs(event.pixelX) > Math.abs(2 * event.pixelY)) {
                    origEvent.preventDefault();
                }
                delta.current += event.pixelX;
                if (!scheduled.current) {
                    // use rAF to make it so multiple event handlers aren't fired per-frame
                    // see https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/
                    scheduled.current = true;
                    window.requestAnimationFrame(() => {
                        model.horizontalScroll(delta.current);
                        delta.current = 0;
                        scheduled.current = false;
                    });
                }
            }
        }
        if (curr) {
            curr.addEventListener('wheel', onWheel);
            return () => {
                curr.removeEventListener('wheel', onWheel);
            };
        }
        return () => { };
    }, [model]);
    return (react_1.default.createElement("div", { ref: ref, "data-testid": "trackContainer", className: classes.tracksContainer, onMouseDown: mouseDown, onMouseUp: mouseUp, onMouseLeave: mouseLeave },
        model.showGridlines ? react_1.default.createElement(Gridlines_1.default, { model: model }) : null,
        model.showCenterLine ? react_1.default.createElement(CenterLine_1.default, { model: model }) : null,
        react_1.default.createElement(RubberBand_1.default, { model: model, ControlComponent: react_1.default.createElement(ScaleBar_1.default, { model: model, style: { height: __1.SCALE_BAR_HEIGHT, boxSizing: 'border-box' } }) }),
        children));
}
exports.default = (0, mobx_react_1.observer)(TracksContainer);
//# sourceMappingURL=TracksContainer.js.map