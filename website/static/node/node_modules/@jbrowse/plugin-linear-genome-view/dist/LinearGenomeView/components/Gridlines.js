"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const blockTypes_1 = require("@jbrowse/core/util/blockTypes");
const mui_1 = require("tss-react/mui");
const mobx_react_1 = require("mobx-react");
const Block_1 = require("../../BaseLinearDisplay/components/Block");
const util_1 = require("../util");
const useStyles = (0, mui_1.makeStyles)()(theme => ({
    verticalGuidesZoomContainer: {
        position: 'absolute',
        height: '100%',
        width: '100%',
        zIndex: 1,
        pointerEvents: 'none',
    },
    verticalGuidesContainer: {
        position: 'absolute',
        height: '100%',
        zIndex: 1,
        pointerEvents: 'none',
        display: 'flex',
    },
    tick: {
        position: 'absolute',
        height: '100%',
        width: 1,
    },
    majorTick: {
        background: theme.palette.text.secondary,
    },
    minorTick: {
        background: theme.palette.divider,
    },
}));
const RenderedVerticalGuides = (0, mobx_react_1.observer)(({ model }) => {
    const { classes, cx } = useStyles();
    return (react_1.default.createElement(react_1.default.Fragment, null, model.staticBlocks.map((block, index) => {
        if (block instanceof blockTypes_1.ContentBlock) {
            const ticks = (0, util_1.makeTicks)(block.start, block.end, model.bpPerPx);
            return (react_1.default.createElement(Block_1.ContentBlock, { key: `${block.key}-${index}`, block: block }, ticks.map(tick => {
                const x = (block.reversed
                    ? block.end - tick.base
                    : tick.base - block.start) / model.bpPerPx;
                return (react_1.default.createElement("div", { key: tick.base, className: cx(classes.tick, tick.type === 'major' || tick.type === 'labeledMajor'
                        ? classes.majorTick
                        : classes.minorTick), style: { left: x } }));
            })));
        }
        if (block instanceof blockTypes_1.ElidedBlock) {
            return react_1.default.createElement(Block_1.ElidedBlock, { key: block.key, width: block.widthPx });
        }
        if (block instanceof blockTypes_1.InterRegionPaddingBlock) {
            return (react_1.default.createElement(Block_1.InterRegionPaddingBlock, { key: block.key, width: block.widthPx, boundary: block.variant === 'boundary' }));
        }
        return null;
    })));
});
function VerticalGuides({ model }) {
    const { classes } = useStyles();
    // find the block that needs pinning to the left side for context
    const offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
    return (react_1.default.createElement("div", { className: classes.verticalGuidesZoomContainer, style: {
            transform: model.scaleFactor !== 1 ? `scaleX(${model.scaleFactor})` : undefined,
        } },
        react_1.default.createElement("div", { className: classes.verticalGuidesContainer, style: {
                left: offsetLeft,
                width: model.staticBlocks.totalWidthPx,
            } },
            react_1.default.createElement(RenderedVerticalGuides, { model: model }))));
}
exports.default = (0, mobx_react_1.observer)(VerticalGuides);
//# sourceMappingURL=Gridlines.js.map