"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const material_1 = require("@mui/material");
const mui_1 = require("tss-react/mui");
const blockTypes_1 = require("@jbrowse/core/util/blockTypes");
const mobx_react_1 = require("mobx-react");
const react_1 = __importDefault(require("react"));
const Block_1 = require("../../BaseLinearDisplay/components/Block");
const util_1 = require("../util");
const util_2 = require("@jbrowse/core/util");
const useStyles = (0, mui_1.makeStyles)()(theme => ({
    scaleBarContainer: {
        overflow: 'hidden',
        position: 'relative',
    },
    scaleBarZoomContainer: {
        position: 'relative',
        zIndex: 1,
    },
    scaleBar: {
        position: 'absolute',
        display: 'flex',
        pointerEvents: 'none',
    },
    majorTickLabel: {
        fontSize: '11px',
        zIndex: 1,
        background: theme.palette.background.paper,
        lineHeight: 'normal',
        pointerEvents: 'none',
    },
    tick: {
        position: 'absolute',
        width: 0,
        display: 'flex',
        justifyContent: 'center',
        pointerEvents: 'none',
    },
    refLabel: {
        fontSize: '11px',
        position: 'absolute',
        left: '2px',
        top: '-1px',
        fontWeight: 'bold',
        lineHeight: 'normal',
        zIndex: 1,
        pointerEvents: 'none',
        background: theme.palette.background.paper,
    },
}));
const RenderedRefNameLabels = (0, mobx_react_1.observer)(({ model }) => {
    const { classes } = useStyles();
    // find the block that needs pinning to the left side for context
    let lastLeftBlock = 0;
    model.staticBlocks.forEach((block, i) => {
        if (block.offsetPx - model.offsetPx < 0) {
            lastLeftBlock = i;
        }
    });
    return (react_1.default.createElement(react_1.default.Fragment, null, model.staticBlocks.map((block, index) => {
        return block instanceof blockTypes_1.ContentBlock &&
            (block.isLeftEndOfDisplayedRegion || index === lastLeftBlock) ? (react_1.default.createElement(material_1.Typography, { key: `refLabel-${block.key}-${index}`, style: {
                left: index === lastLeftBlock
                    ? Math.max(0, -model.offsetPx)
                    : block.offsetPx - model.offsetPx - 1,
                paddingLeft: index === lastLeftBlock ? 0 : 1,
            }, className: classes.refLabel, "data-testid": `refLabel-${block.refName}` }, block.refName)) : null;
    })));
});
const RenderedScaleBarLabels = (0, mobx_react_1.observer)(({ model }) => {
    const { classes } = useStyles();
    const { bpPerPx, staticBlocks } = model;
    return (react_1.default.createElement(react_1.default.Fragment, null, staticBlocks.map((block, index) => {
        const { reversed, start, end, key, widthPx } = block;
        if (block instanceof blockTypes_1.ContentBlock) {
            const ticks = (0, util_1.makeTicks)(start, end, bpPerPx, true, false);
            return (react_1.default.createElement(Block_1.ContentBlock, { key: `${key}-${index}`, block: block }, ticks.map(tick => {
                if (tick.type === 'major') {
                    const x = (reversed ? end - tick.base : tick.base - start) / bpPerPx;
                    const baseNumber = tick.base + 1;
                    return (react_1.default.createElement("div", { key: tick.base, className: classes.tick, style: { left: x } }, baseNumber ? (react_1.default.createElement(material_1.Typography, { className: classes.majorTickLabel }, (0, util_2.getTickDisplayStr)(baseNumber, bpPerPx))) : null));
                }
                return null;
            })));
        }
        if (block instanceof blockTypes_1.ElidedBlock) {
            return react_1.default.createElement(Block_1.ElidedBlock, { key: key, width: widthPx });
        }
        if (block instanceof blockTypes_1.InterRegionPaddingBlock) {
            return (react_1.default.createElement(Block_1.InterRegionPaddingBlock, { key: key, width: widthPx, style: { background: 'none' }, boundary: block.variant === 'boundary' }));
        }
        return null;
    })));
});
const ScaleBar = react_1.default.forwardRef(({ model, style, className, ...other }, ref) => {
    const { classes, cx } = useStyles();
    const offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
    return (react_1.default.createElement(material_1.Paper, { "data-resizer": "true" // used to avoid click-and-drag scrolls on trackscontainer
        , className: cx(classes.scaleBarContainer, className), variant: "outlined", ref: ref, style: style, ...other },
        react_1.default.createElement("div", { className: classes.scaleBarZoomContainer, style: {
                transform: model.scaleFactor !== 1
                    ? `scaleX(${model.scaleFactor})`
                    : undefined,
            } },
            react_1.default.createElement("div", { className: classes.scaleBar, style: {
                    left: offsetLeft - 1,
                    width: model.staticBlocks.totalWidthPx,
                    ...style,
                } },
                react_1.default.createElement(RenderedScaleBarLabels, { model: model }))),
        react_1.default.createElement(RenderedRefNameLabels, { model: model })));
});
exports.default = (0, mobx_react_1.observer)(ScaleBar);
//# sourceMappingURL=ScaleBar.js.map