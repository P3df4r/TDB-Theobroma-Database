"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const mobx_react_1 = require("mobx-react");
const util_1 = require("@jbrowse/core/util");
const BaseResults_1 = __importStar(require("@jbrowse/core/TextSearch/BaseResults"));
const material_1 = require("@mui/material");
// icons
const Search_1 = __importDefault(require("@mui/icons-material/Search"));
const Help_1 = __importDefault(require("@mui/icons-material/Help"));
// lazy
const HelpDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require('./HelpDialog'))));
// the logic of this method is to only apply a filter to RefSequenceResults
// because they do not have a matchedObject. the trix search results already
// filter so don't need re-filtering
function filterOptions(options, searchQuery) {
    return options.filter(option => {
        const { result } = option;
        return (result.getLabel().toLowerCase().includes(searchQuery) ||
            result.matchedObject);
    });
}
function RefNameAutocomplete({ model, onSelect, assemblyName, style, fetchResults, onChange, value, showHelp = true, minWidth = 200, TextFieldProps = {}, }) {
    const session = (0, util_1.getSession)(model);
    const { assemblyManager } = session;
    const [open, setOpen] = (0, react_1.useState)(false);
    const [loaded, setLoaded] = (0, react_1.useState)(true);
    const [isHelpDialogDisplayed, setHelpDialogDisplayed] = (0, react_1.useState)(false);
    const [currentSearch, setCurrentSearch] = (0, react_1.useState)('');
    const [inputValue, setInputValue] = (0, react_1.useState)('');
    const [searchOptions, setSearchOptions] = (0, react_1.useState)();
    const debouncedSearch = (0, util_1.useDebounce)(currentSearch, 300);
    const assembly = assemblyName ? assemblyManager.get(assemblyName) : undefined;
    const { coarseVisibleLocStrings, hasDisplayedRegions } = model;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const regions = (assembly === null || assembly === void 0 ? void 0 : assembly.regions) || [];
    const options = (0, react_1.useMemo)(() => regions.map(option => ({
        result: new BaseResults_1.RefSequenceResult({
            refName: option.refName,
            label: option.refName,
            matchedAttribute: 'refName',
        }),
    })), [regions]);
    (0, react_1.useEffect)(() => {
        let active = true;
        (async () => {
            try {
                if (debouncedSearch === '' || !assemblyName) {
                    return;
                }
                setLoaded(false);
                const results = await fetchResults(debouncedSearch);
                if (active) {
                    const m = {};
                    for (let i = 0; i < results.length; i++) {
                        const r = results[i];
                        const d = r.getDisplayString();
                        if (!m[d]) {
                            m[d] = [];
                        }
                        m[d].push(r);
                    }
                    const display = Object.entries(m).map(([displayString, results]) => {
                        if (results.length === 1) {
                            return { result: results[0] };
                        }
                        else {
                            return {
                                result: new BaseResults_1.default({
                                    displayString,
                                    results,
                                    label: displayString,
                                }),
                            };
                        }
                    });
                    setSearchOptions(display);
                    setLoaded(true);
                }
            }
            catch (e) {
                console.error(e);
                if (active) {
                    session.notify(`${e}`, 'error');
                }
            }
        })();
        return () => {
            active = false;
        };
    }, [assemblyName, fetchResults, debouncedSearch, session, model]);
    const inputBoxVal = coarseVisibleLocStrings || value || '';
    // heuristic, text width + icon width
    // + 45 accomodates help icon and search icon
    const width = Math.min(Math.max((0, util_1.measureText)(inputBoxVal, 16) + 45, minWidth), 550);
    // notes on implementation:
    // The selectOnFocus setting helps highlight the field when clicked
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(material_1.Autocomplete, { id: `refNameAutocomplete-${model.id}`, "data-testid": "autocomplete", disableListWrap: true, disableClearable: true, disabled: !assemblyName, freeSolo: true, includeInputInList: true, selectOnFocus: true, style: { ...style, width }, value: inputBoxVal, loading: !loaded, inputValue: inputValue, onInputChange: (_event, newInputValue) => {
                setInputValue(newInputValue);
                onChange === null || onChange === void 0 ? void 0 : onChange(newInputValue);
            }, loadingText: "loading results", open: open, onOpen: () => setOpen(true), onClose: () => {
                setOpen(false);
                setLoaded(true);
                if (hasDisplayedRegions) {
                    setCurrentSearch('');
                    setSearchOptions(undefined);
                }
            }, onChange: (_event, selectedOption) => {
                if (!selectedOption || !assemblyName) {
                    return;
                }
                if (typeof selectedOption === 'string') {
                    // handles string inputs on keyPress enter
                    onSelect === null || onSelect === void 0 ? void 0 : onSelect(new BaseResults_1.default({ label: selectedOption }));
                }
                else {
                    onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedOption.result);
                }
                setInputValue(inputBoxVal);
            }, options: !(searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.length) ? options : searchOptions, getOptionDisabled: option => (option === null || option === void 0 ? void 0 : option.group) === 'limitOption', filterOptions: (options, params) => {
                const filtered = filterOptions(options, params.inputValue.toLocaleLowerCase());
                return [
                    ...filtered.slice(0, 100),
                    ...(filtered.length > 100
                        ? [
                            {
                                group: 'limitOption',
                                result: new BaseResults_1.default({
                                    label: 'keep typing for more results',
                                }),
                            },
                        ]
                        : []),
                ];
            }, renderInput: params => {
                const { helperText, InputProps = {} } = TextFieldProps;
                return (react_1.default.createElement(material_1.TextField, { onBlur: () => 
                    // this is used to restore a refName or the non-user-typed input
                    // to the box on blurring
                    setInputValue(inputBoxVal), ...params, ...TextFieldProps, helperText: helperText, InputProps: {
                        ...params.InputProps,
                        ...InputProps,
                        endAdornment: (react_1.default.createElement(react_1.default.Fragment, null,
                            regions.length === 0 ? (react_1.default.createElement(material_1.CircularProgress, { color: "inherit", size: 20 })) : (react_1.default.createElement(material_1.InputAdornment, { position: "end", style: { marginRight: 7 } },
                                react_1.default.createElement(Search_1.default, { fontSize: "small" }),
                                showHelp ? (react_1.default.createElement(material_1.IconButton, { onClick: () => setHelpDialogDisplayed(true), size: "small" },
                                    react_1.default.createElement(Help_1.default, { fontSize: "small" }))) : null)),
                            params.InputProps.endAdornment)),
                    }, placeholder: "Search for location", onChange: e => setCurrentSearch(e.target.value) }));
            }, getOptionLabel: option => (typeof option === 'string'
                ? option
                : option.result.getDisplayString()) || '' }),
        isHelpDialogDisplayed ? (react_1.default.createElement(react_1.Suspense, { fallback: react_1.default.createElement("div", null) },
            react_1.default.createElement(HelpDialog, { handleClose: () => setHelpDialogDisplayed(false) }))) : null));
}
exports.default = (0, mobx_react_1.observer)(RefNameAutocomplete);
//# sourceMappingURL=RefNameAutocomplete.js.map