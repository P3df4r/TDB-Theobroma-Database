"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const mobx_react_1 = require("mobx-react");
const material_1 = require("@mui/material");
const mui_1 = require("tss-react/mui");
const util_1 = require("@jbrowse/core/util");
// locals
const RefNameAutocomplete_1 = __importDefault(require("./RefNameAutocomplete"));
const util_2 = require("./util");
const __1 = require("..");
const useStyles = (0, mui_1.makeStyles)()(() => ({
    headerRefName: {
        minWidth: 100,
    },
}));
function SearchBox({ model, showHelp, }) {
    const { classes } = useStyles();
    const theme = (0, material_1.useTheme)();
    const session = (0, util_1.getSession)(model);
    const { textSearchManager, assemblyManager } = session;
    const { assemblyNames, rankSearchResults } = model;
    const assemblyName = assemblyNames[0];
    const assembly = assemblyManager.get(assemblyName);
    const searchScope = model.searchScope(assemblyName);
    function navToOption(option) {
        const location = option.getLocation();
        const trackId = option.getTrackId();
        if (location) {
            model.navToLocString(location, assemblyName);
            if (trackId) {
                model.showTrack(trackId);
            }
        }
    }
    // gets a string as input, or use stored option results from previous query,
    // then re-query and
    // 1) if it has multiple results: pop a dialog
    // 2) if it's a single result navigate to it
    // 3) else assume it's a locstring and navigate to it
    async function handleSelectedRegion(option) {
        try {
            if (option.hasLocation()) {
                navToOption(option);
            }
            else {
                const input = option.getLabel();
                const [ref, rest] = (0, util_2.splitLast)(input, ':');
                const allRefs = (assembly === null || assembly === void 0 ? void 0 : assembly.allRefNamesWithLowerCase) || [];
                if (allRefs.includes(input) ||
                    (allRefs.includes(ref) && !Number.isNaN(parseInt(rest, 10)))) {
                    model.navToLocString(input, assemblyName);
                }
                else {
                    const results = await (0, util_2.fetchResults)({
                        queryString: input,
                        searchType: 'exact',
                        searchScope,
                        rankSearchResults,
                        textSearchManager,
                        assembly,
                    });
                    if (results.length > 1) {
                        model.setSearchResults(results, input.toLowerCase());
                    }
                    else if (results.length === 1) {
                        navToOption(results[0]);
                    }
                    else {
                        model.navToLocString(input, assemblyName);
                    }
                }
            }
        }
        catch (e) {
            console.error(e);
            session.notify(`${e}`, 'warning');
        }
    }
    return (react_1.default.createElement(RefNameAutocomplete_1.default, { showHelp: showHelp, onSelect: handleSelectedRegion, assemblyName: assemblyName, fetchResults: queryString => (0, util_2.fetchResults)({
            queryString,
            searchScope,
            rankSearchResults,
            textSearchManager,
            assembly,
        }), model: model, TextFieldProps: {
            variant: 'outlined',
            className: classes.headerRefName,
            style: { margin: __1.SPACING, minWidth: '175px' },
            InputProps: {
                style: {
                    padding: 0,
                    height: __1.WIDGET_HEIGHT,
                    background: (0, material_1.alpha)(theme.palette.background.paper, 0.8),
                },
            },
        } }));
}
exports.default = (0, mobx_react_1.observer)(SearchBox);
//# sourceMappingURL=SearchBox.js.map