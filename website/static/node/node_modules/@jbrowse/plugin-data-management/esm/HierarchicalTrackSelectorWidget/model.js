import { types, getSnapshot } from 'mobx-state-tree';
import { getConf, readConfObject, } from '@jbrowse/core/configuration';
import { getSession, getEnv } from '@jbrowse/core/util';
import { getTrackName } from '@jbrowse/core/util/tracks';
import { ElementId } from '@jbrowse/core/util/types/mst';
function hasAnyOverlap(a1 = [], a2 = []) {
    return !!a1.find(value => a2.includes(value));
}
function passesFilter(filter, config, session) {
    const categories = readConfObject(config, 'category');
    const filterLower = filter.toLowerCase();
    return (getTrackName(config, session).toLowerCase().includes(filterLower) ||
        !!(categories === null || categories === void 0 ? void 0 : categories.filter(c => c.toLowerCase().includes(filterLower)).length));
}
function filterTracks(tracks, self, assemblyName) {
    const { assemblyManager } = getSession(self);
    const { pluginManager } = getEnv(self);
    const assembly = assemblyManager.get(assemblyName);
    if (!assembly) {
        return [];
    }
    const { allAliases } = assembly;
    return tracks
        .filter(c => hasAnyOverlap(allAliases, readConfObject(c, 'assemblyNames')))
        .filter(c => {
        const { displayTypes } = pluginManager.getViewType(self.view.type);
        const compatDisplays = displayTypes.map((d) => d.name);
        const trackDisplays = c.displays.map((d) => d.type);
        return hasAnyOverlap(compatDisplays, trackDisplays);
    });
}
export function generateHierarchy(model, trackConfigurations, collapsed) {
    const hierarchy = { children: [] };
    const { filterText, view } = model;
    const session = getSession(model);
    trackConfigurations
        .filter(conf => passesFilter(filterText, conf, session))
        .forEach(conf => {
        // copy the categories since this array can be mutated downstream
        const categories = [...(readConfObject(conf, 'category') || [])];
        // silly thing where if trackId ends with sessionTrack, then push it to
        // a category that starts with a space to force sort to the top...
        // double whammy hackyness
        if (conf.trackId.endsWith('sessionTrack')) {
            categories.unshift(' Session tracks');
        }
        let currLevel = hierarchy;
        // find existing category to put track into or create it
        for (let i = 0; i < categories.length; i++) {
            const category = categories[i];
            const ret = currLevel.children.find(c => c.name === category);
            const id = categories.slice(0, i + 1).join(',');
            if (!ret) {
                const n = {
                    children: [],
                    name: category,
                    id,
                    isOpenByDefault: !collapsed.get(id),
                };
                currLevel.children.push(n);
                currLevel = n;
            }
            else {
                currLevel = ret;
            }
        }
        const tracks = view.tracks;
        // using splice here tries to group leaf nodes above hierarchical nodes
        currLevel.children.splice(currLevel.children.findIndex(elt => elt.children.length), 0, {
            id: conf.trackId,
            name: getTrackName(conf, session),
            conf,
            checked: !!tracks.find(f => f.configuration === conf),
            children: [],
        });
    });
    return hierarchy.children;
}
export default function stateTreeFactory(pluginManager) {
    return types
        .model('HierarchicalTrackSelectorWidget', {
        id: ElementId,
        type: types.literal('HierarchicalTrackSelectorWidget'),
        collapsed: types.map(types.boolean),
        filterText: '',
        view: types.safeReference(pluginManager.pluggableMstType('view', 'stateModel')),
    })
        .volatile(() => ({
        selection: [],
    }))
        .actions(self => ({
        addToSelection(elt) {
            self.selection = [...self.selection, ...elt];
        },
        removeFromSelection(elt) {
            self.selection = self.selection.filter(f => !elt.includes(f));
        },
        clearSelection() {
            self.selection = [];
        },
        setView(view) {
            self.view = view;
        },
        toggleCategory(pathName) {
            self.collapsed.set(pathName, !self.collapsed.get(pathName));
        },
        clearFilterText() {
            self.filterText = '';
        },
        setFilterText(newText) {
            self.filterText = newText;
        },
    }))
        .views(self => ({
        getRefSeqTrackConf(assemblyName) {
            const { assemblyManager } = getSession(self);
            const assembly = assemblyManager.get(assemblyName);
            const trackConf = assembly === null || assembly === void 0 ? void 0 : assembly.configuration.sequence;
            const viewType = pluginManager.getViewType(self.view.type);
            if (!trackConf) {
                return undefined;
            }
            for (const display of trackConf.displays) {
                if (viewType.displayTypes.find(d => d.name === display.type)) {
                    return trackConf;
                }
            }
        },
    }))
        .views(self => ({
        trackConfigurations(assemblyName) {
            if (!self.view) {
                return [];
            }
            const { tracks, assemblyManager } = getSession(self);
            const assembly = assemblyManager.get(assemblyName);
            if (!assembly) {
                return [];
            }
            const refseq = self.getRefSeqTrackConf(assemblyName);
            // filter out tracks that don't match the current assembly (check all
            // assembly aliases) and display types
            return (refseq ? [refseq] : []).concat([
                ...filterTracks(tracks, self, assemblyName),
            ]);
        },
        get assemblyNames() {
            var _a;
            return ((_a = self.view) === null || _a === void 0 ? void 0 : _a.assemblyNames) || [];
        },
        connectionTrackConfigurations(assemblyName, connection) {
            if (!self.view) {
                return [];
            }
            // filter out tracks that don't match the current display types
            return filterTracks(connection.tracks, self, assemblyName);
        },
    }))
        .views(self => ({
        hierarchy(assemblyName) {
            const hier = generateHierarchy(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            self, self.trackConfigurations(assemblyName), self.collapsed);
            const session = getSession(self);
            const { connectionInstances } = session;
            const { assemblyManager } = getSession(self);
            const assembly = assemblyManager.get(assemblyName);
            const conns = (assembly &&
                (connectionInstances === null || connectionInstances === void 0 ? void 0 : connectionInstances.filter(c => hasAnyOverlap(assembly.allAliases, getConf(c, 'assemblyNames'))).map(c => ({
                    // @ts-ignore
                    id: getSnapshot(c).configuration,
                    name: getConf(c, 'name'),
                    children: this.connectionHierarchy(assemblyName, c),
                    state: {
                        expanded: true,
                    },
                })))) ||
                [];
            return {
                name: 'Root',
                id: 'Root',
                children: [
                    { name: 'Tracks', id: 'Tracks', children: hier },
                    ...conns,
                ],
            };
        },
        connectionHierarchy(assemblyName, connection) {
            return generateHierarchy(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            self, self.connectionTrackConfigurations(assemblyName, connection), self.collapsed);
        },
    }));
}
//# sourceMappingURL=model.js.map