import React, { useEffect, useState } from 'react';
import { Card, CardContent, Checkbox, FormControl, FormControlLabel, IconButton, InputLabel, InputAdornment, ListSubheader, Link, List, ListItem, MenuItem, Paper, TextField, Typography, } from '@mui/material';
import { makeStyles } from 'tss-react/mui';
import { readConfObject } from '@jbrowse/core/configuration';
import { supportedIndexingAdapters, getSession, getEnv, isElectron, } from '@jbrowse/core/util';
import { observer } from 'mobx-react';
import { UNKNOWN } from '@jbrowse/core/util/tracks';
// icons
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material//Add';
const useStyles = makeStyles()(theme => ({
    spacing: {
        marginBottom: theme.spacing(3),
    },
    paper: {
        display: 'flex',
        flexDirection: 'column',
        padding: theme.spacing(1),
    },
    spacer: {
        height: theme.spacing(8),
    },
    card: {
        marginTop: theme.spacing(1),
    },
}));
function StatusMessage({ trackAdapter, trackType, }) {
    var _a;
    const { classes } = useStyles();
    return trackAdapter.type === 'SNPCoverageAdapter' ? (React.createElement(Typography, { className: classes.spacing },
        "Selected ",
        React.createElement("code", null, trackType),
        ". Using adapter",
        ' ',
        React.createElement("code", null, trackAdapter.type),
        " with subadapter",
        ' ',
        React.createElement("code", null, (_a = trackAdapter.subadapter) === null || _a === void 0 ? void 0 : _a.type),
        ". Please enter a track name and, if necessary, update the track type.")) : (React.createElement(Typography, { className: classes.spacing },
        "Using adapter ",
        React.createElement("code", null, trackAdapter.type),
        " and guessing track type",
        ' ',
        React.createElement("code", null, trackType),
        ". Please enter a track name and, if necessary, update the track type."));
}
/**
 * categorizeAdapters takes a list of adapters and sorts their menu item elements under an appropriate ListSubheader
 *  element. In this way, adapters that are from external plugins can have headers that differentiate them from the
 *  out-of-the-box plugins.
 * @param adaptersList - a list of adapters found in the PluginManager
 * @returns a series of JSX elements that are ListSubheaders followed by the adapters
 *   found under that subheader
 */
function categorizeAdapters(adaptersList) {
    let currentCategory = '';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const items = [];
    adaptersList.forEach(adapter => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ((_a = adapter.adapterMetadata) === null || _a === void 0 ? void 0 : _a.category) {
            if (currentCategory !== ((_b = adapter.adapterMetadata) === null || _b === void 0 ? void 0 : _b.category)) {
                currentCategory = (_c = adapter.adapterMetadata) === null || _c === void 0 ? void 0 : _c.category;
                items.push(React.createElement(ListSubheader, { key: (_d = adapter.adapterMetadata) === null || _d === void 0 ? void 0 : _d.category, value: (_e = adapter.adapterMetadata) === null || _e === void 0 ? void 0 : _e.category }, (_f = adapter.adapterMetadata) === null || _f === void 0 ? void 0 : _f.category));
            }
            items.push(React.createElement(MenuItem, { key: adapter.name, value: adapter.name }, ((_g = adapter.adapterMetadata) === null || _g === void 0 ? void 0 : _g.displayName)
                ? (_h = adapter.adapterMetadata) === null || _h === void 0 ? void 0 : _h.displayName
                : adapter.name));
        }
    });
    return items;
}
function getAdapterTypes(pluginManager) {
    return pluginManager.getElementTypesInGroup('adapter');
}
function getTrackTypes(pluginManager) {
    return pluginManager.getElementTypesInGroup('track');
}
const TextIndexingConfig = observer(({ model }) => {
    const { classes } = useStyles();
    const [value1, setValue1] = useState('');
    const [value2, setValue2] = useState('');
    const [attributes, setAttributes] = useState(['Name', 'ID']);
    const [exclude, setExclude] = useState(['CDS', 'exon']);
    const sections = [
        {
            label: 'Indexing attributes',
            values: attributes,
        },
        {
            label: 'Feature types to exclude',
            values: exclude,
        },
    ];
    useEffect(() => {
        model.setTextIndexingConf({ attributes, exclude });
    }, [model, attributes, exclude]);
    return (React.createElement(Paper, { className: classes.paper },
        React.createElement(InputLabel, null, "Indexing configuration"),
        sections.map((section, index) => (React.createElement(Card, { raised: true, key: section.label, className: classes.card },
            React.createElement(CardContent, null,
                React.createElement(InputLabel, null, section.label),
                React.createElement(List, { disablePadding: true },
                    section.values.map((val, idx) => (React.createElement(ListItem, { key: idx, disableGutters: true },
                        React.createElement(TextField, { value: val, InputProps: {
                                endAdornment: (React.createElement(InputAdornment, { position: "end" },
                                    React.createElement(IconButton, { color: "secondary", onClick: () => {
                                            const newAttr = section.values.filter((a, i) => {
                                                return i !== idx;
                                            });
                                            index === 0
                                                ? setAttributes(newAttr)
                                                : setExclude(newAttr);
                                        } },
                                        React.createElement(DeleteIcon, null)))),
                            } })))),
                    React.createElement(ListItem, { disableGutters: true },
                        React.createElement(TextField, { value: index === 0 ? value1 : value2, placeholder: "add new", onChange: event => {
                                index === 0
                                    ? setValue1(event.target.value)
                                    : setValue2(event.target.value);
                            }, InputProps: {
                                endAdornment: (React.createElement(InputAdornment, { position: "end" },
                                    React.createElement(IconButton, { onClick: () => {
                                            if (index === 0) {
                                                const newAttr = attributes;
                                                newAttr.push(value1);
                                                setAttributes(newAttr);
                                                setValue1('');
                                            }
                                            else {
                                                const newFeat = exclude;
                                                newFeat.push(value2);
                                                setExclude(newFeat);
                                                setValue2('');
                                            }
                                        }, disabled: index === 0 ? value1 === '' : value2 === '', color: "secondary", "data-testid": `stringArrayAdd-Feat` },
                                        React.createElement(AddIcon, null)))),
                            } })))))))));
});
const TrackAdapterSelector = observer(({ model }) => {
    const { classes } = useStyles();
    const { trackAdapter } = model;
    const { pluginManager } = getEnv(model);
    const adapters = getAdapterTypes(pluginManager);
    return (React.createElement(TextField, { className: classes.spacing, value: (trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type) !== 'UNKNOWN' ? trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type : '', label: "adapterType", helperText: "Select an adapter type", select: true, fullWidth: true, onChange: event => model.setAdapterHint(event.target.value), SelectProps: {
            // @ts-ignore
            SelectDisplayProps: { 'data-testid': 'adapterTypeSelect' },
        } },
        adapters
            // Excludes any adapter with the 'adapterMetadata.hiddenFromGUI' property, and anything with the 'adapterMetadata.category' property
            .filter(elt => {
            var _a, _b;
            return !((_a = elt.adapterMetadata) === null || _a === void 0 ? void 0 : _a.hiddenFromGUI) &&
                !((_b = elt.adapterMetadata) === null || _b === void 0 ? void 0 : _b.category);
        })
            .map(elt => {
            var _a, _b;
            return (React.createElement(MenuItem, { key: elt.name, value: elt.name }, ((_a = elt.adapterMetadata) === null || _a === void 0 ? void 0 : _a.displayName)
                ? (_b = elt.adapterMetadata) === null || _b === void 0 ? void 0 : _b.displayName
                : elt.name));
        }),
        // adapters with the 'adapterMetadata.category' property are categorized
        // by the value of the property here
        categorizeAdapters(adapters.filter(elt => { var _a; return !((_a = elt.adapterMetadata) === null || _a === void 0 ? void 0 : _a.hiddenFromGUI); }))));
});
function UnknownAdapterPrompt({ model }) {
    const { classes } = useStyles();
    return (React.createElement(React.Fragment, null,
        React.createElement(Typography, { className: classes.spacing },
            "JBrowse was not able to guess the adapter type for this data, but it may be in the list below. If not, you can",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/releases", target: "_blank", rel: "noopener noreferrer" }, "check for new releases"),
            ' ',
            "of JBrowse to see if they support this data type or",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/issues/new", target: "_blank", rel: "noopener noreferrer" }, "file an issue"),
            ' ',
            "and add a feature request for this data type."),
        React.createElement(TrackAdapterSelector, { model: model })));
}
const TrackTypeSelector = observer(({ model }) => {
    const { classes } = useStyles();
    const session = getSession(model);
    const { trackType } = model;
    const trackTypes = getTrackTypes(getEnv(session).pluginManager);
    return (React.createElement(TextField, { className: classes.spacing, value: trackType, label: "trackType", helperText: "Select a track type", select: true, fullWidth: true, onChange: event => {
            model.setTrackType(event.target.value);
        }, SelectProps: {
            // @ts-ignore
            SelectDisplayProps: { 'data-testid': 'trackTypeSelect' },
        } }, trackTypes.map(({ name }) => (React.createElement(MenuItem, { key: name, value: name }, name)))));
});
const TrackAssemblySelector = observer(({ model }) => {
    const session = getSession(model);
    const { assembly } = model;
    return (React.createElement(TextField, { value: assembly, label: "assemblyName", helperText: "Assembly to which the track will be added", select: true, fullWidth: true, onChange: event => model.setAssembly(event.target.value), SelectProps: {
            // @ts-ignore
            SelectDisplayProps: { 'data-testid': 'assemblyNameSelect' },
        } }, session.assemblies
        .map(conf => readConfObject(conf, 'name'))
        .map(name => (React.createElement(MenuItem, { key: name, value: name }, name)))));
});
function ConfirmTrack({ model }) {
    const { classes } = useStyles();
    const [check, setCheck] = useState(true);
    const { trackName, trackAdapter, trackType, warningMessage, adapterHint } = model;
    if (model.unsupported) {
        return (React.createElement(Typography, { className: classes.spacing },
            "This version of JBrowse cannot display data of this type. It is possible, however, that there is a newer version that can display them. You can",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/releases", target: "_blank", rel: "noopener noreferrer" }, "check for new releases"),
            ' ',
            "of JBrowse or",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/issues/new", target: "_blank", rel: "noopener noreferrer" }, "file an issue"),
            ' ',
            "and add a feature request for this data type."));
    }
    if ((trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type) === UNKNOWN) {
        return React.createElement(UnknownAdapterPrompt, { model: model });
    }
    if (adapterHint === '' && trackAdapter) {
        model.setAdapterHint(trackAdapter.type);
    }
    if (!(trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type)) {
        return React.createElement(Typography, null, "Could not recognize this data type.");
    }
    const supportedForIndexing = supportedIndexingAdapters(trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type);
    return (React.createElement("div", null,
        trackAdapter ? (React.createElement(StatusMessage, { trackAdapter: trackAdapter, trackType: trackType })) : null,
        warningMessage ? (React.createElement(Typography, { style: { color: 'orange' } }, warningMessage)) : null,
        React.createElement(TextField, { className: classes.spacing, label: "trackName", helperText: "A name for this track", fullWidth: true, value: trackName, onChange: event => model.setTrackName(event.target.value), inputProps: { 'data-testid': 'trackNameInput' } }),
        React.createElement(TrackAdapterSelector, { model: model }),
        React.createElement(TrackTypeSelector, { model: model }),
        React.createElement(TrackAssemblySelector, { model: model }),
        isElectron && supportedForIndexing && (React.createElement(FormControl, null,
            React.createElement(FormControlLabel, { label: 'Index track for text searching?', control: React.createElement(Checkbox, { checked: check, onChange: e => {
                        setCheck(e.target.checked);
                        model.setTextIndexTrack(e.target.checked);
                    } }) }))),
        isElectron && check && supportedForIndexing ? (React.createElement(TextIndexingConfig, { model: model })) : null));
}
export default observer(ConfirmTrack);
//# sourceMappingURL=ConfirmTrack.js.map