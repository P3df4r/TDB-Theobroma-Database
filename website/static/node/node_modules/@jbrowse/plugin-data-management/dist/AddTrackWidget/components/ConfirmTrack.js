"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const material_1 = require("@mui/material");
const mui_1 = require("tss-react/mui");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const mobx_react_1 = require("mobx-react");
const tracks_1 = require("@jbrowse/core/util/tracks");
// icons
const Delete_1 = __importDefault(require("@mui/icons-material/Delete"));
const Add_1 = __importDefault(require("@mui/icons-material//Add"));
const useStyles = (0, mui_1.makeStyles)()(theme => ({
    spacing: {
        marginBottom: theme.spacing(3),
    },
    paper: {
        display: 'flex',
        flexDirection: 'column',
        padding: theme.spacing(1),
    },
    spacer: {
        height: theme.spacing(8),
    },
    card: {
        marginTop: theme.spacing(1),
    },
}));
function StatusMessage({ trackAdapter, trackType, }) {
    var _a;
    const { classes } = useStyles();
    return trackAdapter.type === 'SNPCoverageAdapter' ? (react_1.default.createElement(material_1.Typography, { className: classes.spacing },
        "Selected ",
        react_1.default.createElement("code", null, trackType),
        ". Using adapter",
        ' ',
        react_1.default.createElement("code", null, trackAdapter.type),
        " with subadapter",
        ' ',
        react_1.default.createElement("code", null, (_a = trackAdapter.subadapter) === null || _a === void 0 ? void 0 : _a.type),
        ". Please enter a track name and, if necessary, update the track type.")) : (react_1.default.createElement(material_1.Typography, { className: classes.spacing },
        "Using adapter ",
        react_1.default.createElement("code", null, trackAdapter.type),
        " and guessing track type",
        ' ',
        react_1.default.createElement("code", null, trackType),
        ". Please enter a track name and, if necessary, update the track type."));
}
/**
 * categorizeAdapters takes a list of adapters and sorts their menu item elements under an appropriate ListSubheader
 *  element. In this way, adapters that are from external plugins can have headers that differentiate them from the
 *  out-of-the-box plugins.
 * @param adaptersList - a list of adapters found in the PluginManager
 * @returns a series of JSX elements that are ListSubheaders followed by the adapters
 *   found under that subheader
 */
function categorizeAdapters(adaptersList) {
    let currentCategory = '';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const items = [];
    adaptersList.forEach(adapter => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ((_a = adapter.adapterMetadata) === null || _a === void 0 ? void 0 : _a.category) {
            if (currentCategory !== ((_b = adapter.adapterMetadata) === null || _b === void 0 ? void 0 : _b.category)) {
                currentCategory = (_c = adapter.adapterMetadata) === null || _c === void 0 ? void 0 : _c.category;
                items.push(react_1.default.createElement(material_1.ListSubheader, { key: (_d = adapter.adapterMetadata) === null || _d === void 0 ? void 0 : _d.category, value: (_e = adapter.adapterMetadata) === null || _e === void 0 ? void 0 : _e.category }, (_f = adapter.adapterMetadata) === null || _f === void 0 ? void 0 : _f.category));
            }
            items.push(react_1.default.createElement(material_1.MenuItem, { key: adapter.name, value: adapter.name }, ((_g = adapter.adapterMetadata) === null || _g === void 0 ? void 0 : _g.displayName)
                ? (_h = adapter.adapterMetadata) === null || _h === void 0 ? void 0 : _h.displayName
                : adapter.name));
        }
    });
    return items;
}
function getAdapterTypes(pluginManager) {
    return pluginManager.getElementTypesInGroup('adapter');
}
function getTrackTypes(pluginManager) {
    return pluginManager.getElementTypesInGroup('track');
}
const TextIndexingConfig = (0, mobx_react_1.observer)(({ model }) => {
    const { classes } = useStyles();
    const [value1, setValue1] = (0, react_1.useState)('');
    const [value2, setValue2] = (0, react_1.useState)('');
    const [attributes, setAttributes] = (0, react_1.useState)(['Name', 'ID']);
    const [exclude, setExclude] = (0, react_1.useState)(['CDS', 'exon']);
    const sections = [
        {
            label: 'Indexing attributes',
            values: attributes,
        },
        {
            label: 'Feature types to exclude',
            values: exclude,
        },
    ];
    (0, react_1.useEffect)(() => {
        model.setTextIndexingConf({ attributes, exclude });
    }, [model, attributes, exclude]);
    return (react_1.default.createElement(material_1.Paper, { className: classes.paper },
        react_1.default.createElement(material_1.InputLabel, null, "Indexing configuration"),
        sections.map((section, index) => (react_1.default.createElement(material_1.Card, { raised: true, key: section.label, className: classes.card },
            react_1.default.createElement(material_1.CardContent, null,
                react_1.default.createElement(material_1.InputLabel, null, section.label),
                react_1.default.createElement(material_1.List, { disablePadding: true },
                    section.values.map((val, idx) => (react_1.default.createElement(material_1.ListItem, { key: idx, disableGutters: true },
                        react_1.default.createElement(material_1.TextField, { value: val, InputProps: {
                                endAdornment: (react_1.default.createElement(material_1.InputAdornment, { position: "end" },
                                    react_1.default.createElement(material_1.IconButton, { color: "secondary", onClick: () => {
                                            const newAttr = section.values.filter((a, i) => {
                                                return i !== idx;
                                            });
                                            index === 0
                                                ? setAttributes(newAttr)
                                                : setExclude(newAttr);
                                        } },
                                        react_1.default.createElement(Delete_1.default, null)))),
                            } })))),
                    react_1.default.createElement(material_1.ListItem, { disableGutters: true },
                        react_1.default.createElement(material_1.TextField, { value: index === 0 ? value1 : value2, placeholder: "add new", onChange: event => {
                                index === 0
                                    ? setValue1(event.target.value)
                                    : setValue2(event.target.value);
                            }, InputProps: {
                                endAdornment: (react_1.default.createElement(material_1.InputAdornment, { position: "end" },
                                    react_1.default.createElement(material_1.IconButton, { onClick: () => {
                                            if (index === 0) {
                                                const newAttr = attributes;
                                                newAttr.push(value1);
                                                setAttributes(newAttr);
                                                setValue1('');
                                            }
                                            else {
                                                const newFeat = exclude;
                                                newFeat.push(value2);
                                                setExclude(newFeat);
                                                setValue2('');
                                            }
                                        }, disabled: index === 0 ? value1 === '' : value2 === '', color: "secondary", "data-testid": `stringArrayAdd-Feat` },
                                        react_1.default.createElement(Add_1.default, null)))),
                            } })))))))));
});
const TrackAdapterSelector = (0, mobx_react_1.observer)(({ model }) => {
    const { classes } = useStyles();
    const { trackAdapter } = model;
    const { pluginManager } = (0, util_1.getEnv)(model);
    const adapters = getAdapterTypes(pluginManager);
    return (react_1.default.createElement(material_1.TextField, { className: classes.spacing, value: (trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type) !== 'UNKNOWN' ? trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type : '', label: "adapterType", helperText: "Select an adapter type", select: true, fullWidth: true, onChange: event => model.setAdapterHint(event.target.value), SelectProps: {
            // @ts-ignore
            SelectDisplayProps: { 'data-testid': 'adapterTypeSelect' },
        } },
        adapters
            // Excludes any adapter with the 'adapterMetadata.hiddenFromGUI' property, and anything with the 'adapterMetadata.category' property
            .filter(elt => {
            var _a, _b;
            return !((_a = elt.adapterMetadata) === null || _a === void 0 ? void 0 : _a.hiddenFromGUI) &&
                !((_b = elt.adapterMetadata) === null || _b === void 0 ? void 0 : _b.category);
        })
            .map(elt => {
            var _a, _b;
            return (react_1.default.createElement(material_1.MenuItem, { key: elt.name, value: elt.name }, ((_a = elt.adapterMetadata) === null || _a === void 0 ? void 0 : _a.displayName)
                ? (_b = elt.adapterMetadata) === null || _b === void 0 ? void 0 : _b.displayName
                : elt.name));
        }),
        // adapters with the 'adapterMetadata.category' property are categorized
        // by the value of the property here
        categorizeAdapters(adapters.filter(elt => { var _a; return !((_a = elt.adapterMetadata) === null || _a === void 0 ? void 0 : _a.hiddenFromGUI); }))));
});
function UnknownAdapterPrompt({ model }) {
    const { classes } = useStyles();
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(material_1.Typography, { className: classes.spacing },
            "JBrowse was not able to guess the adapter type for this data, but it may be in the list below. If not, you can",
            ' ',
            react_1.default.createElement(material_1.Link, { href: "https://github.com/GMOD/jbrowse-components/releases", target: "_blank", rel: "noopener noreferrer" }, "check for new releases"),
            ' ',
            "of JBrowse to see if they support this data type or",
            ' ',
            react_1.default.createElement(material_1.Link, { href: "https://github.com/GMOD/jbrowse-components/issues/new", target: "_blank", rel: "noopener noreferrer" }, "file an issue"),
            ' ',
            "and add a feature request for this data type."),
        react_1.default.createElement(TrackAdapterSelector, { model: model })));
}
const TrackTypeSelector = (0, mobx_react_1.observer)(({ model }) => {
    const { classes } = useStyles();
    const session = (0, util_1.getSession)(model);
    const { trackType } = model;
    const trackTypes = getTrackTypes((0, util_1.getEnv)(session).pluginManager);
    return (react_1.default.createElement(material_1.TextField, { className: classes.spacing, value: trackType, label: "trackType", helperText: "Select a track type", select: true, fullWidth: true, onChange: event => {
            model.setTrackType(event.target.value);
        }, SelectProps: {
            // @ts-ignore
            SelectDisplayProps: { 'data-testid': 'trackTypeSelect' },
        } }, trackTypes.map(({ name }) => (react_1.default.createElement(material_1.MenuItem, { key: name, value: name }, name)))));
});
const TrackAssemblySelector = (0, mobx_react_1.observer)(({ model }) => {
    const session = (0, util_1.getSession)(model);
    const { assembly } = model;
    return (react_1.default.createElement(material_1.TextField, { value: assembly, label: "assemblyName", helperText: "Assembly to which the track will be added", select: true, fullWidth: true, onChange: event => model.setAssembly(event.target.value), SelectProps: {
            // @ts-ignore
            SelectDisplayProps: { 'data-testid': 'assemblyNameSelect' },
        } }, session.assemblies
        .map(conf => (0, configuration_1.readConfObject)(conf, 'name'))
        .map(name => (react_1.default.createElement(material_1.MenuItem, { key: name, value: name }, name)))));
});
function ConfirmTrack({ model }) {
    const { classes } = useStyles();
    const [check, setCheck] = (0, react_1.useState)(true);
    const { trackName, trackAdapter, trackType, warningMessage, adapterHint } = model;
    if (model.unsupported) {
        return (react_1.default.createElement(material_1.Typography, { className: classes.spacing },
            "This version of JBrowse cannot display data of this type. It is possible, however, that there is a newer version that can display them. You can",
            ' ',
            react_1.default.createElement(material_1.Link, { href: "https://github.com/GMOD/jbrowse-components/releases", target: "_blank", rel: "noopener noreferrer" }, "check for new releases"),
            ' ',
            "of JBrowse or",
            ' ',
            react_1.default.createElement(material_1.Link, { href: "https://github.com/GMOD/jbrowse-components/issues/new", target: "_blank", rel: "noopener noreferrer" }, "file an issue"),
            ' ',
            "and add a feature request for this data type."));
    }
    if ((trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type) === tracks_1.UNKNOWN) {
        return react_1.default.createElement(UnknownAdapterPrompt, { model: model });
    }
    if (adapterHint === '' && trackAdapter) {
        model.setAdapterHint(trackAdapter.type);
    }
    if (!(trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type)) {
        return react_1.default.createElement(material_1.Typography, null, "Could not recognize this data type.");
    }
    const supportedForIndexing = (0, util_1.supportedIndexingAdapters)(trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type);
    return (react_1.default.createElement("div", null,
        trackAdapter ? (react_1.default.createElement(StatusMessage, { trackAdapter: trackAdapter, trackType: trackType })) : null,
        warningMessage ? (react_1.default.createElement(material_1.Typography, { style: { color: 'orange' } }, warningMessage)) : null,
        react_1.default.createElement(material_1.TextField, { className: classes.spacing, label: "trackName", helperText: "A name for this track", fullWidth: true, value: trackName, onChange: event => model.setTrackName(event.target.value), inputProps: { 'data-testid': 'trackNameInput' } }),
        react_1.default.createElement(TrackAdapterSelector, { model: model }),
        react_1.default.createElement(TrackTypeSelector, { model: model }),
        react_1.default.createElement(TrackAssemblySelector, { model: model }),
        util_1.isElectron && supportedForIndexing && (react_1.default.createElement(material_1.FormControl, null,
            react_1.default.createElement(material_1.FormControlLabel, { label: 'Index track for text searching?', control: react_1.default.createElement(material_1.Checkbox, { checked: check, onChange: e => {
                        setCheck(e.target.checked);
                        model.setTextIndexTrack(e.target.checked);
                    } }) }))),
        util_1.isElectron && check && supportedForIndexing ? (react_1.default.createElement(TextIndexingConfig, { model: model })) : null));
}
exports.default = (0, mobx_react_1.observer)(ConfirmTrack);
//# sourceMappingURL=ConfirmTrack.js.map