"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateHierarchy = void 0;
const mobx_state_tree_1 = require("mobx-state-tree");
const configuration_1 = require("@jbrowse/core/configuration");
const util_1 = require("@jbrowse/core/util");
const tracks_1 = require("@jbrowse/core/util/tracks");
const mst_1 = require("@jbrowse/core/util/types/mst");
function hasAnyOverlap(a1 = [], a2 = []) {
    return !!a1.find(value => a2.includes(value));
}
function passesFilter(filter, config, session) {
    const categories = (0, configuration_1.readConfObject)(config, 'category');
    const filterLower = filter.toLowerCase();
    return ((0, tracks_1.getTrackName)(config, session).toLowerCase().includes(filterLower) ||
        !!(categories === null || categories === void 0 ? void 0 : categories.filter(c => c.toLowerCase().includes(filterLower)).length));
}
function filterTracks(tracks, self, assemblyName) {
    const { assemblyManager } = (0, util_1.getSession)(self);
    const { pluginManager } = (0, util_1.getEnv)(self);
    const assembly = assemblyManager.get(assemblyName);
    if (!assembly) {
        return [];
    }
    const { allAliases } = assembly;
    return tracks
        .filter(c => hasAnyOverlap(allAliases, (0, configuration_1.readConfObject)(c, 'assemblyNames')))
        .filter(c => {
        const { displayTypes } = pluginManager.getViewType(self.view.type);
        const compatDisplays = displayTypes.map((d) => d.name);
        const trackDisplays = c.displays.map((d) => d.type);
        return hasAnyOverlap(compatDisplays, trackDisplays);
    });
}
function generateHierarchy(model, trackConfigurations, collapsed) {
    const hierarchy = { children: [] };
    const { filterText, view } = model;
    const session = (0, util_1.getSession)(model);
    trackConfigurations
        .filter(conf => passesFilter(filterText, conf, session))
        .forEach(conf => {
        // copy the categories since this array can be mutated downstream
        const categories = [...((0, configuration_1.readConfObject)(conf, 'category') || [])];
        // silly thing where if trackId ends with sessionTrack, then push it to
        // a category that starts with a space to force sort to the top...
        // double whammy hackyness
        if (conf.trackId.endsWith('sessionTrack')) {
            categories.unshift(' Session tracks');
        }
        let currLevel = hierarchy;
        // find existing category to put track into or create it
        for (let i = 0; i < categories.length; i++) {
            const category = categories[i];
            const ret = currLevel.children.find(c => c.name === category);
            const id = categories.slice(0, i + 1).join(',');
            if (!ret) {
                const n = {
                    children: [],
                    name: category,
                    id,
                    isOpenByDefault: !collapsed.get(id),
                };
                currLevel.children.push(n);
                currLevel = n;
            }
            else {
                currLevel = ret;
            }
        }
        const tracks = view.tracks;
        // using splice here tries to group leaf nodes above hierarchical nodes
        currLevel.children.splice(currLevel.children.findIndex(elt => elt.children.length), 0, {
            id: conf.trackId,
            name: (0, tracks_1.getTrackName)(conf, session),
            conf,
            checked: !!tracks.find(f => f.configuration === conf),
            children: [],
        });
    });
    return hierarchy.children;
}
exports.generateHierarchy = generateHierarchy;
function stateTreeFactory(pluginManager) {
    return mobx_state_tree_1.types
        .model('HierarchicalTrackSelectorWidget', {
        id: mst_1.ElementId,
        type: mobx_state_tree_1.types.literal('HierarchicalTrackSelectorWidget'),
        collapsed: mobx_state_tree_1.types.map(mobx_state_tree_1.types.boolean),
        filterText: '',
        view: mobx_state_tree_1.types.safeReference(pluginManager.pluggableMstType('view', 'stateModel')),
    })
        .volatile(() => ({
        selection: [],
    }))
        .actions(self => ({
        addToSelection(elt) {
            self.selection = [...self.selection, ...elt];
        },
        removeFromSelection(elt) {
            self.selection = self.selection.filter(f => !elt.includes(f));
        },
        clearSelection() {
            self.selection = [];
        },
        setView(view) {
            self.view = view;
        },
        toggleCategory(pathName) {
            self.collapsed.set(pathName, !self.collapsed.get(pathName));
        },
        clearFilterText() {
            self.filterText = '';
        },
        setFilterText(newText) {
            self.filterText = newText;
        },
    }))
        .views(self => ({
        getRefSeqTrackConf(assemblyName) {
            const { assemblyManager } = (0, util_1.getSession)(self);
            const assembly = assemblyManager.get(assemblyName);
            const trackConf = assembly === null || assembly === void 0 ? void 0 : assembly.configuration.sequence;
            const viewType = pluginManager.getViewType(self.view.type);
            if (!trackConf) {
                return undefined;
            }
            for (const display of trackConf.displays) {
                if (viewType.displayTypes.find(d => d.name === display.type)) {
                    return trackConf;
                }
            }
        },
    }))
        .views(self => ({
        trackConfigurations(assemblyName) {
            if (!self.view) {
                return [];
            }
            const { tracks, assemblyManager } = (0, util_1.getSession)(self);
            const assembly = assemblyManager.get(assemblyName);
            if (!assembly) {
                return [];
            }
            const refseq = self.getRefSeqTrackConf(assemblyName);
            // filter out tracks that don't match the current assembly (check all
            // assembly aliases) and display types
            return (refseq ? [refseq] : []).concat([
                ...filterTracks(tracks, self, assemblyName),
            ]);
        },
        get assemblyNames() {
            var _a;
            return ((_a = self.view) === null || _a === void 0 ? void 0 : _a.assemblyNames) || [];
        },
        connectionTrackConfigurations(assemblyName, connection) {
            if (!self.view) {
                return [];
            }
            // filter out tracks that don't match the current display types
            return filterTracks(connection.tracks, self, assemblyName);
        },
    }))
        .views(self => ({
        hierarchy(assemblyName) {
            const hier = generateHierarchy(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            self, self.trackConfigurations(assemblyName), self.collapsed);
            const session = (0, util_1.getSession)(self);
            const { connectionInstances } = session;
            const { assemblyManager } = (0, util_1.getSession)(self);
            const assembly = assemblyManager.get(assemblyName);
            const conns = (assembly &&
                (connectionInstances === null || connectionInstances === void 0 ? void 0 : connectionInstances.filter(c => hasAnyOverlap(assembly.allAliases, (0, configuration_1.getConf)(c, 'assemblyNames'))).map(c => ({
                    // @ts-ignore
                    id: (0, mobx_state_tree_1.getSnapshot)(c).configuration,
                    name: (0, configuration_1.getConf)(c, 'name'),
                    children: this.connectionHierarchy(assemblyName, c),
                    state: {
                        expanded: true,
                    },
                })))) ||
                [];
            return {
                name: 'Root',
                id: 'Root',
                children: [
                    { name: 'Tracks', id: 'Tracks', children: hier },
                    ...conns,
                ],
            };
        },
        connectionHierarchy(assemblyName, connection) {
            return generateHierarchy(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            self, self.connectionTrackConfigurations(assemblyName, connection), self.collapsed);
        },
    }));
}
exports.default = stateTreeFactory;
//# sourceMappingURL=model.js.map