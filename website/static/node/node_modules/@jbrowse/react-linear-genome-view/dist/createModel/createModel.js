"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assemblyManager_1 = __importStar(require("@jbrowse/core/assemblyManager"));
const PluginManager_1 = __importDefault(require("@jbrowse/core/PluginManager"));
const RpcManager_1 = __importDefault(require("@jbrowse/core/rpc/RpcManager"));
const TextSearchManager_1 = __importDefault(require("@jbrowse/core/TextSearch/TextSearchManager"));
const mobx_state_tree_1 = require("mobx-state-tree");
const corePlugins_1 = __importDefault(require("../corePlugins"));
const createConfigModel_1 = __importDefault(require("./createConfigModel"));
const createSessionModel_1 = __importDefault(require("./createSessionModel"));
function createModel(runtimePlugins, makeWorkerInstance = () => {
    throw new Error('no makeWorkerInstance supplied');
}) {
    const pluginManager = new PluginManager_1.default([...corePlugins_1.default, ...runtimePlugins].map(P => new P()));
    pluginManager.createPluggableElements();
    const Session = (0, createSessionModel_1.default)(pluginManager);
    const assemblyConfig = (0, assemblyManager_1.assemblyConfigSchemaFactory)(pluginManager);
    const AssemblyManager = (0, assemblyManager_1.default)(assemblyConfig, pluginManager);
    const rootModel = mobx_state_tree_1.types
        .model('ReactLinearGenomeView', {
        config: (0, createConfigModel_1.default)(pluginManager, assemblyConfig),
        session: Session,
        assemblyManager: mobx_state_tree_1.types.optional(AssemblyManager, {}),
        disableAddTracks: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
        internetAccounts: mobx_state_tree_1.types.array(pluginManager.pluggableMstType('internet account', 'stateModel')),
    })
        .volatile(self => ({
        error: undefined,
        rpcManager: new RpcManager_1.default(pluginManager, self.config.configuration.rpc, {
            WebWorkerRpcDriver: {
                makeWorkerInstance,
            },
            MainThreadRpcDriver: {},
        }),
        textSearchManager: new TextSearchManager_1.default(pluginManager),
    }))
        .actions(self => ({
        setSession(sessionSnapshot) {
            self.session = (0, mobx_state_tree_1.cast)(sessionSnapshot);
        },
        renameCurrentSession(sessionName) {
            if (self.session) {
                const snapshot = JSON.parse(JSON.stringify((0, mobx_state_tree_1.getSnapshot)(self.session)));
                snapshot.name = sessionName;
                this.setSession(snapshot);
            }
        },
        setError(errorMessage) {
            self.error = errorMessage;
        },
        addInternetAccount(internetAccount) {
            self.internetAccounts.push(internetAccount);
        },
        findAppropriateInternetAccount(location) {
            // find the existing account selected from menu
            const selectedId = location.internetAccountId;
            if (selectedId) {
                const selectedAccount = self.internetAccounts.find(account => {
                    return account.internetAccountId === selectedId;
                });
                if (selectedAccount) {
                    return selectedAccount;
                }
            }
            // if no existing account or not found, try to find working account
            for (const account of self.internetAccounts) {
                const handleResult = account.handlesLocation(location);
                if (handleResult) {
                    return account;
                }
            }
            // no available internet accounts
            return null;
        },
    }))
        .views(self => ({
        get jbrowse() {
            return self.config;
        },
    }));
    return { model: rootModel, pluginManager };
}
exports.default = createModel;
//# sourceMappingURL=createModel.js.map