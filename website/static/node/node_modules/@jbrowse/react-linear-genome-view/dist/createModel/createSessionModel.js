"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SnackbarModel_1 = __importDefault(require("@jbrowse/core/ui/SnackbarModel"));
const util_1 = require("@jbrowse/core/util");
const configuration_1 = require("@jbrowse/core/configuration");
const version_1 = require("../version");
const mobx_state_tree_1 = require("mobx-state-tree");
const Info_1 = __importDefault(require("@mui/icons-material/Info"));
const AboutDialog_1 = __importDefault(require("@jbrowse/core/ui/AboutDialog"));
function sessionModelFactory(pluginManager) {
    const model = mobx_state_tree_1.types
        .model('ReactLinearGenomeViewSession', {
        name: mobx_state_tree_1.types.identifier,
        margin: 0,
        view: pluginManager.getViewType('LinearGenomeView')
            .stateModel,
        widgets: mobx_state_tree_1.types.map(pluginManager.pluggableMstType('widget', 'stateModel')),
        activeWidgets: mobx_state_tree_1.types.map(mobx_state_tree_1.types.safeReference(pluginManager.pluggableMstType('widget', 'stateModel'))),
        connectionInstances: mobx_state_tree_1.types.array(pluginManager.pluggableMstType('connection', 'stateModel')),
        sessionTracks: mobx_state_tree_1.types.array(pluginManager.pluggableConfigSchemaType('track')),
    })
        .volatile(( /* self */) => ({
        /**
         * this is the globally "selected" object. can be anything.
         * code that wants to deal with this should examine it to see what
         * kind of thing it is.
         */
        selection: undefined,
        /**
         * this is the current "task" that is being performed in the UI.
         * this is usually an object of the form
         * `{ taskName: "configure", target: thing_being_configured }`
         */
        task: undefined,
        queueOfDialogs: [],
    }))
        .views(self => ({
        get disableAddTracks() {
            return (0, mobx_state_tree_1.getParent)(self).disableAddTracks;
        },
        get DialogComponent() {
            var _a;
            if (self.queueOfDialogs.length) {
                return (_a = self.queueOfDialogs[0]) === null || _a === void 0 ? void 0 : _a[0];
            }
            return undefined;
        },
        get DialogProps() {
            var _a;
            if (self.queueOfDialogs.length) {
                return (_a = self.queueOfDialogs[0]) === null || _a === void 0 ? void 0 : _a[1];
            }
            return undefined;
        },
        get textSearchManager() {
            return (0, mobx_state_tree_1.getParent)(self).textSearchManager;
        },
        get rpcManager() {
            return (0, mobx_state_tree_1.getParent)(self).rpcManager;
        },
        get configuration() {
            return (0, mobx_state_tree_1.getParent)(self).config.configuration;
        },
        get assemblies() {
            return [(0, mobx_state_tree_1.getParent)(self).config.assembly];
        },
        get assemblyNames() {
            return [(0, mobx_state_tree_1.getParent)(self).config.assemblyName];
        },
        get tracks() {
            return (0, mobx_state_tree_1.getParent)(self).config.tracks;
        },
        get aggregateTextSearchAdapters() {
            return (0, mobx_state_tree_1.getParent)(self).config.aggregateTextSearchAdapters;
        },
        get connections() {
            return (0, mobx_state_tree_1.getParent)(self).config.connections;
        },
        get adminMode() {
            return false;
        },
        get assemblyManager() {
            return (0, mobx_state_tree_1.getParent)(self).assemblyManager;
        },
        get version() {
            return version_1.version;
        },
        get views() {
            return [self.view];
        },
        renderProps() {
            return { theme: (0, configuration_1.readConfObject)(this.configuration, 'theme') };
        },
        get visibleWidget() {
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                // returns most recently added item in active widgets
                return Array.from(self.activeWidgets.values())[self.activeWidgets.size - 1];
            }
            return undefined;
        },
        /**
         * See if any MST nodes currently have a types.reference to this object.
         * @param object - object
         * @returns An array where the first element is the node referring
         * to the object and the second element is they property name the node is
         * using to refer to the object
         */
        getReferring(object) {
            const refs = [];
            (0, mobx_state_tree_1.walk)((0, mobx_state_tree_1.getParent)(self), node => {
                if ((0, mobx_state_tree_1.isModelType)((0, mobx_state_tree_1.getType)(node))) {
                    const members = (0, mobx_state_tree_1.getMembers)(node);
                    Object.entries(members.properties).forEach(([key, value]) => {
                        // @ts-ignore
                        if ((0, mobx_state_tree_1.isReferenceType)(value) && node[key] === object) {
                            refs.push({ node, key });
                        }
                    });
                }
            });
            return refs;
        },
    }))
        .actions(self => ({
        addTrackConf(trackConf) {
            const { trackId, type } = trackConf;
            if (!type) {
                throw new Error(`unknown track type ${type}`);
            }
            const track = self.sessionTracks.find((t) => t.trackId === trackId);
            if (track) {
                return track;
            }
            const length = self.sessionTracks.push(trackConf);
            return self.sessionTracks[length - 1];
        },
        queueDialog(callback) {
            const [component, props] = callback(() => {
                this.removeActiveDialog();
            });
            self.queueOfDialogs = [...self.queueOfDialogs, [component, props]];
        },
        removeActiveDialog() {
            self.queueOfDialogs = self.queueOfDialogs.slice(1);
        },
        makeConnection(configuration, initialSnapshot = {}) {
            const { type } = configuration;
            if (!type) {
                throw new Error('track configuration has no `type` listed');
            }
            const name = (0, configuration_1.readConfObject)(configuration, 'name');
            const connectionType = pluginManager.getConnectionType(type);
            if (!connectionType) {
                throw new Error(`unknown connection type ${type}`);
            }
            const connectionData = {
                ...initialSnapshot,
                name,
                type,
                configuration,
            };
            const length = self.connectionInstances.push(connectionData);
            return self.connectionInstances[length - 1];
        },
        removeReferring(referring, track, callbacks, dereferenceTypeCount) {
            referring.forEach(({ node }) => {
                let dereferenced = false;
                try {
                    // If a view is referring to the track config, remove the track
                    // from the view
                    const type = 'open track(s)';
                    const view = (0, util_1.getContainingView)(node);
                    callbacks.push(() => view.hideTrack(track.trackId));
                    dereferenced = true;
                    if (!dereferenceTypeCount[type]) {
                        dereferenceTypeCount[type] = 0;
                    }
                    dereferenceTypeCount[type] += 1;
                }
                catch (err1) {
                    // ignore
                }
                if (this.hasWidget(node)) {
                    // If a configuration editor widget has the track config
                    // open, close the widget
                    const type = 'configuration editor widget(s)';
                    callbacks.push(() => this.hideWidget(node));
                    dereferenced = true;
                    if (!dereferenceTypeCount[type]) {
                        dereferenceTypeCount[type] = 0;
                    }
                    dereferenceTypeCount[type] += 1;
                }
                if (!dereferenced) {
                    throw new Error(`Error when closing this connection, the following node is still referring to a track configuration: ${JSON.stringify((0, mobx_state_tree_1.getSnapshot)(node))}`);
                }
            });
        },
        prepareToBreakConnection(configuration) {
            const callbacksToDereferenceTrack = [];
            const dereferenceTypeCount = {};
            const name = (0, configuration_1.readConfObject)(configuration, 'name');
            const connection = self.connectionInstances.find(c => c.name === name);
            connection.tracks.forEach((track) => {
                const referring = self.getReferring(track);
                this.removeReferring(referring, track, callbacksToDereferenceTrack, dereferenceTypeCount);
            });
            const safelyBreakConnection = () => {
                callbacksToDereferenceTrack.forEach(cb => cb());
                this.breakConnection(configuration);
            };
            return [safelyBreakConnection, dereferenceTypeCount];
        },
        breakConnection(configuration) {
            const name = (0, configuration_1.readConfObject)(configuration, 'name');
            const connection = self.connectionInstances.find(c => c.name === name);
            self.connectionInstances.remove(connection);
        },
        addView(typeName, initialState = {}) {
            const typeDefinition = pluginManager.getElementType('view', typeName);
            if (!typeDefinition) {
                throw new Error(`unknown view type ${typeName}`);
            }
            self.view = (0, mobx_state_tree_1.cast)({
                ...initialState,
                type: typeName,
            });
            return self.view;
        },
        removeView() { },
        addWidget(typeName, id, initialState = {}, configuration = { type: typeName }) {
            const typeDefinition = pluginManager.getElementType('widget', typeName);
            if (!typeDefinition) {
                throw new Error(`unknown widget type ${typeName}`);
            }
            const data = {
                ...initialState,
                id,
                type: typeName,
                configuration,
            };
            self.widgets.set(id, data);
            return self.widgets.get(id);
        },
        showWidget(widget) {
            if (self.activeWidgets.has(widget.id)) {
                self.activeWidgets.delete(widget.id);
            }
            self.activeWidgets.set(widget.id, widget);
        },
        hasWidget(widget) {
            return self.activeWidgets.has(widget.id);
        },
        hideWidget(widget) {
            self.activeWidgets.delete(widget.id);
        },
        hideAllWidgets() {
            self.activeWidgets.clear();
        },
        /**
         * set the global selection, i.e. the globally-selected object.
         * can be a feature, a view, just about anything
         * @param thing -
         */
        setSelection(thing) {
            self.selection = thing;
        },
        /**
         * clears the global selection
         */
        clearSelection() {
            self.selection = undefined;
        },
        clearConnections() {
            self.connectionInstances.length = 0;
        },
        renameCurrentSession(sessionName) {
            return (0, mobx_state_tree_1.getParent)(self).renameCurrentSession(sessionName);
        },
    }))
        .views(self => ({
        getTrackActionMenuItems(config) {
            return [
                {
                    label: 'About track',
                    onClick: () => {
                        self.queueDialog(doneCallback => [
                            AboutDialog_1.default,
                            { config, handleClose: doneCallback },
                        ]);
                    },
                    icon: Info_1.default,
                },
            ];
        },
    }));
    return (0, SnackbarModel_1.default)(model);
}
exports.default = sessionModelFactory;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function z(x) {
    // this function's sole purpose is to get typescript to check
    // that the session model implements all of AbstractSessionModel
    return x;
}
//# sourceMappingURL=createSessionModel.js.map