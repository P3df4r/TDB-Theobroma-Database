"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
const createModel_1 = __importDefault(require("./createModel"));
function createViewState(opts) {
    const { assembly, tracks, internetAccounts, configuration, aggregateTextSearchAdapters, plugins, location, onChange, disableAddTracks = false, makeWorkerInstance, } = opts;
    const { model, pluginManager } = (0, createModel_1.default)(plugins || [], makeWorkerInstance);
    let { defaultSession } = opts;
    if (!defaultSession) {
        defaultSession = {
            name: 'this session',
            view: {
                id: 'linearGenomeView',
                type: 'LinearGenomeView',
            },
        };
    }
    const stateTree = model.create({
        config: {
            configuration,
            assembly,
            tracks,
            internetAccounts,
            aggregateTextSearchAdapters,
        },
        disableAddTracks,
        session: defaultSession,
    }, { pluginManager });
    stateTree.config.internetAccounts.forEach(account => {
        const internetAccountType = pluginManager.getInternetAccountType(account.type);
        if (!internetAccountType) {
            throw new Error(`unknown internet account type ${account.type}`);
        }
        stateTree.addInternetAccount({
            type: account.type,
            configuration: account,
        });
    });
    pluginManager.setRootModel(stateTree);
    pluginManager.configure();
    if (location) {
        (0, mobx_1.autorun)(async (reaction) => {
            const { session } = stateTree;
            if (!session.view.initialized) {
                return;
            }
            if (typeof location === 'string') {
                session.view.navToLocString(location, assembly.name);
            }
            else {
                session.view.navTo(location);
            }
            reaction.dispose();
        });
    }
    if (onChange) {
        (0, mobx_state_tree_1.onPatch)(stateTree, onChange);
    }
    return stateTree;
}
exports.default = createViewState;
//# sourceMappingURL=createViewState.js.map