"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const rxjs_1 = require("@jbrowse/core/util/rxjs");
const util_1 = require("@jbrowse/core/util");
const operators_1 = require("rxjs/operators");
class default_1 extends BaseAdapter_1.BaseFeatureDataAdapter {
    constructor() {
        super(...arguments);
        this.windowSize = 1000;
        this.windowDelta = 1000;
        this.gcMode = 'content';
    }
    async configure() {
        var _a;
        const adapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, this.getConf('sequenceAdapter')));
        if (!adapter) {
            throw new Error('Error getting subadapter');
        }
        return adapter.dataAdapter;
    }
    async getRefNames() {
        const adapter = await this.configure();
        return adapter.getRefNames();
    }
    getFeatures(query, opts) {
        return (0, rxjs_1.ObservableCreate)(async (observer) => {
            var _a;
            const sequenceAdapter = await this.configure();
            const hw = this.windowSize === 1 ? 1 : this.windowSize / 2; // Half the window size
            const f = this.windowSize === 1;
            let { start: queryStart, end: queryEnd } = query;
            queryStart = Math.max(0, queryStart - hw);
            queryEnd += hw;
            if (queryEnd < 0 || queryStart > queryEnd) {
                observer.complete();
                return;
            }
            const ret = sequenceAdapter.getFeatures({
                ...query,
                start: queryStart,
                end: queryEnd,
            }, opts);
            const feats = await ret.pipe((0, operators_1.toArray)()).toPromise();
            const residues = ((_a = feats[0]) === null || _a === void 0 ? void 0 : _a.get('seq')) || '';
            for (let i = hw; i < residues.length - hw; i += this.windowDelta) {
                const r = f ? residues[i] : residues.slice(i - hw, i + hw);
                let nc = 0;
                let ng = 0;
                let len = 0;
                for (let j = 0; j < r.length; j++) {
                    if (r[j] === 'c' || r[j] === 'C') {
                        nc++;
                    }
                    else if (r[j] === 'g' || r[j] === 'G') {
                        ng++;
                    }
                    if (r[j] !== 'N') {
                        len++;
                    }
                }
                const pos = queryStart;
                let score;
                if (this.gcMode === 'content') {
                    score = (ng + nc) / (len || 1);
                }
                else if (this.gcMode === 'skew') {
                    score = (ng - nc) / (ng + nc || 1);
                }
                observer.next(new util_1.SimpleFeature({
                    uniqueId: `${this.id}_${pos + i}`,
                    start: pos + i,
                    end: pos + i + this.windowDelta,
                    score,
                }));
            }
            observer.complete();
        });
    }
    /**
     * called to provide a hint that data tied to a certain region
     * will not be needed for the forseeable future and can be purged
     * from caches, etc
     */
    freeResources( /* { region } */) { }
}
exports.default = default_1;
default_1.capabilities = ['hasLocalStats'];
//# sourceMappingURL=GCContentAdapter.js.map