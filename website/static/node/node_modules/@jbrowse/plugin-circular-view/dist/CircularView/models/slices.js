"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliceIsVisible = exports.calculateStaticSlices = exports.Slice = void 0;
const util_1 = require("@jbrowse/core/util");
const viewportVisibleRegion_1 = require("./viewportVisibleRegion");
class Slice {
    constructor(view, region, currentRadianOffset, radianWidth) {
        this.region = region;
        this.radianWidth = radianWidth;
        const { bpPerRadian } = view;
        this.key = (0, util_1.assembleLocString)(region);
        this.offsetRadians = currentRadianOffset;
        this.bpPerRadian = bpPerRadian;
        this.flipped = false;
        this.startRadians = this.offsetRadians;
        this.endRadians = region.widthBp / this.bpPerRadian + this.offsetRadians;
        Object.freeze(this);
    }
    bpToXY(bp, radiusPx) {
        let offsetBp;
        if (this.region.elided) {
            offsetBp = this.region.widthBp / 2;
        }
        else if (this.flipped) {
            offsetBp = this.region.end - bp;
        }
        else {
            offsetBp = bp - this.region.start;
        }
        const totalRadians = offsetBp / this.bpPerRadian + this.offsetRadians;
        return (0, util_1.polarToCartesian)(radiusPx, totalRadians);
    }
    toJSON() {
        return Object.fromEntries(Object.entries(this));
    }
}
exports.Slice = Slice;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function calculateStaticSlices(self) {
    const slices = [];
    let currentRadianOffset = 0;
    for (const region of self.elidedRegions) {
        const radianWidth = region.widthBp / self.bpPerRadian + self.spacingPx / self.pxPerRadian;
        slices.push(new Slice(self, region, currentRadianOffset, radianWidth));
        currentRadianOffset += radianWidth;
    }
    return slices;
}
exports.calculateStaticSlices = calculateStaticSlices;
function sliceIsVisible(self, slice) {
    const { theta: [visibleThetaMin, visibleThetaMax], } = self.visibleSection;
    return (0, viewportVisibleRegion_1.thetaRangesOverlap)(slice.offsetRadians + self.offsetRadians, slice.radianWidth, visibleThetaMin, visibleThetaMax - visibleThetaMin);
}
exports.sliceIsVisible = sliceIsVisible;
//# sourceMappingURL=slices.js.map