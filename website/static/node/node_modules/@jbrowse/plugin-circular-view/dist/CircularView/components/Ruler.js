"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const mobx_react_1 = require("mobx-react");
const util_1 = require("@jbrowse/core/util");
const color_1 = require("@jbrowse/core/util/color");
const styles_1 = require("@mui/material/styles");
const mui_1 = require("tss-react/mui");
const useStyles = (0, mui_1.makeStyles)()({
    rulerLabel: {
        fontSize: '0.8rem',
        fontWeight: 500,
        lineHeight: 1.6,
        letterSpacing: '0.0075em',
    },
});
function sliceArcPath(slice, radiusPx, startBase, endBase) {
    // A rx ry x-axis-rotation large-arc-flag sweep-flag x y
    if (slice.flipped) {
        ;
        [startBase, endBase] = [endBase, startBase];
    }
    const startXY = slice.bpToXY(startBase, radiusPx);
    const endXY = slice.bpToXY(endBase, radiusPx);
    const largeArc = Math.abs(endBase - startBase) / slice.bpPerRadian > Math.PI ? '1' : '0';
    const sweepFlag = '1';
    return [
        'M',
        ...startXY,
        'A',
        radiusPx,
        radiusPx,
        '0',
        largeArc,
        sweepFlag,
        ...endXY,
    ].join(' ');
}
const ElisionRulerArc = (0, mobx_react_1.observer)(({ model, slice }) => {
    const theme = (0, styles_1.useTheme)();
    const { radiusPx: modelRadiusPx } = model;
    const radiusPx = modelRadiusPx + 1;
    const { endRadians, startRadians, region } = slice;
    const startXY = (0, util_1.polarToCartesian)(radiusPx, startRadians);
    const endXY = (0, util_1.polarToCartesian)(radiusPx, endRadians);
    const widthPx = (endRadians - startRadians) * radiusPx;
    const largeArc = endRadians - startRadians > Math.PI ? '1' : '0';
    // TODO: draw the elision
    const centerRadians = (endRadians + startRadians) / 2;
    const regionCountString = `[${Number(
    // @ts-ignore
    region.regions.length).toLocaleString()}]`;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(RulerLabel, { text: regionCountString, view: model, maxWidthPx: widthPx, radians: centerRadians, radiusPx: radiusPx, title: `${Number(
            // @ts-ignore
            region.regions.length).toLocaleString()} more regions`, color: theme.palette.text.primary }),
        react_1.default.createElement("path", { d: [
                'M',
                ...startXY,
                'A',
                radiusPx,
                radiusPx,
                '0',
                largeArc,
                '1',
                ...endXY,
            ].join(' '), stroke: theme.palette.text.secondary, strokeWidth: 2, strokeDasharray: "2,2", fill: "none" })));
});
const RulerLabel = (0, mobx_react_1.observer)(({ view, text, maxWidthPx, radians, radiusPx, title, color, }) => {
    const { classes } = useStyles();
    const textXY = (0, util_1.polarToCartesian)(radiusPx + 5, radians);
    if (!text) {
        return null;
    }
    if (text.length * 6.5 < maxWidthPx) {
        // text is rotated parallel to the ruler arc
        return (react_1.default.createElement("text", { x: 0, y: 0, className: classes.rulerLabel, textAnchor: "middle", dominantBaseline: "baseline", transform: `translate(${textXY}) rotate(${(0, util_1.radToDeg)(radians) + 90})`, style: { fill: color } },
            text,
            react_1.default.createElement("title", null, title || text)));
    }
    if (maxWidthPx > 4) {
        // text is rotated perpendicular to the ruler arc
        const overallRotation = (0, util_1.radToDeg)(radians + view.offsetRadians - Math.PI / 2);
        if (overallRotation >= 180) {
            return (react_1.default.createElement("text", { x: 0, y: 0, className: classes.rulerLabel, textAnchor: "start", dominantBaseline: "middle", transform: `translate(${textXY}) rotate(${(0, util_1.radToDeg)(radians)})`, style: { fill: color } },
                text,
                react_1.default.createElement("title", null, title || text)));
        }
        return (react_1.default.createElement("text", { x: 0, y: 0, className: classes.rulerLabel, textAnchor: "end", dominantBaseline: "middle", transform: `translate(${textXY}) rotate(${(0, util_1.radToDeg)(radians) + 180})`, style: { fill: color } },
            text,
            react_1.default.createElement("title", null, title || text)));
    }
    // if you get here there is no room for the text at all
    return null;
});
const RegionRulerArc = (0, mobx_react_1.observer)(({ model, slice }) => {
    const theme = (0, styles_1.useTheme)();
    const { radiusPx } = model;
    const { region, endRadians, startRadians } = slice;
    const centerRadians = (endRadians + startRadians) / 2;
    const widthPx = (endRadians - startRadians) * radiusPx;
    const session = (0, util_1.getSession)(model);
    let color;
    const assembly = session.assemblyManager.get(slice.region.assemblyName);
    if (assembly) {
        color = assembly.getRefNameColor(region.refName);
    }
    if (color) {
        try {
            color = (0, color_1.makeContrasting)(color, theme.palette.background.paper);
        }
        catch (error) {
            color = theme.palette.text.primary;
        }
    }
    else {
        color = theme.palette.text.primary;
    }
    // TODO: slice flipping
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(RulerLabel, { text: region.refName, view: model, maxWidthPx: widthPx, radians: centerRadians, radiusPx: radiusPx, color: color }),
        react_1.default.createElement("path", { d: sliceArcPath(slice, radiusPx + 1, region.start, region.end), stroke: color, strokeWidth: 2, fill: "none" },
            react_1.default.createElement("title", null, region.refName))));
});
const CircularRuler = (0, mobx_react_1.observer)(({ model, slice }) => {
    if (slice.region.elided) {
        return (react_1.default.createElement(ElisionRulerArc, { key: 
            /* @ts-ignore */
            (0, util_1.assembleLocString)(slice.region.regions[0]), model: model, slice: slice }));
    }
    return (react_1.default.createElement(RegionRulerArc, { key: (0, util_1.assembleLocString)(slice.region), model: model, slice: slice }));
});
exports.default = CircularRuler;
//# sourceMappingURL=Ruler.js.map