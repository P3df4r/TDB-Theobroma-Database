"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderReactionEffect = exports.renderReactionData = void 0;
const tracks_1 = require("@jbrowse/core/util/tracks");
const util_1 = require("@jbrowse/core/util");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function renderReactionData(self) {
    var _a;
    const view = (0, util_1.getContainingView)(self);
    const { rendererType } = self;
    const { rpcManager } = (0, util_1.getSession)(view);
    return {
        rendererType,
        rpcManager,
        renderProps: self.renderProps(),
        renderArgs: {
            assemblyName: (_a = view.displayedRegions[0]) === null || _a === void 0 ? void 0 : _a.assemblyName,
            adapterConfig: JSON.parse(JSON.stringify(self.adapterConfig)),
            rendererType: rendererType.name,
            regions: JSON.parse(JSON.stringify(view.displayedRegions)),
            blockDefinitions: self.blockDefinitions,
            sessionId: (0, tracks_1.getRpcSessionId)(self),
            timeout: 1000000,
        },
    };
}
exports.renderReactionData = renderReactionData;
async function renderReactionEffect(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
props, signal, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self) {
    if (!props) {
        throw new Error('cannot render with no props');
    }
    const { rendererType, rpcManager, cannotBeRenderedReason, renderArgs, renderProps, } = props;
    if (cannotBeRenderedReason) {
        return { message: cannotBeRenderedReason };
    }
    // don't try to render 0 or NaN radius or no regions
    if (!props.renderProps.radius ||
        !props.renderArgs.regions ||
        !props.renderArgs.regions.length) {
        return { message: 'Skipping render' };
    }
    // check renderertype compatibility
    if (!self.isCompatibleWithRenderer(rendererType)) {
        throw new Error(`renderer ${rendererType.name} is not compatible with this display type`);
    }
    const { html, ...data } = await rendererType.renderInClient(rpcManager, {
        ...renderArgs,
        ...renderProps,
        signal,
    });
    return { html, data, renderingComponent: rendererType.ReactComponent };
}
exports.renderReactionEffect = renderReactionEffect;
//# sourceMappingURL=renderReaction.js.map