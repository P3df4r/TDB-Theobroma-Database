"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseChordDisplayModel = void 0;
const configuration_1 = require("@jbrowse/core/configuration");
const models_1 = require("@jbrowse/core/pluggableElementTypes/models");
const CircularChordRendererType_1 = __importDefault(require("@jbrowse/core/pluggableElementTypes/renderers/CircularChordRendererType"));
const util_1 = require("@jbrowse/core/util");
const simpleFeature_1 = require("@jbrowse/core/util/simpleFeature");
const tracks_1 = require("@jbrowse/core/util/tracks");
const mobx_state_tree_1 = require("mobx-state-tree");
// locals
const renderReaction_1 = require("./renderReaction");
/**
 * #stateModel BaseChordDisplay
 * extends `BaseDisplay`
 */
function stateModelFactory() {
    return mobx_state_tree_1.types
        .compose('BaseChordDisplay', models_1.BaseDisplay, mobx_state_tree_1.types.model({
        /**
         * #property
         */
        bezierRadiusRatio: 0.1,
        /**
         * #property
         */
        assemblyName: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
    }))
        .volatile(() => {
        return {
            // NOTE: all this volatile stuff has to be filled in at once
            // so that it stays consistent
            filled: false,
            reactElement: undefined,
            data: undefined,
            message: '',
            renderingComponent: undefined,
            refNameMap: undefined,
        };
    })
        .actions(self => {
        const { pluginManager } = (0, util_1.getEnv)(self);
        const track = self;
        return {
            /**
             * #action
             */
            onChordClick(feature) {
                (0, configuration_1.getConf)(self, 'onChordClick', { feature, track, pluginManager });
            },
        };
    })
        .views(self => ({
        /**
         * #getter
         */
        get blockDefinitions() {
            const origSlices = (0, util_1.getContainingView)(self)
                .staticSlices;
            if (!self.refNameMap) {
                return origSlices;
            }
            const slices = JSON.parse(JSON.stringify(origSlices));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            slices.forEach((slice) => {
                const regions = slice.region.elided
                    ? slice.region.regions
                    : [slice.region];
                regions.forEach((region) => {
                    var _a;
                    const renamed = (_a = self.refNameMap) === null || _a === void 0 ? void 0 : _a[region.refName];
                    if (renamed && region.refName !== renamed) {
                        region.refName = renamed;
                    }
                });
            });
            return slices;
        },
        /**
         * #method
         */
        renderProps() {
            const view = (0, util_1.getContainingView)(self);
            return {
                ...(0, tracks_1.getParentRenderProps)(self),
                rpcDriverName: self.rpcDriverName,
                displayModel: self,
                bezierRadius: view.radiusPx * self.bezierRadiusRatio,
                radius: view.radiusPx,
                blockDefinitions: this.blockDefinitions,
                onChordClick: self.onChordClick,
            };
        },
        /**
         * #getter
         * the pluggable element type object for this diplay's
         * renderer
         */
        get rendererType() {
            const display = self;
            const { pluginManager } = (0, util_1.getEnv)(self);
            const ThisRendererType = pluginManager.getRendererType(self.rendererTypeName);
            if (!ThisRendererType) {
                throw new Error(`renderer "${display.rendererTypeName}" not found`);
            }
            if (!ThisRendererType.ReactComponent) {
                throw new Error(`renderer ${display.rendererTypeName} has no ReactComponent, it may not be completely implemented yet`);
            }
            return ThisRendererType;
        },
        /**
         * #method
         */
        isCompatibleWithRenderer(renderer) {
            return !!(renderer instanceof CircularChordRendererType_1.default);
        },
        /**
         * #getter
         * returns a string feature ID if the globally-selected object
         * is probably a feature
         */
        get selectedFeatureId() {
            if (!(0, mobx_state_tree_1.isAlive)(self)) {
                return undefined;
            }
            const session = (0, util_1.getSession)(self);
            if (!session) {
                return undefined;
            }
            const { selection } = session;
            // does it quack like a feature?
            if ((0, simpleFeature_1.isFeature)(selection)) {
                return selection.id();
            }
            return undefined;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        renderStarted() {
            self.filled = false;
            self.message = '';
            self.reactElement = undefined;
            self.data = undefined;
            self.error = undefined;
            self.renderingComponent = undefined;
        },
        /**
         * #action
         */
        renderSuccess({ message, data, reactElement, renderingComponent, }) {
            if (message) {
                self.filled = false;
                self.message = message;
                self.reactElement = undefined;
                self.data = undefined;
                self.error = undefined;
                self.renderingComponent = undefined;
            }
            else {
                self.filled = true;
                self.message = '';
                self.reactElement = reactElement;
                self.data = data;
                self.error = undefined;
                self.renderingComponent = renderingComponent;
            }
        },
        /**
         * #action
         */
        renderError(error) {
            console.error(error);
            // the rendering failed for some reason
            self.filled = false;
            self.message = '';
            self.reactElement = undefined;
            self.data = undefined;
            self.error = error;
            self.renderingComponent = undefined;
        },
        /**
         * #action
         */
        setRefNameMap(refNameMap) {
            self.refNameMap = refNameMap;
        },
    }))
        .actions(self => ({
        afterAttach() {
            (0, util_1.makeAbortableReaction)(self, renderReaction_1.renderReactionData, 
            // @ts-ignore
            renderReaction_1.renderReactionEffect, {
                name: `${self.type} ${self.id} rendering`,
                // delay: self.renderDelay || 300,
                fireImmediately: true,
            }, self.renderStarted, self.renderSuccess, self.renderError);
            (0, util_1.makeAbortableReaction)(self, () => ({
                assemblyNames: (0, tracks_1.getTrackAssemblyNames)(self.parentTrack),
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                adapter: (0, configuration_1.getConf)((0, mobx_state_tree_1.getParent)(self, 2), 'adapter'),
                assemblyManager: (0, util_1.getSession)(self).assemblyManager,
            }), 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            async ({ assemblyNames, adapter, assemblyManager }, signal) => {
                return assemblyManager.getRefNameMapForAdapter(adapter, assemblyNames[0], { signal, sessionId: (0, tracks_1.getRpcSessionId)(self) });
            }, {
                name: `${self.type} ${self.id} getting refNames`,
                fireImmediately: true,
            }, () => { }, refNameMap => {
                self.setRefNameMap(refNameMap);
            }, error => {
                console.error(error);
                self.setError(error);
            });
        },
    }));
}
exports.BaseChordDisplayModel = stateModelFactory();
//# sourceMappingURL=BaseChordDisplayModel.js.map