import { getConf } from '@jbrowse/core/configuration';
import { BaseDisplay } from '@jbrowse/core/pluggableElementTypes/models';
import CircularChordRendererType from '@jbrowse/core/pluggableElementTypes/renderers/CircularChordRendererType';
import { getContainingView, getSession, getEnv, makeAbortableReaction, } from '@jbrowse/core/util';
import { isFeature } from '@jbrowse/core/util/simpleFeature';
import { getParentRenderProps, getRpcSessionId, getTrackAssemblyNames, } from '@jbrowse/core/util/tracks';
import { getParent, isAlive, types } from 'mobx-state-tree';
// locals
import { renderReactionData, renderReactionEffect } from './renderReaction';
/**
 * #stateModel BaseChordDisplay
 * extends `BaseDisplay`
 */
function stateModelFactory() {
    return types
        .compose('BaseChordDisplay', BaseDisplay, types.model({
        /**
         * #property
         */
        bezierRadiusRatio: 0.1,
        /**
         * #property
         */
        assemblyName: types.maybe(types.string),
    }))
        .volatile(() => {
        return {
            // NOTE: all this volatile stuff has to be filled in at once
            // so that it stays consistent
            filled: false,
            reactElement: undefined,
            data: undefined,
            message: '',
            renderingComponent: undefined,
            refNameMap: undefined,
        };
    })
        .actions(self => {
        const { pluginManager } = getEnv(self);
        const track = self;
        return {
            /**
             * #action
             */
            onChordClick(feature) {
                getConf(self, 'onChordClick', { feature, track, pluginManager });
            },
        };
    })
        .views(self => ({
        /**
         * #getter
         */
        get blockDefinitions() {
            const origSlices = getContainingView(self)
                .staticSlices;
            if (!self.refNameMap) {
                return origSlices;
            }
            const slices = JSON.parse(JSON.stringify(origSlices));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            slices.forEach((slice) => {
                const regions = slice.region.elided
                    ? slice.region.regions
                    : [slice.region];
                regions.forEach((region) => {
                    var _a;
                    const renamed = (_a = self.refNameMap) === null || _a === void 0 ? void 0 : _a[region.refName];
                    if (renamed && region.refName !== renamed) {
                        region.refName = renamed;
                    }
                });
            });
            return slices;
        },
        /**
         * #method
         */
        renderProps() {
            const view = getContainingView(self);
            return {
                ...getParentRenderProps(self),
                rpcDriverName: self.rpcDriverName,
                displayModel: self,
                bezierRadius: view.radiusPx * self.bezierRadiusRatio,
                radius: view.radiusPx,
                blockDefinitions: this.blockDefinitions,
                onChordClick: self.onChordClick,
            };
        },
        /**
         * #getter
         * the pluggable element type object for this diplay's
         * renderer
         */
        get rendererType() {
            const display = self;
            const { pluginManager } = getEnv(self);
            const ThisRendererType = pluginManager.getRendererType(self.rendererTypeName);
            if (!ThisRendererType) {
                throw new Error(`renderer "${display.rendererTypeName}" not found`);
            }
            if (!ThisRendererType.ReactComponent) {
                throw new Error(`renderer ${display.rendererTypeName} has no ReactComponent, it may not be completely implemented yet`);
            }
            return ThisRendererType;
        },
        /**
         * #method
         */
        isCompatibleWithRenderer(renderer) {
            return !!(renderer instanceof CircularChordRendererType);
        },
        /**
         * #getter
         * returns a string feature ID if the globally-selected object
         * is probably a feature
         */
        get selectedFeatureId() {
            if (!isAlive(self)) {
                return undefined;
            }
            const session = getSession(self);
            if (!session) {
                return undefined;
            }
            const { selection } = session;
            // does it quack like a feature?
            if (isFeature(selection)) {
                return selection.id();
            }
            return undefined;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        renderStarted() {
            self.filled = false;
            self.message = '';
            self.reactElement = undefined;
            self.data = undefined;
            self.error = undefined;
            self.renderingComponent = undefined;
        },
        /**
         * #action
         */
        renderSuccess({ message, data, reactElement, renderingComponent, }) {
            if (message) {
                self.filled = false;
                self.message = message;
                self.reactElement = undefined;
                self.data = undefined;
                self.error = undefined;
                self.renderingComponent = undefined;
            }
            else {
                self.filled = true;
                self.message = '';
                self.reactElement = reactElement;
                self.data = data;
                self.error = undefined;
                self.renderingComponent = renderingComponent;
            }
        },
        /**
         * #action
         */
        renderError(error) {
            console.error(error);
            // the rendering failed for some reason
            self.filled = false;
            self.message = '';
            self.reactElement = undefined;
            self.data = undefined;
            self.error = error;
            self.renderingComponent = undefined;
        },
        /**
         * #action
         */
        setRefNameMap(refNameMap) {
            self.refNameMap = refNameMap;
        },
    }))
        .actions(self => ({
        afterAttach() {
            makeAbortableReaction(self, renderReactionData, 
            // @ts-ignore
            renderReactionEffect, {
                name: `${self.type} ${self.id} rendering`,
                // delay: self.renderDelay || 300,
                fireImmediately: true,
            }, self.renderStarted, self.renderSuccess, self.renderError);
            makeAbortableReaction(self, () => ({
                assemblyNames: getTrackAssemblyNames(self.parentTrack),
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                adapter: getConf(getParent(self, 2), 'adapter'),
                assemblyManager: getSession(self).assemblyManager,
            }), 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            async ({ assemblyNames, adapter, assemblyManager }, signal) => {
                return assemblyManager.getRefNameMapForAdapter(adapter, assemblyNames[0], { signal, sessionId: getRpcSessionId(self) });
            }, {
                name: `${self.type} ${self.id} getting refNames`,
                fireImmediately: true,
            }, () => { }, refNameMap => {
                self.setRefNameMap(refNameMap);
            }, error => {
                console.error(error);
                self.setError(error);
            });
        },
    }));
}
export const BaseChordDisplayModel = stateModelFactory();
//# sourceMappingURL=BaseChordDisplayModel.js.map