"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseAdapter_1 = require("@jbrowse/core/data_adapters/BaseAdapter");
const BaseResults_1 = __importDefault(require("@jbrowse/core/TextSearch/BaseResults"));
const configuration_1 = require("@jbrowse/core/configuration");
const HttpMap_1 = __importDefault(require("./HttpMap"));
//  Jbrowse1 text search adapter
// Uses index built by generate-names.pl
class JBrowse1TextSearchAdapter extends BaseAdapter_1.BaseAdapter {
    constructor(config, getSubAdapter, pluginManager) {
        super(config, getSubAdapter, pluginManager);
        const namesIndexLocation = (0, configuration_1.readConfObject)(config, 'namesIndexLocation');
        if (!namesIndexLocation) {
            throw new Error('must provide namesIndexLocation');
        }
        this.httpMap = new HttpMap_1.default({
            url: namesIndexLocation.baseUri
                ? new URL(namesIndexLocation.uri, namesIndexLocation.baseUri).href
                : namesIndexLocation.uri,
        });
    }
    /**
     * Returns the contents of the file containing the query if it exists
     * else it returns empty
     * @param query - string query
     */
    async loadIndexFile(query) {
        return this.httpMap.getBucket(query);
    }
    async searchIndex(args) {
        const { searchType, queryString } = args;
        const tracks = this.tracksNames || (await this.httpMap.getTrackNames());
        const entries = await this.loadIndexFile(queryString.toLowerCase());
        if (entries[queryString]) {
            return this.formatResults(entries[queryString], tracks, searchType);
        }
        return [];
    }
    formatResults(results, tracks, searchType) {
        return [
            ...(searchType === 'exact'
                ? []
                : results.prefix.map(result => {
                    return new BaseResults_1.default({
                        label: typeof result === 'object' ? result.name : result,
                        matchedAttribute: 'name',
                        matchedObject: { result: result },
                    });
                })),
            ...results.exact.map(result => {
                const name = result[0];
                const trackIndex = result[1];
                const refName = result[3];
                const start = result[4];
                const end = result[5];
                const locstring = `${refName || name}:${start}-${end}`;
                return new BaseResults_1.default({
                    locString: locstring,
                    label: name,
                    matchedAttribute: 'name',
                    matchedObject: result,
                    trackId: tracks[trackIndex],
                });
            }),
        ].filter(result => result.getLabel() !== 'too many matches');
    }
    freeResources() { }
}
exports.default = JBrowse1TextSearchAdapter;
//# sourceMappingURL=JBrowse1TextSearchAdapter.js.map