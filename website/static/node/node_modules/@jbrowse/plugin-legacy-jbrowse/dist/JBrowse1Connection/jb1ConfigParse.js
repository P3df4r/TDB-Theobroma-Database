"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.regularizeConf = exports.parseJB1Conf = exports.parseJB1Json = void 0;
/* eslint no-cond-assign: ["error", "except-parens"] */
const get_value_1 = __importDefault(require("get-value"));
const set_value_1 = __importDefault(require("set-value"));
const util_1 = require("@jbrowse/core/util");
const util_2 = require("./util");
function parseJB1Json(config, url) {
    if (typeof config === 'string') {
        let parsedConf;
        try {
            parsedConf = JSON.parse(config);
        }
        catch (error) {
            throw new Error(`${error} when parsing configuration.`);
        }
        return regularizeConf(parsedConf, url);
    }
    return regularizeConf(config, url);
}
exports.parseJB1Json = parseJB1Json;
function parseJB1Conf(config, url) {
    let parsedConf;
    try {
        parsedConf = parse(config, url);
    }
    catch (error) {
        throw new Error(`${error} when parsing configuration.`);
    }
    return regularizeConf(parsedConf, url);
}
exports.parseJB1Conf = parseJB1Conf;
function isAlwaysArray(varName) {
    if (varName === 'include') {
        return true;
    }
    return false;
}
function parse(text, url) {
    let section = [];
    let keyPath;
    let operation;
    let value;
    const data = { tracks: {} };
    let lineNumber;
    function recordVal() {
        if (value !== undefined) {
            let parsedValue;
            try {
                // parse json
                const match = value.match(/^json:(.+)/i);
                if (match) {
                    parsedValue = JSON.parse(match[1]);
                }
                // parse numbers if it looks numeric
                else if (/^[+-]?[\d.,]+([eE][-+]?\d+)?$/.test(value)) {
                    parsedValue = parseFloat(value.replace(/,/g, ''));
                }
                else {
                    parsedValue = value;
                }
                if (!keyPath) {
                    throw new Error(`Error parsing in section ${section.join(' - ')}`);
                }
                const path = section.concat(keyPath).join('.');
                if (operation === '+=') {
                    let existing = (0, get_value_1.default)(data, path);
                    if (existing) {
                        if (!Array.isArray(existing)) {
                            existing = [existing];
                        }
                    }
                    else {
                        existing = [];
                    }
                    existing.push(parsedValue);
                    parsedValue = existing;
                }
                if (parsedValue === 'true') {
                    parsedValue = true;
                }
                if (parsedValue === 'false') {
                    parsedValue = false;
                }
                (0, set_value_1.default)(data, path, parsedValue);
            }
            catch (e) {
                throw new Error(`syntax error${url ? ` in ${url}` : ''}${lineNumber ? ` at line ${lineNumber - 1}` : ''}`);
            }
        }
    }
    text.split(/\n|\r\n|\r/).forEach((textLine, i) => {
        lineNumber = i + 1;
        const line = textLine.replace(/^\s*#.+/, '');
        // new section
        let match;
        if ((match = line.match(/^\s*\[([^\]]+)/))) {
            // new section
            recordVal();
            keyPath = undefined;
            value = undefined;
            section = match[1].trim().split(/\s*\.\s*/);
            if (section.length === 1 && section[0].toLowerCase() === 'general') {
                section = [];
            }
        }
        // new value
        else if ((match = line.match(value === undefined ? /^([^+=]+)(\+?=)(.*)/ : /^(\S[^+=]+)(\+?=)(.*)/))) {
            recordVal();
            keyPath = match[1].trim().split(/\s*\.\s*/);
            [, , operation] = match;
            if (isAlwaysArray(section.concat(keyPath).join('.'))) {
                operation = '+=';
            }
            value = match[3].trim();
        }
        // add to existing array value
        else if (keyPath !== undefined &&
            (match = line.match(/^\s{0,4}\+\s*(.+)/))) {
            recordVal();
            operation = '+=';
            value = match[1].trim();
        }
        // add to existing value
        else if (value !== undefined && (match = line.match(/^\s+(\S.*)/))) {
            value += value.length ? ` ${match[1].trim()}` : match[1].trim();
        }
        // done with last value
        else {
            recordVal();
            keyPath = undefined;
            value = undefined;
        }
    });
    recordVal();
    return data;
}
/**
 * Applies defaults and any other necessary tweaks to the loaded configuration.
 * @param conf - the object containing the configuration, which it modifies
 * in-place
 * @param url - URL of the config file
 * @returns the same object it was passed
 */
function regularizeConf(conf, url) {
    // if tracks is not an array, convert it to one
    if (conf.tracks && !Array.isArray(conf.tracks)) {
        // if it's a single track config, wrap it in an arrayref
        if ((0, util_2.isTrack)(conf.tracks)) {
            conf.tracks = [conf.tracks];
        }
        // otherwise, coerce it to an array
        else {
            const tracks = [];
            for (const label of Object.keys(conf.tracks)) {
                const track = conf.tracks[label];
                if ((0, util_2.isTrack)(track)) {
                    tracks.push(track);
                }
                else {
                    tracks.push({ label, ...track });
                }
            }
            conf.tracks = tracks;
        }
    }
    // regularize trackMetadata.sources
    const meta = conf.trackMetadata;
    if (meta && meta.sources) {
        // if it's a single source config, wrap it in an arrayref
        if (typeof meta.sources === 'string') {
            meta.sources = [meta.sources];
        }
        if ((0, util_2.isSource)(meta.sources)) {
            meta.sources = [meta.sources];
        }
        if (!Array.isArray(meta.sources)) {
            const sources = [];
            for (const name of Object.keys(meta.sources)) {
                const source = meta.sources[name];
                if (!('name' in source)) {
                    source.name = name;
                }
                sources.push(source);
            }
            meta.sources = sources;
        }
        // coerce any string source defs to be URLs, and try to detect their types
        meta.sources = meta.sources.map((sourceDef) => {
            if (typeof sourceDef === 'string') {
                const newSourceDef = { url: sourceDef };
                const typeMatch = sourceDef.match(/\.(\w+)$/);
                if (typeMatch) {
                    newSourceDef.type = typeMatch[1].toLowerCase();
                }
                return newSourceDef;
            }
            return sourceDef;
        });
    }
    conf.sourceUrl = conf.sourceUrl || url;
    if (conf.sourceUrl.startsWith('/')) {
        conf.sourceUrl = new URL(conf.sourceUrl, window.location.href).href;
    }
    conf.baseUrl = conf.baseUrl || new URL('.', conf.sourceUrl).href;
    if (conf.baseUrl.length && !conf.baseUrl.endsWith('/')) {
        conf.baseUrl += '/';
    }
    if (conf.sourceUrl) {
        // set a default baseUrl in each of the track and store confs, and the names
        // conf, if needed
        const addBase = [];
        if (conf.tracks) {
            addBase.push(...conf.tracks);
        }
        if (conf.stores) {
            addBase.push(...Object.values(conf.stores));
        }
        if (conf.names) {
            addBase.push(conf.names);
        }
        addBase.forEach((t) => {
            if (!t.baseUrl) {
                t.baseUrl = conf.baseUrl || '/';
            }
        });
        // resolve the refSeqs and nameUrl if present
        if (conf.refSeqs && typeof conf.refSeqs === 'string') {
            conf.refSeqs = new URL(conf.refSeqs, conf.sourceUrl).href;
        }
        if (conf.nameUrl) {
            conf.nameUrl = new URL(conf.nameUrl, conf.sourceUrl).href;
        }
    }
    conf.stores = conf.stores || {};
    (conf.tracks || []).forEach((trackConfig) => {
        // if there is a `config` subpart, just copy its keys in to the top-level
        // config
        if (trackConfig.config) {
            const c = trackConfig.config;
            delete trackConfig.config;
            trackConfig = { ...c, ...trackConfig };
        }
        // skip if it's a new-style track def
        if (trackConfig.store) {
            return;
        }
        let trackClassName;
        if (trackConfig.type === 'FeatureTrack') {
            trackClassName = 'JBrowse/View/Track/HTMLFeatures';
        }
        else if (trackConfig.type === 'ImageTrack') {
            trackClassName = 'JBrowse/View/Track/FixedImage';
        }
        else if (trackConfig.type === 'ImageTrack.Wiggle') {
            trackClassName = 'JBrowse/View/Track/FixedImage/Wiggle';
        }
        else if (trackConfig.type === 'SequenceTrack') {
            trackClassName = 'JBrowse/View/Track/Sequence';
        }
        else {
            trackClassName = regularizeClass('JBrowse/View/Track', trackConfig.type);
        }
        trackConfig.type = trackClassName;
        synthesizeTrackStoreConfig(conf, trackConfig);
        if (trackConfig.histograms) {
            if (!trackConfig.histograms.baseUrl) {
                trackConfig.histograms.baseUrl = trackConfig.baseUrl;
            }
            synthesizeTrackStoreConfig(conf, trackConfig.histograms);
        }
    });
    return conf;
}
exports.regularizeConf = regularizeConf;
/**
 * prefix class name with `root` if it contains no slashes
 * @param root - Prefix root
 * @param className - class name
 */
function regularizeClass(root, className) {
    if (!className) {
        return '';
    }
    if (!className.includes('/')) {
        className = `${root}/${className}`;
    }
    className = className.replace(/^\//, '');
    return className;
}
function guessStoreClass(trackConfig, urlTemplate) {
    if (!trackConfig) {
        return '';
    }
    if (trackConfig.type && trackConfig.type.includes('/FixedImage')) {
        return `JBrowse/Store/TiledImage/Fixed${trackConfig.backendVersion === 0 ? '_v0' : ''}`;
    }
    if (/\.jsonz?$/i.test(urlTemplate)) {
        return `JBrowse/Store/SeqFeature/NCList${trackConfig.backendVersion === 0 ? '_v0' : ''}`;
    }
    if (/\.bam$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/BAM';
    }
    if (/\.cram$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/CRAM';
    }
    if (/\.gff3?$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/GFF3';
    }
    if (/\.bed$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/BED';
    }
    if (/\.vcf.b?gz$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/VCFTabix';
    }
    if (/\.gff3?.b?gz$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/GFF3Tabix';
    }
    if (/\.bed.b?gz$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/BEDTabix';
    }
    if (/\.(bw|bigwig)$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/BigWig';
    }
    if (/\.(bb|bigbed)$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/BigBed';
    }
    if (/\.(fa|fasta)$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/IndexedFasta';
    }
    if (/\.(fa|fasta)\.b?gz$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/BgzipIndexedFasta';
    }
    if (/\.2bit$/i.test(urlTemplate)) {
        return 'JBrowse/Store/SeqFeature/TwoBit';
    }
    if (trackConfig.type && trackConfig.type.endsWith('/Sequence')) {
        return 'JBrowse/Store/Sequence/StaticChunked';
    }
    return '';
}
function synthesizeTrackStoreConfig(mainConf, trackConfig) {
    // figure out what data store class to use with the track, applying some
    // defaults if it is not explicit in the configuration
    const { urlTemplate = '' } = trackConfig;
    let storeClass;
    if (trackConfig.storeClass) {
        storeClass = regularizeClass('JBrowse/Store', trackConfig.storeClass);
    }
    else {
        storeClass = guessStoreClass(trackConfig, urlTemplate);
    }
    if (!storeClass) {
        console.warn(`Unable to determine an appropriate data store to use with track '${trackConfig.label}', please explicitly specify a storeClass in the configuration.`);
        return;
    }
    // synthesize a separate store conf
    const storeConf = { ...trackConfig, type: storeClass };
    // if this is the first sequence store we see, and we have no refseqs store
    // defined explicitly, make this the refseqs store.
    if ((storeClass === 'JBrowse/Store/Sequence/StaticChunked' ||
        storeClass === 'JBrowse/Store/Sequence/IndexedFasta' ||
        storeClass === 'JBrowse/Store/SeqFeature/IndexedFasta' ||
        storeClass === 'JBrowse/Store/SeqFeature/BgzipIndexedFasta' ||
        storeClass === 'JBrowse/Store/SeqFeature/TwoBit' ||
        storeClass === 'JBrowse/Store/Sequence/TwoBit' ||
        trackConfig.useAsRefSeqStore) &&
        !(mainConf.stores && mainConf.stores.refseqs)) {
        storeConf.name = 'refseqs';
    }
    else {
        storeConf.name = `store${(0, util_1.objectHash)(storeConf)}`;
    }
    // record it
    if (!mainConf.stores) {
        mainConf.stores = {};
    }
    mainConf.stores[storeConf.name] = storeConf;
    // connect it to the track conf
    trackConfig.store = storeConf.name;
}
//# sourceMappingURL=jb1ConfigParse.js.map