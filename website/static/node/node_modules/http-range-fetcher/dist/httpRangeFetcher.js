"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-nocheck
var quick_lru_1 = __importDefault(require("quick-lru"));
var cacheSemantics_1 = require("./cacheSemantics");
var aggregatingFetcher_1 = __importDefault(require("./aggregatingFetcher"));
var crossFetchBinaryRange_1 = __importDefault(require("./crossFetchBinaryRange"));
/**
 * check if the given exception was caused by an operation being intentionally aborted
 * @param {Error} exception
 * @returns {boolean}
 */
function isAbortException(exception) {
    return (
    // DOMException
    exception.name === 'AbortError' ||
        // standard-ish non-DOM abort exception
        // @ts-ignore
        exception.code === 'ERR_ABORTED' ||
        // message contains aborted for bubbling through RPC
        // things we have seen that we want to catch here
        // Error: aborted
        // AbortError: aborted
        // AbortError: The user aborted a request.
        !!exception.message.match(/\b(aborted|AbortError)\b/i));
}
// TODO: fire events when a remote file is detected as having been changed
/**
 * smart cache that fetches chunks of remote files.
 * caches chunks in an LRU cache, and aggregates upstream fetches
 */
var HttpRangeFetcher = /** @class */ (function () {
    /**
     * @param {object} args the arguments object
     * @param {number} [args.fetch] callback with signature `(key, start, end) => Promise({ headers, buffer })`
     * @param {number} [args.size] size in bytes of cache to keep
     * @param {number} [args.chunkSize] size in bytes of cached chunks
     * @param {number} [args.aggregationTime] time in ms over which to pool requests before dispatching them
     * @param {number} [args.minimumTTL] time in ms a non-cacheable response will be cached
     * @param {number} [args.maxFetchSize] maximum size of an aggregated request
     * @param {number} [args.maxExtraFetch] max number of additional bytes to fetch when aggregating requests
     * that don't actually overlap
     */
    function HttpRangeFetcher(_a) {
        var _b = _a.fetch, fetch = _b === void 0 ? crossFetchBinaryRange_1.default : _b, _c = _a.size, size = _c === void 0 ? 10000000 : _c, _d = _a.chunkSize, chunkSize = _d === void 0 ? 32768 : _d, _e = _a.aggregationTime, aggregationTime = _e === void 0 ? 100 : _e, _f = _a.minimumTTL, minimumTTL = _f === void 0 ? 1000 : _f, _g = _a.maxFetchSize, maxFetchSize = _g === void 0 ? chunkSize * 4 : _g, _h = _a.maxExtraFetch, maxExtraFetch = _h === void 0 ? chunkSize : _h;
        this.aggregator = new aggregatingFetcher_1.default({
            fetch: fetch,
            frequency: aggregationTime,
            maxFetchSize: maxFetchSize,
            maxExtraSize: maxExtraFetch,
        });
        this.chunkSize = chunkSize;
        this.chunkCache = new quick_lru_1.default({ maxSize: Math.floor(size / chunkSize) || 1 });
        this.cacheSemantics = new cacheSemantics_1.CacheSemantics({ minimumTTL: minimumTTL });
        this.stats = new quick_lru_1.default({ maxSize: 20 });
    }
    /**
     * Fetch a range of a remote resource.
     * @param {string} key the resource's unique identifier, this would usually be a URL.
     * This is passed along to the fetch callback.
     * @param {number} [position] offset in the file at which to start fetching
     * @param {number} [length] number of bytes to fetch, defaults to the remainder of the file
     * @param {object} [options] request options
     * @param {AbortSignal} [options.signal] AbortSignal object that can be used to abort the fetch
     */
    HttpRangeFetcher.prototype.getRange = function (key, position, requestedLength, options) {
        if (position === void 0) { position = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var length, stat, firstChunk, lastChunk, fetches, _loop_1, this_1, chunk, chunkResponses, chunksOffset;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        length = requestedLength;
                        if (!(length === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.stat(key)];
                    case 1:
                        stat = _a.sent();
                        if (stat.size === undefined) {
                            throw new Error("length not specified, and could not determine size of the remote file");
                        }
                        length = stat.size - position;
                        _a.label = 2;
                    case 2:
                        firstChunk = Math.floor(position / this.chunkSize);
                        lastChunk = Math.floor((position + length - 1) / this.chunkSize);
                        fetches = new Array(lastChunk - firstChunk + 1);
                        _loop_1 = function (chunk) {
                            fetches[chunk - firstChunk] = this_1._getChunk(key, chunk, options).then(function (response) {
                                return response && {
                                    headers: response.headers,
                                    buffer: response.buffer,
                                    chunkNumber: chunk,
                                };
                            });
                        };
                        this_1 = this;
                        for (chunk = firstChunk; chunk <= lastChunk; chunk += 1) {
                            _loop_1(chunk);
                        }
                        return [4 /*yield*/, Promise.all(fetches)];
                    case 3:
                        chunkResponses = _a.sent();
                        chunkResponses = chunkResponses.filter(function (r) { return !!r; }); // filter out any undefined (out of range) responses
                        if (!chunkResponses.length) {
                            return [2 /*return*/, { headers: {}, buffer: Buffer.allocUnsafe(0) }];
                        }
                        chunksOffset = position - chunkResponses[0].chunkNumber * this.chunkSize;
                        return [2 /*return*/, {
                                headers: this._makeHeaders(chunkResponses[0].headers, position, position + length - 1),
                                buffer: this._makeBuffer(chunkResponses, chunksOffset, length),
                            }];
                }
            });
        });
    };
    HttpRangeFetcher.prototype._makeBuffer = function (chunkResponses, chunksOffset, length) {
        if (chunkResponses.length === 1) {
            return chunkResponses[0].buffer.slice(chunksOffset, chunksOffset + length);
        }
        else if (chunkResponses.length === 0) {
            return Buffer.allocUnsafe(0);
        }
        // 2 or more buffers
        var buffers = chunkResponses.map(function (r) { return r.buffer; });
        var first = buffers.shift().slice(chunksOffset);
        var last = buffers.pop();
        var trimEnd = first.length +
            buffers.reduce(function (sum, buf) { return sum + buf.length; }, 0) +
            last.length -
            length;
        if (trimEnd < 0) {
            trimEnd = 0;
        }
        last = last.slice(0, last.length - trimEnd);
        return Buffer.concat(__spreadArray(__spreadArray([first], buffers, true), [last], false));
    };
    /**
     * Fetches the first few bytes of the remote file (if necessary) and uses
     * the returned headers to populate a `fs`-like stat object.
     *
     * Currently, this attempts to set `size`, `mtime`, and `mtimeMs`, if
     * the information is available from HTTP headers.
     *
     * @param {string} key
     * @returns {Promise} for a stats object
     */
    HttpRangeFetcher.prototype.stat = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var stat, chunk;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        stat = this.stats.get(key);
                        if (!!stat) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._getChunk(key, 0)];
                    case 1:
                        chunk = _a.sent();
                        this._recordStatsIfNecessary(key, chunk);
                        stat = this.stats.get(key);
                        if (!stat) {
                            throw new Error("failed to retrieve file size for ".concat(key));
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, stat];
                }
            });
        });
    };
    HttpRangeFetcher.prototype._headersToStats = function (chunkResponse) {
        var headers = chunkResponse.headers;
        var stat = {};
        if (headers['content-range']) {
            var match = headers['content-range'].match(/\d+-\d+\/(\d+)/);
            if (match) {
                stat.size = parseInt(match[1], 10);
                if (Number.isNaN(stat.size)) {
                    delete stat.size;
                }
            }
        }
        if (headers['last-modified']) {
            stat.mtime = new Date(headers['last-modified']);
            if (stat.mtime.toString() === 'Invalid Date') {
                delete stat.mtime;
            }
            if (stat.mtime) {
                stat.mtimeMs = stat.mtime.getTime();
            }
        }
        return stat;
    };
    HttpRangeFetcher.prototype._makeHeaders = function (originalHeaders, newStart, newEnd) {
        var newHeaders = Object.assign({}, originalHeaders || {});
        newHeaders['content-length'] = newEnd - newStart;
        var oldContentRange = newHeaders['content-range'] || '';
        var match = oldContentRange.match(/\d+-\d+\/(\d+)/);
        if (match) {
            newHeaders['content-range'] = "".concat(newStart, "-").concat(newEnd - 1, "/").concat(match[1]);
            // eslint-disable-next-line prefer-destructuring
            newHeaders['x-resource-length'] = match[1];
        }
        return newHeaders;
    };
    HttpRangeFetcher.prototype._getChunk = function (key, chunkNumber, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var chunkKey, cachedPromise, chunk, chunkAborted, err_1, fetchStart, fetchEnd, stat, alreadyRejected, freshPromise, freshChunk;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        chunkKey = "".concat(key, "/").concat(chunkNumber);
                        cachedPromise = this.chunkCache.get(chunkKey);
                        if (!cachedPromise) return [3 /*break*/, 5];
                        chunk = void 0;
                        chunkAborted = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, cachedPromise];
                    case 2:
                        chunk = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        if (isAbortException(err_1)) {
                            // fetch was aborted
                            chunkAborted = true;
                        }
                        else {
                            throw err_1;
                        }
                        return [3 /*break*/, 4];
                    case 4:
                        // when the cached chunk is resolved, validate it before returning it.
                        // if invalid or aborted, delete it from the cache and redispatch the request
                        if (chunkAborted || !this.cacheSemantics.cachedChunkIsValid(chunk)) {
                            this._uncacheIfSame(chunkKey, cachedPromise);
                            return [2 /*return*/, this._getChunk(key, chunkNumber, requestOptions)];
                        }
                        // gather the stats for the file from the headers
                        this._recordStatsIfNecessary(key, chunk);
                        return [2 /*return*/, chunk];
                    case 5:
                        fetchStart = chunkNumber * this.chunkSize;
                        fetchEnd = fetchStart + this.chunkSize;
                        stat = this.stats.get(key);
                        if (stat && stat.size) {
                            if (fetchStart >= stat.size) {
                                return [2 /*return*/, undefined];
                            }
                            if (fetchEnd >= stat.size) {
                                fetchEnd = stat.size;
                            }
                        }
                        alreadyRejected = false;
                        freshPromise = this.aggregator
                            .fetch(key, fetchStart, fetchEnd, requestOptions)
                            .catch(function (err) {
                            // if the request fails, remove its promise
                            // from the cache and keep the error
                            alreadyRejected = true;
                            _this._uncacheIfSame(chunkKey, freshPromise);
                            throw err;
                        });
                        if (!alreadyRejected) {
                            this.chunkCache.set(chunkKey, freshPromise);
                        }
                        return [4 /*yield*/, freshPromise
                            // gather the stats for the file from the headers
                        ];
                    case 6:
                        freshChunk = _a.sent();
                        // gather the stats for the file from the headers
                        this._recordStatsIfNecessary(key, freshChunk);
                        // remove the promise from the cache
                        // if it turns out not to be cacheable. this is
                        // done after the fact because we want multiple requests
                        // for the same chunk to reuse the same cached promise
                        if (!this.cacheSemantics.chunkIsCacheable(freshChunk)) {
                            this._uncacheIfSame(chunkKey, freshPromise);
                        }
                        return [2 /*return*/, freshChunk];
                }
            });
        });
    };
    // if the stats for a resource haven't been recorded yet, record them
    HttpRangeFetcher.prototype._recordStatsIfNecessary = function (key, chunk) {
        if (!this.stats.has(key)) {
            this.stats.set(key, this._headersToStats(chunk));
        }
    };
    // delete a promise from the cache if it is still in there.
    // need to check if it is still the same because it might
    // have been overwritten sometime while the promise was in flight
    HttpRangeFetcher.prototype._uncacheIfSame = function (key, cachedPromise) {
        if (this.chunkCache.get(key) === cachedPromise) {
            this.chunkCache.delete(key);
        }
    };
    /**
     * Throw away all cached data, resetting the cache.
     */
    HttpRangeFetcher.prototype.reset = function () {
        this.stats.clear();
        this.chunkCache.clear();
    };
    return HttpRangeFetcher;
}());
exports.default = HttpRangeFetcher;
//# sourceMappingURL=httpRangeFetcher.js.map