"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-nocheck
var object_entries_ponyfill_1 = __importDefault(require("object.entries-ponyfill"));
var abortcontroller_ponyfill_1 = require("./abortcontroller-ponyfill");
/**
 * takes fetch requests and aggregates them at a certain time frequency
 */
var AggregatingFetcher = /** @class */ (function () {
    /**
     *
     * @param {object} params
     * @param {number} [params.frequency] number of milliseconds to wait for requests to aggregate
     */
    function AggregatingFetcher(_a) {
        var _b = _a.frequency, frequency = _b === void 0 ? 100 : _b, fetch = _a.fetch, _c = _a.maxExtraSize, maxExtraSize = _c === void 0 ? 32000 : _c, _d = _a.maxFetchSize, maxFetchSize = _d === void 0 ? 1000000 : _d;
        this.requestQueues = {}; // url => array of requests
        this.fetchCallback = fetch;
        this.frequency = frequency;
        this.maxExtraSize = maxExtraSize;
        this.maxFetchSize = maxFetchSize;
    }
    AggregatingFetcher.prototype._canAggregate = function (requestGroup, request) {
        return (
        // the fetches overlap, or come close
        request.start <= requestGroup.end + this.maxExtraSize &&
            // aggregating would not result in a fetch that is too big
            request.end - request.start + requestGroup.end - requestGroup.start <
                this.maxFetchSize);
    };
    // returns a promise that only resolves
    // when all of the signals in the given array
    // have fired their abort signal
    AggregatingFetcher.prototype._allSignalsFired = function (signals) {
        return new Promise(function (resolve) {
            var signalsLeft = signals.filter(function (s) { return !s.aborted; }).length;
            signals.forEach(function (signal) {
                signal.addEventListener('abort', function () {
                    signalsLeft -= 1;
                    // console.log('aggregatingfetcher received an abort')
                    if (!signalsLeft) {
                        // console.log('aggregatingfetcher aborting aggegated request')
                        resolve();
                    }
                });
            });
        }).catch(function (e) {
            // eslint-disable-next-line no-console
            console.error(e);
        });
    };
    // dispatch a request group as a single request
    // and then slice the result back up to satisfy
    // the individual requests
    AggregatingFetcher.prototype._dispatch = function (_a) {
        // if any of the requests have an AbortSignal `signal` in their requestOptions,
        // make our aggregating abortcontroller track it, aborting the request if
        // all of the abort signals that are aggregated here have fired
        var url = _a.url, start = _a.start, end = _a.end, requests = _a.requests;
        var abortWholeRequest = new abortcontroller_ponyfill_1.AbortController();
        var signals = [];
        requests.forEach(function (_a) {
            var requestOptions = _a.requestOptions;
            if (requestOptions && requestOptions.signal) {
                signals.push(requestOptions.signal);
            }
        });
        if (signals.length === requests.length) {
            this._allSignalsFired(signals).then(function () { return abortWholeRequest.abort(); });
        }
        this.fetchCallback(url, start, end - 1, {
            signal: abortWholeRequest.signal,
        }).then(function (response) {
            var data = response.buffer;
            requests.forEach(function (_a) {
                var reqStart = _a.start, reqEnd = _a.end, resolve = _a.resolve;
                // remember Buffer.slice does not copy, it creates
                // an offset child buffer pointing to the same data
                resolve({
                    headers: response.headers,
                    buffer: data.slice(reqStart - start, reqEnd - start),
                });
            });
        }, function (err) {
            requests.forEach(function (_a) {
                var reject = _a.reject;
                return reject(err);
            });
        });
    };
    AggregatingFetcher.prototype._aggregateAndDispatch = function () {
        var _this = this;
        (0, object_entries_ponyfill_1.default)(this.requestQueues).forEach(function (_a) {
            var url = _a[0], requests = _a[1];
            if (!requests || !requests.length) {
                return;
            }
            // console.log(url, requests)
            // we are now going to aggregate the requests in this url's queue
            // into groups of requests that can be dispatched as one
            var requestsToDispatch = [];
            // look to see if any of the requests are aborted, and if they are, just
            // reject them now and forget about them
            requests.forEach(function (request) {
                var requestOptions = request.requestOptions, reject = request.reject;
                if (requestOptions &&
                    requestOptions.signal &&
                    requestOptions.signal.aborted) {
                    reject(Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' }));
                }
                else {
                    requestsToDispatch.push(request);
                }
            });
            requestsToDispatch.sort(function (a, b) { return a.start - b.start; });
            // eslint-disable-next-line no-param-reassign
            requests.length = 0;
            if (!requestsToDispatch.length) {
                return;
            }
            var currentRequestGroup;
            for (var i = 0; i < requestsToDispatch.length; i += 1) {
                var next = requestsToDispatch[i];
                if (currentRequestGroup &&
                    _this._canAggregate(currentRequestGroup, next)) {
                    // aggregate it into the current group
                    currentRequestGroup.requests.push(next);
                    currentRequestGroup.end = next.end;
                }
                else {
                    // out of range, dispatch the current request group
                    if (currentRequestGroup) {
                        _this._dispatch(currentRequestGroup);
                    }
                    // and start on a new one
                    currentRequestGroup = {
                        requests: [next],
                        url: url,
                        start: next.start,
                        end: next.end,
                    };
                }
            }
            if (currentRequestGroup) {
                _this._dispatch(currentRequestGroup);
            }
        });
    };
    AggregatingFetcher.prototype._enQueue = function (url, request) {
        if (!this.requestQueues[url]) {
            this.requestQueues[url] = [];
        }
        this.requestQueues[url].push(request);
    };
    /**
     *
     * @param {string} url
     * @param {number} start 0-based half-open
     * @param {number} end 0-based half-open
     * @param {object} [requestOptions] options passed to the underlying fetch call
     */
    AggregatingFetcher.prototype.fetch = function (url, start, end, requestOptions) {
        var _this = this;
        if (requestOptions === void 0) { requestOptions = {}; }
        return new Promise(function (resolve, reject) {
            _this._enQueue(url, { start: start, end: end, resolve: resolve, reject: reject, requestOptions: requestOptions });
            if (!_this.timeout) {
                _this.timeout = setTimeout(function () {
                    _this.timeout = undefined;
                    _this._aggregateAndDispatch();
                }, _this.frequency || 1);
            }
        });
    };
    return AggregatingFetcher;
}());
exports.default = AggregatingFetcher;
//# sourceMappingURL=aggregatingFetcher.js.map